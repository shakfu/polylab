<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="sa.20110119002240.1264" a="E"><vh>custom bash file</vh>
<v t="sa.20110121142539.1490" a="E"><vh>current</vh>
<v t="sa.20110128155259.1959"><vh>@@file /home/sa/.bashrc</vh></v>
</v>
<v t="sa.20110128155259.1958"><vh>backup</vh>
<v t="sa.20110119002240.1266"><vh>backup /home/sa/tmp/bashrc_new.sh</vh>
<v t="sa.20110119002240.1268"><vh>setup</vh>
<v t="sa.20110119002240.1272"><vh>start</vh></v>
<v t="sa.20110119002240.1271"><vh>history control</vh></v>
<v t="sa.20110119002240.1277"><vh>shell options</vh></v>
<v t="sa.20110119002240.1279"><vh>less options</vh></v>
<v t="sa.20110119002240.1278"><vh>debian specific</vh></v>
<v t="sa.20110119002240.1273"><vh>color prompt</vh></v>
<v t="sa.20110119002240.1274"><vh>color ls</vh></v>
<v t="sa.20110119002240.1275"><vh>bash completion</vh></v>
<v t="sa.20110119002240.1267"><vh>external alias file</vh></v>
</v>
<v t="sa.20110119002240.1276"><vh>aliases</vh>
<v t="sa.20110119002240.1280"><vh>alert</vh></v>
</v>
<v t="sa.20110119002240.1281"><vh>exports</vh></v>
<v t="sa.20110119002240.1269"><vh>functions</vh>
<v t="sa.20110119013021.1356"><vh>permissions</vh>
<v t="sa.20110119013021.1357"><vh>sanitize</vh></v>
<v t="sa.20110119013021.1365"><vh>fix</vh></v>
<v t="sa.20110119013021.1372"><vh>own</vh></v>
<v t="sa.20110119013021.1380"><vh>xchown</vh></v>
<v t="sa.20110119013021.1385"><vh>resetp</vh></v>
</v>
<v t="sa.20110119013021.1324"><vh>files</vh>
<v t="sa.20110119013021.1325"><vh>fixlines</vh></v>
<v t="sa.20110119013021.1335"><vh>delete</vh></v>
<v t="sa.20110119013021.1336"><vh>cp_p</vh></v>
<v t="sa.20110119013021.1301"><vh>bak</vh></v>
<v t="sa.20110119013021.1337"><vh>lcfiles</vh></v>
<v t="sa.20110119013021.1338"><vh>lowercase</vh></v>
<v t="sa.20110119013021.1339"><vh>rmspaces</vh></v>
<v t="sa.20110119013021.1340"><vh>linesort</vh></v>
<v t="sa.20110119013021.1341"><vh>removeduplines</vh></v>
<v t="sa.20110119013021.1358"><vh>saveit</vh></v>
<v t="sa.20110119013021.1359"><vh>safeedit</vh></v>
<v t="sa.20110119013021.1361"><vh>showfile</vh></v>
<v t="sa.20110119013021.1377"><vh>tmv</vh></v>
<v t="sa.20110119013021.1378"><vh>underscore</vh></v>
<v t="sa.20110119013021.1379"><vh>vimcmd</vh></v>
<v t="sa.20110119013021.1381"><vh>zero</vh></v>
</v>
<v t="sa.20110119013021.1316"><vh>directories</vh>
<v t="sa.20110119013021.1334"><vh>ls stuff</vh></v>
<v t="sa.20110119013021.1318"><vh>dubigf</vh></v>
<v t="sa.20110119013021.1305"><vh>cds</vh></v>
<v t="sa.20110119013021.1317"><vh>ds</vh></v>
<v t="sa.20110119013021.1342"><vh>mcdr</vh></v>
<v t="sa.20110119013021.1303"><vh>blank_rename</vh></v>
<v t="sa.20110119013021.1346"><vh>newHeadline</vh></v>
</v>
<v t="sa.20110119013021.1322"><vh>find and replace</vh>
<v t="sa.20110119013021.1360"><vh>searchnreplace</vh></v>
<v t="sa.20110119013021.1320"><vh>find a file</vh></v>
<v t="sa.20110119013021.1321"><vh>find pattern in files</vh></v>
<v t="sa.20110119013021.1323"><vh>meaning of error code</vh></v>
</v>
<v t="sa.20110119013021.1328"><vh>text</vh>
<v t="sa.20110119013021.1329"><vh>getcolumn</vh></v>
<v t="sa.20110119013021.1304"><vh>box</vh></v>
<v t="sa.20110119013021.1349"><vh>most_frequent</vh></v>
<v t="sa.20110119013021.1353"><vh>println</vh></v>
</v>
<v t="sa.20110119013021.1364"><vh>docs</vh>
<v t="sa.20110119013021.1368"><vh>doc</vh></v>
<v t="sa.20110119013021.1296"><vh>archwikisearch</vh></v>
<v t="sa.20110119013021.1371"><vh>man2text</vh></v>
<v t="sa.20110119013021.1375"><vh>rtfm</vh></v>
</v>
<v t="sa.20110119013021.1369"><vh>info</vh>
<v t="sa.20110119013021.1370"><vh>ii</vh></v>
<v t="sa.20110119013021.1376"><vh>themeinfo</vh></v>
</v>
<v t="sa.20110119013021.1330"><vh>vcs</vh>
<v t="sa.20110119013021.1331"><vh>git</vh></v>
</v>
<v t="sa.20110119013021.1292"><vh>apath</vh></v>
<v t="sa.20110119013021.1332"><vh>grep</vh>
<v t="sa.20110119013021.1293"><vh>grepped commands</vh></v>
</v>
<v t="sa.20110119013021.1366"><vh>package mgmt</vh>
<v t="sa.20110119013021.1312"><vh>debian</vh>
<v t="sa.20110119013021.1314"><vh>packagelistdl</vh></v>
<v t="sa.20110119013021.1313"><vh>nuke</vh></v>
<v t="sa.20110119013021.1295"><vh>apt-log</vh></v>
<v t="sa.20110119013021.1315"><vh>sp</vh></v>
</v>
<v t="sa.20110119013021.1367" a="E"><vh>arch linux</vh>
<v t="sa.20110119013021.1373"><vh>pacsearch</vh></v>
</v>
</v>
<v t="sa.20110119013021.1297"><vh>ask</vh></v>
<v t="sa.20110119013021.1306"><vh>fun</vh>
<v t="sa.20110119013021.1298"><vh>natdebt</vh></v>
<v t="sa.20110119013021.1299"><vh>oneliners</vh></v>
</v>
<v t="sa.20110119013021.1302"><vh>batchexec</vh></v>
<v t="sa.20110119013021.1319"><vh>compression</vh>
<v t="sa.20110119013021.1374"><vh>roll</vh></v>
<v t="sa.20110119013021.1344"><vh>mktbz</vh></v>
<v t="sa.20110119013021.1345"><vh>mktgz</vh></v>
<v t="sa.20110119013021.1343"><vh>mktar</vh></v>
<v t="sa.20110119013021.1300"><vh>atb</vh></v>
<v t="sa.20110119013021.1348"><vh>extract</vh></v>
<v t="sa.20110119013021.1347"><vh>tarball</vh></v>
<v t="sa.20110119013021.1382"><vh>zipf</vh></v>
<v t="sa.20110119013021.1384"><vh>pullout</vh></v>
</v>
<v t="sa.20110119013021.1307"><vh>network</vh>
<v t="sa.20110119013021.1352"><vh>portscan</vh></v>
</v>
<v t="sa.20110119013021.1308"><vh>colors</vh></v>
<v t="sa.20110119013021.1362"><vh>web lookup</vh>
<v t="sa.20110119013021.1309"><vh>dictionary</vh></v>
<v t="sa.20110119013021.1363"><vh>stock</vh></v>
</v>
<v t="sa.20110119013021.1310"><vh>processes</vh>
<v t="sa.20110119013021.1327"><vh>findPid</vh></v>
<v t="sa.20110119013021.1326"><vh>fork</vh></v>
<v t="sa.20110119013021.1333"><vh>kill</vh></v>
<v t="sa.20110119013021.1350"><vh>nh</vh></v>
<v t="sa.20110119013021.1351"><vh>open</vh></v>
<v t="sa.20110119013021.1354"><vh>program-timer</vh></v>
<v t="sa.20110119013021.1355"><vh>progress visuals</vh></v>
</v>
<v t="sa.20110119013021.1311"><vh>note</vh></v>
<v t="sa.20110119013021.1383"><vh>service</vh></v>
</v>
<v t="sa.20110119002240.1270"><vh>paths</vh></v>
<v t="sa.20110119002240.1282"><vh>colors</vh></v>
<v t="sa.20110119002240.1283"><vh>prompts</vh></v>
</v>
<v t="sa.20110121142539.1603"><vh>@@file /home/sa/tmp/bashrc_new.sh</vh>
<v t="sa.20110121142539.1604" a="E"><vh>setup</vh>
<v t="sa.20110121142539.1605"><vh>start</vh></v>
<v t="sa.20110121142539.1606"><vh>history control</vh></v>
<v t="sa.20110121142539.1607"><vh>shell options</vh></v>
<v t="sa.20110121142539.1608"><vh>less options</vh></v>
<v t="sa.20110121142539.1609"><vh>debian specific</vh></v>
<v t="sa.20110121142539.1610"><vh>color prompt</vh></v>
<v t="sa.20110121142539.1611"><vh>color ls</vh></v>
<v t="sa.20110121142539.1612"><vh>bash completion</vh></v>
<v t="sa.20110121142539.1613"><vh>external alias file</vh></v>
</v>
<v t="sa.20110121142539.1614"><vh>aliases</vh>
<v t="sa.20110121142539.1714"><vh>pacman</vh></v>
<v t="sa.20110121142539.1715"><vh>yaourt</vh></v>
<v t="sa.20110121142539.1716"><vh>apt-cache</vh></v>
<v t="sa.20110121142539.1717"><vh>apt-get</vh></v>
<v t="sa.20110121142539.1718"><vh>apt-history</vh></v>
<v t="sa.20110121142539.1719"><vh>aptitude</vh></v>
<v t="sa.20110121142539.1615"><vh>alert</vh></v>
</v>
<v t="sa.20110121142539.1616"><vh>exports</vh></v>
<v t="sa.20110121142539.1617" a="E"><vh>functions</vh>
<v t="sa.20110121142539.1618" a="E"><vh>permissions</vh>
<v t="sa.20110121142539.1619"><vh>sanitize</vh></v>
<v t="sa.20110121142539.1620"><vh>fix</vh></v>
<v t="sa.20110121142539.1621"><vh>own</vh></v>
<v t="sa.20110121142539.1622"><vh>xchown</vh></v>
<v t="sa.20110121142539.1623"><vh>resetp</vh></v>
</v>
<v t="sa.20110121142539.1624"><vh>files</vh>
<v t="sa.20110121142539.1625"><vh>fixlines</vh></v>
<v t="sa.20110121142539.1626"><vh>delete</vh></v>
<v t="sa.20110121142539.1627"><vh>cp_p</vh></v>
<v t="sa.20110121142539.1628"><vh>bak</vh></v>
<v t="sa.20110121142539.1629"><vh>lcfiles</vh></v>
<v t="sa.20110121142539.1630"><vh>lowercase</vh></v>
<v t="sa.20110121142539.1631"><vh>rmspaces</vh></v>
<v t="sa.20110121142539.1632"><vh>linesort</vh></v>
<v t="sa.20110121142539.1633"><vh>removeduplines</vh></v>
<v t="sa.20110121142539.1634"><vh>saveit</vh></v>
<v t="sa.20110121142539.1635"><vh>safeedit</vh></v>
<v t="sa.20110121142539.1636"><vh>showfile</vh></v>
<v t="sa.20110121142539.1637"><vh>tmv</vh></v>
<v t="sa.20110121142539.1638"><vh>underscore</vh></v>
<v t="sa.20110121142539.1639"><vh>vimcmd</vh></v>
<v t="sa.20110121142539.1640"><vh>zero</vh></v>
</v>
<v t="sa.20110121142539.1641"><vh>directories</vh>
<v t="sa.20110121142539.1642"><vh>ls stuff</vh></v>
<v t="sa.20110121142539.1643"><vh>dubigf</vh></v>
<v t="sa.20110121142539.1644"><vh>cds</vh></v>
<v t="sa.20110121142539.1645"><vh>ds</vh></v>
<v t="sa.20110121142539.1646"><vh>mcdr</vh></v>
<v t="sa.20110121142539.1647"><vh>blank_rename</vh></v>
<v t="sa.20110121142539.1648"><vh>newHeadline</vh></v>
</v>
<v t="sa.20110121142539.1649"><vh>find and replace</vh>
<v t="sa.20110121142539.1650"><vh>searchnreplace</vh></v>
<v t="sa.20110121142539.1651"><vh>find a file</vh></v>
<v t="sa.20110121142539.1652"><vh>find pattern in files</vh></v>
<v t="sa.20110121142539.1653"><vh>meaning of error code</vh></v>
</v>
<v t="sa.20110121142539.1654"><vh>text</vh>
<v t="sa.20110121142539.1655"><vh>getcolumn</vh></v>
<v t="sa.20110121142539.1656"><vh>box</vh></v>
<v t="sa.20110121142539.1657"><vh>most_frequent</vh></v>
<v t="sa.20110121142539.1658"><vh>println</vh></v>
</v>
<v t="sa.20110121142539.1659"><vh>docs</vh>
<v t="sa.20110121142539.1660"><vh>doc</vh></v>
<v t="sa.20110121142539.1661"><vh>archwikisearch</vh></v>
<v t="sa.20110121142539.1662"><vh>man2text</vh></v>
<v t="sa.20110121142539.1663"><vh>rtfm</vh></v>
</v>
<v t="sa.20110121142539.1664"><vh>info</vh>
<v t="sa.20110121142539.1665"><vh>ii</vh></v>
<v t="sa.20110121142539.1666"><vh>themeinfo</vh></v>
</v>
<v t="sa.20110121142539.1667"><vh>vcs</vh>
<v t="sa.20110121142539.1668"><vh>git</vh></v>
</v>
<v t="sa.20110121142539.1669"><vh>apath</vh></v>
<v t="sa.20110121142539.1670"><vh>grep</vh>
<v t="sa.20110121142539.1671"><vh>grepped commands</vh></v>
</v>
<v t="sa.20110121142539.1672"><vh>package mgmt</vh>
<v t="sa.20110121142539.1673"><vh>debian</vh>
<v t="sa.20110121142539.1674"><vh>packagelistdl</vh></v>
<v t="sa.20110121142539.1675"><vh>nuke</vh></v>
<v t="sa.20110121142539.1676"><vh>apt-log</vh></v>
<v t="sa.20110121142539.1677"><vh>sp</vh></v>
</v>
<v t="sa.20110121142539.1678" a="E"><vh>arch linux</vh>
<v t="sa.20110121142539.1679"><vh>pacsearch</vh></v>
</v>
</v>
<v t="sa.20110121142539.1680"><vh>ask</vh></v>
<v t="sa.20110121142539.1681"><vh>fun</vh>
<v t="sa.20110121142539.1682"><vh>natdebt</vh></v>
<v t="sa.20110121142539.1683"><vh>oneliners</vh></v>
</v>
<v t="sa.20110121142539.1684"><vh>batchexec</vh></v>
<v t="sa.20110121142539.1685"><vh>compression</vh>
<v t="sa.20110121142539.1686"><vh>roll</vh></v>
<v t="sa.20110121142539.1687"><vh>mktbz</vh></v>
<v t="sa.20110121142539.1688"><vh>mktgz</vh></v>
<v t="sa.20110121142539.1689"><vh>mktar</vh></v>
<v t="sa.20110121142539.1690"><vh>atb</vh></v>
<v t="sa.20110121142539.1691"><vh>extract</vh></v>
<v t="sa.20110121142539.1692"><vh>tarball</vh></v>
<v t="sa.20110121142539.1693"><vh>zipf</vh></v>
<v t="sa.20110121142539.1694"><vh>pullout</vh></v>
</v>
<v t="sa.20110121142539.1695"><vh>network</vh>
<v t="sa.20110121142539.1696"><vh>portscan</vh></v>
</v>
<v t="sa.20110121142539.1697"><vh>colors</vh></v>
<v t="sa.20110121142539.1698"><vh>web lookup</vh>
<v t="sa.20110121142539.1699"><vh>dictionary</vh></v>
<v t="sa.20110121142539.1700"><vh>stock</vh></v>
</v>
<v t="sa.20110121142539.1701"><vh>processes</vh>
<v t="sa.20110121142539.1702"><vh>findPid</vh></v>
<v t="sa.20110121142539.1703"><vh>fork</vh></v>
<v t="sa.20110121142539.1704"><vh>kill</vh></v>
<v t="sa.20110121142539.1705"><vh>nh</vh></v>
<v t="sa.20110121142539.1706"><vh>open</vh></v>
<v t="sa.20110121142539.1707"><vh>program-timer</vh></v>
<v t="sa.20110121142539.1708"><vh>progress visuals</vh></v>
</v>
<v t="sa.20110121142539.1709"><vh>note</vh></v>
<v t="sa.20110121142539.1710"><vh>service</vh></v>
</v>
<v t="sa.20110121142539.1711"><vh>paths</vh></v>
<v t="sa.20110121142539.1712"><vh>colors</vh></v>
</v>
</v>
<v t="sa.20110128155259.1842" a="EO"><vh>@nosent /home/sa/tmp/bashrc_new.sh</vh>
<v t="sa.20110128155259.1843"><vh>setup</vh>
<v t="sa.20110128155259.1844"><vh>start</vh></v>
<v t="sa.20110128155259.1845"><vh>history control</vh></v>
<v t="sa.20110128155259.1846"><vh>shell options</vh></v>
<v t="sa.20110128155259.1847"><vh>less options</vh></v>
<v t="sa.20110128155259.1848"><vh>debian specific</vh></v>
<v t="sa.20110128155259.1849"><vh>color prompt</vh></v>
<v t="sa.20110128155259.1850"><vh>color ls</vh></v>
<v t="sa.20110128155259.1851"><vh>bash completion</vh></v>
<v t="sa.20110128155259.1852"><vh>external alias file</vh></v>
</v>
<v t="sa.20110128155259.1853"><vh>aliases</vh>
<v t="sa.20110128155259.1856"><vh>apt-cache</vh></v>
<v t="sa.20110128155259.1857"><vh>apt-get</vh></v>
<v t="sa.20110128155259.1968"><vh>cleanup</vh></v>
<v t="sa.20110128155259.1965"><vh>compression</vh></v>
<v t="sa.20110128155259.1971"><vh>cpu usage</vh></v>
<v t="sa.20110128155259.1973"><vh>mem usage</vh></v>
<v t="sa.20110128155259.1969"><vh>disk usage</vh></v>
<v t="sa.20110128155259.1961"><vh>editors</vh></v>
<v t="sa.20110128155259.1962"><vh>files / directories</vh></v>
<v t="sa.20110128155259.1972"><vh>find</vh></v>
<v t="sa.20110128155259.1970"><vh>hardware</vh></v>
<v t="sa.20110128155259.1960"><vh>ignored</vh>
<v t="sa.20110128155259.1854"><vh>pacman</vh></v>
<v t="sa.20110128155259.1855"><vh>yaourt</vh></v>
<v t="sa.20110128155259.1858"><vh>apt-history</vh></v>
<v t="sa.20110128155259.1859"><vh>aptitude</vh></v>
<v t="sa.20110128155259.1860"><vh>alert</vh></v>
<v t="sa.20110128155259.1974"><vh>date &amp; time</vh></v>
</v>
<v t="sa.20110128155259.1966"><vh>logs and forensics</vh></v>
<v t="sa.20110128155259.1964"><vh>network</vh></v>
<v t="sa.20110128155259.1963"><vh>processes</vh></v>
</v>
<v t="sa.20110128155259.1861"><vh>exports</vh></v>
<v t="sa.20110128155259.1862" a="E"><vh>functions</vh>
<v t="sa.20110128155259.1863"><vh>permissions</vh>
<v t="sa.20110128155259.1864"><vh>sanitize</vh></v>
<v t="sa.20110128155259.1865"><vh>fix</vh></v>
<v t="sa.20110128155259.1866"><vh>own</vh></v>
<v t="sa.20110128155259.1867"><vh>xchown</vh></v>
<v t="sa.20110128155259.1868"><vh>resetp</vh></v>
</v>
<v t="sa.20110128155259.1869"><vh>files</vh>
<v t="sa.20110128155259.1870"><vh>fixlines</vh></v>
<v t="sa.20110128155259.1871"><vh>delete</vh></v>
<v t="sa.20110128155259.1872"><vh>cp_p</vh></v>
<v t="sa.20110128155259.1873"><vh>bak</vh></v>
<v t="sa.20110128155259.1874"><vh>lcfiles</vh></v>
<v t="sa.20110128155259.1875"><vh>lowercase</vh></v>
<v t="sa.20110128155259.1876"><vh>rmspaces</vh></v>
<v t="sa.20110128155259.1877"><vh>linesort</vh></v>
<v t="sa.20110128155259.1878"><vh>removeduplines</vh></v>
<v t="sa.20110128155259.1879"><vh>saveit</vh></v>
<v t="sa.20110128155259.1880"><vh>safeedit</vh></v>
<v t="sa.20110128155259.1881"><vh>showfile</vh></v>
<v t="sa.20110128155259.1882"><vh>tmv</vh></v>
<v t="sa.20110128155259.1883"><vh>underscore</vh></v>
<v t="sa.20110128155259.1884"><vh>vimcmd</vh></v>
<v t="sa.20110128155259.1885"><vh>zero</vh></v>
</v>
<v t="sa.20110128155259.1886"><vh>directories</vh>
<v t="sa.20110128155259.1887"><vh>ls stuff</vh></v>
<v t="sa.20110128155259.1888"><vh>dubigf</vh></v>
<v t="sa.20110128155259.1889"><vh>cds</vh></v>
<v t="sa.20110128155259.1890"><vh>ds</vh></v>
<v t="sa.20110128155259.1891"><vh>mcdr</vh></v>
<v t="sa.20110128155259.1892"><vh>blank_rename</vh></v>
<v t="sa.20110128155259.1893"><vh>newHeadline</vh></v>
</v>
<v t="sa.20110128155259.1894"><vh>find and replace</vh>
<v t="sa.20110128155259.1895"><vh>searchnreplace</vh></v>
<v t="sa.20110128155259.1896"><vh>find a file</vh></v>
<v t="sa.20110128155259.1897"><vh>find pattern in files</vh></v>
<v t="sa.20110128155259.1898"><vh>meaning of error code</vh></v>
</v>
<v t="sa.20110128155259.1899"><vh>text</vh>
<v t="sa.20110128155259.1900"><vh>getcolumn</vh></v>
<v t="sa.20110128155259.1901"><vh>box</vh></v>
<v t="sa.20110128155259.1902"><vh>most_frequent</vh></v>
<v t="sa.20110128155259.1903"><vh>println</vh></v>
</v>
<v t="sa.20110128155259.1904"><vh>docs</vh>
<v t="sa.20110128155259.1905"><vh>doc</vh></v>
<v t="sa.20110128155259.1906"><vh>archwikisearch</vh></v>
<v t="sa.20110128155259.1907"><vh>man2text</vh></v>
<v t="sa.20110128155259.1908"><vh>rtfm</vh></v>
</v>
<v t="sa.20110128155259.1909"><vh>info</vh>
<v t="sa.20110128155259.1910"><vh>ii</vh></v>
<v t="sa.20110128155259.1911"><vh>themeinfo</vh></v>
</v>
<v t="sa.20110128155259.1912"><vh>vcs</vh>
<v t="sa.20110128155259.1913"><vh>git</vh></v>
</v>
<v t="sa.20110128155259.1914"><vh>apath</vh></v>
<v t="sa.20110128155259.1915"><vh>grep</vh>
<v t="sa.20110128155259.1916"><vh>grepped commands</vh></v>
</v>
<v t="sa.20110128155259.1917"><vh>package mgmt</vh>
<v t="sa.20110128155259.1918"><vh>debian</vh>
<v t="sa.20110128155259.1919"><vh>packagelistdl</vh></v>
<v t="sa.20110128155259.1920"><vh>nuke</vh></v>
<v t="sa.20110128155259.1921"><vh>apt-log</vh></v>
<v t="sa.20110128155259.1922"><vh>sp</vh></v>
</v>
<v t="sa.20110128155259.1923" a="E"><vh>arch linux</vh>
<v t="sa.20110128155259.1924"><vh>pacsearch</vh></v>
</v>
</v>
<v t="sa.20110128155259.1925"><vh>ask</vh></v>
<v t="sa.20110128155259.1926"><vh>fun</vh>
<v t="sa.20110128155259.1927"><vh>natdebt</vh></v>
<v t="sa.20110128155259.1928"><vh>oneliners</vh></v>
</v>
<v t="sa.20110128155259.1929"><vh>batchexec</vh></v>
<v t="sa.20110128155259.1930"><vh>compression</vh>
<v t="sa.20110128155259.1931"><vh>roll</vh></v>
<v t="sa.20110128155259.1932"><vh>mktbz</vh></v>
<v t="sa.20110128155259.1933"><vh>mktgz</vh></v>
<v t="sa.20110128155259.1934"><vh>mktar</vh></v>
<v t="sa.20110128155259.1935"><vh>atb</vh></v>
<v t="sa.20110128155259.1936"><vh>extract</vh></v>
<v t="sa.20110128155259.1937"><vh>tarball</vh></v>
<v t="sa.20110128155259.1938"><vh>zipf</vh></v>
<v t="sa.20110128155259.1939"><vh>pullout</vh></v>
</v>
<v t="sa.20110128155259.1940"><vh>network</vh>
<v t="sa.20110128155259.1941"><vh>portscan</vh></v>
</v>
<v t="sa.20110128155259.1942"><vh>colors</vh></v>
<v t="sa.20110128155259.1943"><vh>web lookup</vh>
<v t="sa.20110128155259.1944"><vh>dictionary</vh></v>
<v t="sa.20110128155259.1945"><vh>stock</vh></v>
</v>
<v t="sa.20110128155259.1946"><vh>processes</vh>
<v t="sa.20110128155259.1947"><vh>findPid</vh></v>
<v t="sa.20110128155259.1948"><vh>fork</vh></v>
<v t="sa.20110128155259.1949"><vh>kill</vh></v>
<v t="sa.20110128155259.1950"><vh>nh</vh></v>
<v t="sa.20110128155259.1951"><vh>open</vh></v>
<v t="sa.20110128155259.1952"><vh>program-timer</vh></v>
<v t="sa.20110128155259.1953"><vh>progress visuals</vh></v>
</v>
<v t="sa.20110128155259.1954"><vh>note</vh></v>
<v t="sa.20110128155259.1955"><vh>service</vh></v>
</v>
<v t="sa.20110128155259.1956"><vh>paths</vh></v>
<v t="sa.20110128155259.1957"><vh>colors</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="sa.20110119002240.1264"></t>
<t tx="sa.20110119002240.1266">@language shell

@others
</t>
<t tx="sa.20110119002240.1267"># Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

</t>
<t tx="sa.20110119002240.1268">





</t>
<t tx="sa.20110119002240.1269"></t>
<t tx="sa.20110119002240.1270"></t>
<t tx="sa.20110119002240.1271"># don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

</t>
<t tx="sa.20110119002240.1272"># If not running interactively, don't do anything
[ -z "$PS1" ] &amp;&amp; return
</t>
<t tx="sa.20110119002240.1273"># set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
# force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac
</t>
<t tx="sa.20110119002240.1274"># enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors &amp;&amp; eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    # alias dir='dir --color=auto'
    # alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
</t>
<t tx="sa.20110119002240.1275"># enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then
    . /etc/bash_completion
fi
</t>
<t tx="sa.20110119002240.1276">######################################################################################################################################################
###### ALIASES ###### ALIASES ###### ALIASES ###### ALIASES ###### ALIASES ###### ALIASES ###### ALIASES ###### ALIASES ###### ALIASES ###### ALIASES ######
######################################################################################################################################################








##################################################
# App-specific					 #
##################################################

alias audio='ncmpcpp'								# music player
alias daemon-status='for a in deluged deluge rtorrent; do  (ps -u $USER|grep $a$ &gt; /dev/null &amp;&amp; echo $a running.) || echo $a not running.; done'	# list the status of the daemons :p
alias daggerfall='dosbox -conf ~/.dosbox.conf.daggerfall'			# launch dosbox with a preset configuration for Daggerfall
# alias deluge-link='echo http://'`hostname`':'$USER_WPRT'/'
alias ftp='ncftp Personal'
alias instaluj='sudo pacman-color -S'
alias links2g='links2 -g'
alias nano='nano -W -m'								# disable annoying line wrapping
alias pacclean='sudo yaourt -Scc' 						# clean package cache
alias pacin='sudo yaourt -S'  							# install a specific package
alias pacman='yaourt' 								# switches from Pacman to Yaourt so we can troll the AUR
alias pacout='sudo yaourt -Rs'							# Remove a specific package
alias pacsync='sudo yaourt -Sy'   						# Sync
alias pacup='sudo yaourt -Syu'							# Sync &amp; Update
alias rc='ssh ${MEDIAPCHOSTNAME} env DISPLAY=:0.0 rhythmbox-client --no-start'	# remote control for Rhythmbox on an Ubuntu Media PC
alias scrot='scrot -c -d 7'
alias spotify_next='$HOME/spotifycmd/spotify_cmd.exe next; $HOME/spotifycmd/spotify_cmd.exe status'
alias spotify_playpause='$HOME/spotifycmd/spotify_cmd.exe playpause'
alias spotify_prev='$HOME/spotifycmd/spotify_cmd.exe prev; $HOME/spotifycmd/spotify_cmd.exe status'
alias spotify_status='$HOME/spotifycmd/spotify_cmd.exe status'
alias spotify_stop='$HOME/spotifycmd/spotify_cmd.exe stop'
alias ss='gnome-screensaver-command -a'
alias start-deluged='start-stop-daemon -S --pidfile $HOME/.deluged.pid -u $USER -d $HOME -a /usr/bin/deluged -- --pidfile $HOME/.deluged.pid'
alias start-deluge-webui='start-stop-daemon -S --pidfile $HOME/.deluge-web.pid --background --make-pidfile -u $USER -d $HOME -a /usr/bin/deluge --  -u web'
alias start-rtorrent='(screen -ls|grep rtorrent &gt; /dev/null || (screen -dmS rtorrent rtorrent &amp;&amp; false)) &amp;&amp; echo rtorrent is already running.'
alias start-vnc='vncserver :$USER_VPRT'
alias stop-deluged='start-stop-daemon -K --pidfile $HOME/.deluged.pid -u $USER -d $HOME -a /usr/bin/deluged -- --pidfile $HOME/.deluged.pid || killall -v -u $USER deluged'
alias stop-deluge-webui='start-stop-daemon -K --pidfile $HOME/.deluge-web.pid --make-pidfile -u $USER -d $HOME -a /usr/bin/deluge --  -u web;rm $HOME/.deluge-web.pid;'
alias stop-rtorrent='killall -u $USER rtorrent -q || echo rtorrent is not running'
alias stop-vnc='vncserver -kill :$USER_VPRT'
alias tetris='bastet' 								# bastardly tetris... awesome but deadly
alias tvtime-video0='tvtime-configure -d /dev/video0'
alias tvtime-video1='tvtime-configure -d /dev/video1'
alias tvtime-video2='tvtime-configure -d /dev/video2'
alias tvtime-video3='tvtime-configure -d /dev/video3'
alias tvtime-video4='tvtime-configure -d /dev/video4'
alias tvtime-video5='tvtime-configure -d /dev/video5'
alias wgeturlfromfile='wget -r -l1 -H -t1 -nd -N -np -A.jpg -erobots=off -i'	# -i file.txt
alias wget='wget -c'
alias yr='yaourt -Rs -C'
alias yss='yaourt -Ss -C'
alias ys='yaourt -S -C'
alias ysyu='yaourt -Syu -C'
alias ysy='yaourt -Sy -C'



##################################################
# Apt-cache stuff				 #
##################################################

alias aptadd='sudo apt-cache add'
alias aptdepends='sudo apt-cache depends'
alias aptdotty='sudo apt-cache dotty'
alias aptdumpavail='sudo apt-cache dumpavail'
alias aptdump='sudo apt-cache dump'
alias aptgencaches='sudo apt-cache gencaches'
alias aptpkgnames='sudo apt-cache pkgnames'
alias aptpolicy='sudo apt-cache policy'
alias aptrdepends='sudo apt-cache rdepends'
alias aptsearch='sudo apt-cache search'
alias aptshowpkg='sudo apt-cache showpkg'
alias aptshowsrc='sudo apt-cache showsrc'
alias aptshow='sudo apt-cache show'
alias aptstats='sudo apt-cache stats'
alias aptunmet='sudo apt-cache unmet'
alias aptxvcg='sudo apt-cache xvcg'



##################################################
# Apt-get stuff					 #
##################################################

alias autoremove='sudo apt-get autoremove'
alias check='sudo apt-get check'
alias dist-upgrade='sudo apt-get dist-upgrade'
alias dselect-upgrade='sudo apt-get dselect-upgrade'
alias source='sudo apt-get source'



##################################################
# Apt-history Stuff				 #
##################################################

alias historya='apt-history'
alias historyi='apt-history install'
alias historyre='apt-history remove'
alias historyro='apt-history rollback'
alias historyu='apt-history upgrade'



##################################################
# Aptitude stuff				 #
##################################################

alias autoclean='sudo aptitude autoclean'
alias build-dep='sudo aptitude build-dep'
alias changelog='sudo aptitude changelog'
alias clean='sudo aptitude clean'
alias download='sudo aptitude download'
alias forbid-version='sudo aptitude forbid-version'
alias forget-new='sudo aptitude forget-new'
alias full-upgrade='sudo aptitude full-upgrade'
alias hold='sudo aptitude hold'
alias install='sudo aptitude install'
alias linux-image='sudo aptitude search linux-image'		# linux-image kernel update check
alias markauto='sudo aptitude markauto'
alias purge='sudo aptitude purge'
alias reinstall='sudo aptitude reinstall'
alias remove='sudo aptitude remove'
alias search='sudo aptitude search'
alias show='sudo aptitude show'
alias unhold='sudo aptitude unhold'
alias unmarkauto='sudo aptitude unmarkauto'
alias update='sudo aptitude update'
alias upgrade='sudo aptitude safe-upgrade'
alias why-not='sudo aptitude why-not'
alias why='sudo aptitude why'



##################################################
# Chown substitution				 #
##################################################

alias chown-backgrounds='sudo chown -R $USER:$USER ~/Pictures/Backgrounds'
alias chown-backups='sudo chown -R $USER:$USER ~/Backups'
alias chown-books='sudo chown -R $USER:$USER ~/eBooks'
alias chown-desktop='sudo chown -R $USER:$USER ~/Desktop'
alias chown-documents='sudo chown -R $USER:$USER ~/Documents'
alias chown-downloads='sudo chown -R $USER:$USER ~/Downloads'
alias chown-drive-c='sudo chown -R $USER:$USER ~/.wine/drive_c'
alias chown-home='sudo chown -R $USER:$USER ~/'
alias chown-images='sudo chown -R $USER:$USER ~/Images'
alias chown-localhost='sudo chown -R $USER:$USER ~/var/www'
alias chown-music='sudo chown -R $USER:$USER ~/Music'
alias chown-nautilus-scripts='sudo chown -R $USER:$USER ~/.gnome2/nautilus-scripts'
alias chown-packages='sudo chown -R $USER:$USER ~/Packages'
alias chown-pictures='sudo chown -R $USER:$USER ~/Pictures'
alias chown-ppc='sudo chown -R $USER:$USER ~/PPC'
alias chown-public='sudo chown -R $USER:$USER ~/Public'
alias chown='sudo chown -R $USER:$USER'
alias chown-temp='sudo chown -R $USER:$USER ~/Temp'
alias chown-torrents='sudo chown -R $USER:$USER ~/Torrents'
alias chown-ubuntu-texts='sudo chown -R $USER:$USER ~/Documents/"Ubuntu Texts"'
alias chown-videos='sudo chown -R $USER:$USER ~/Videos'



##################################################
# Command substitution				 #
##################################################

alias abs='sudo abs'
alias a='ssh-agent;ssh-add'
alias bt='aria2c --max-upload-limit=10K --seed-time=60 --listen-port=8900-8909'		# shortcut for downloading a torrent file on the command line
alias c='clear'
alias ci='vim'
alias ck='killall conky &amp;&amp; conky -d'
alias cls='clear'
alias contents='/bin/tar -tzf'								# can View the contents of a Tar file
alias cp='cp -iv'
alias d_='ssh 192.168.1.4'
alias dr='dirs -v'
alias ds_='dig +noauthority +noadditional +noqr +nostats +noidentify +nocmd +noquestion +nocomments'		# short and sweet output from dig(1)
alias e='espeak'
alias egrep='egrep –color=auto'
alias enote='vi ~/todo;~/motd.pl'
alias fgrep='fgrep –color=auto'
alias ge='geany'
alias go='startx'
alias grep='grep --color=auto'								# highlight matched pattern
alias g_='mocp -G'
alias halt='sudo /sbin/halt'
alias h='history | grep $1'
alias hib='sudo pm-hibernate'
alias ie='wine iexplore.exe'								# browse the Internet using Internet Explorer
alias im='centerim'  									# terminal based instant messaging client
alias img='imgurbash' 									# uploads image to imgur
alias irc='irssi' 									# terminal based IRC
# alias irssi='screen -wipe; screen -A -U -x -R -S irssi irssi'				# for creating screen session containing IRSSI, named irssi, while checking if existing session is created
alias j='jobs -l'
alias kfx='killall firefox-bin'
alias kgp='killall gnome-panel'
alias k='kill'
alias kk='sendmail -d0.4 -bv root |less'
alias kn='killall nautilus'
alias last='last -a'
alias lock='clear &amp;&amp; vlock -c'								# clear and lock console (non-X) terminal
alias logs='tail -f /var/log/messages /var/log/*log'
alias m='~/bin/motd.pl'
alias mc='metacafe-dl -t'
alias me='vi ~/.muttrc'
alias mkdir='mkdir -p -v'
alias mktd='tdir=`mktemp -d` &amp;&amp; cd $tdir'						# make a temp dir, then immediately cd into it
alias m=mutt
alias more='less'
alias mp='screen -d -m mousepad'
alias mv='mv -iv'
alias na='nano'
alias nmr='sudo /etc/rc.d/networkmanager restart'
alias n='nautilus &amp; exit'
alias np='mpc --format "np: [[%artist%] - [%title%] - 					#[[%album%] ##[%track%]#]]|[%file%]" | head -n 1'
alias nq='nautilus -q'
alias oe='wine msimn.exe'								# read email with Outlook Express
alias packup='/bin/tar -czvf'								# compress a file in tar format
alias parts='cat /proc/partitions'
# alias paste='ix'  									# pastes to ix.ox pastebin service
alias paste='pastebinit'
alias path='echo -e ${PATH//:/\\n}'
alias pe='vi ~/.procmailrc'
alias pg='ps aux | grep'*								# requires an argument
alias pi='`cat ~/.pi | grep ' ; alias addpi='echo "cd `pwd`" &gt;&gt; ~/.pi'			# fast access to any of your favorite directory.
alias ping='ping -c 10'
alias pjet='enscript -h -G -fCourier9 -d $LPDEST'           				# pretty-print using enscript
alias print='/usr/bin/lp -o nobanner -d $LPDEST'            				# assumes LPDEST is defined (default printer)
alias ps='ps auxf'
alias p_='for ((n=0;n&lt;1;n++)); do dd if=/dev/urandom count=1 2&gt; /dev/null | uuencode -m -| sed -ne 2p | cut -c-8; done' # creating password
alias :q='exit'
alias q='exit'
alias rcci='svn ci ~/rc/'
alias rcup='~/bin/rc_sync.sh'
alias rd='cd "`pwd -P`"' 								# if in directory containing symlink in path, change to "real" path
alias reboot='sudo /sbin/reboot'
# alias reboot='sudo shutdown -r now'   							# easy shutdown management
alias refresh='nautilus -q &amp;&amp; killall gnome-panel'
alias rgrep='find . \( ! -name .svn -o -prune \) -type f -print0 | xargs -0 grep'	# rgrep: recursive grep without .svn
alias rh='rehash'
alias rmdir='rmdir -v'
alias rm='rm -iv'
alias root='sudo bash -l'								# generic shortcut for switching to root user depending on system
# alias root='sudo -i'									# generic shortcut for switching to root user depending on system
# alias root='su -'									# generic shortcut for switching to root user depending on system
alias scx='screen -x'
alias sdi='sudo dpkg -i'
alias se='vi ~/.screenrc'
alias sg='sudo geany'
alias shutdown='sudo shutdown -h now'							# proper restart
alias shutdownde='for ((;;)) do pgrep wget ||shutdown -h now; sleep 5; done'		# if download end, shutdown
alias sn='sudo nano'
alias split='split -d'
alias sql='mysql -p -u root'
alias sr='screen -d -RR'
# alias s='sudo'
# alias s_='screen -X screen'; s top; s vi; s man ls;					# start a new command in a new screen window
alias sshdo='ssh -q -t root@localhost -- cd $PWD \&amp;\&amp; sudo'				# an alternative to sudo
alias sus='sudo pm-suspend'
alias svi='sudo vim'
alias tc='tar cfvz'
alias te='tail -50f /var/log/qmail/qmail-send/current | elog'
alias tf='tail -50f /var/log/iptables.log'
alias tm='tail -50f /var/log/messages.log'
alias ts='tail -50f /var/log/auth.log'
alias tweet='bti'
alias tx='tar xfvz'
alias u='mocp -P &amp;&amp; sudo pm-suspend ; sleep 1s &amp;&amp; mocp -U &amp;&amp; setxkbmap -option terminate:ctrl_alt_bksp &amp;&amp; xmodmap .config/caps-esc &amp;&amp; ~/.fehbg'	# something is messed up somewhere, dirty fix
alias unpack='/bin/tar -xzvpf'								# uncompress a a Tar file
alias updatefont='fc-cache -v -f'
alias url='tinyurl'
alias urlping="ping -q -c 1 www.google.com|awk -F/ 'END{print $5}'"			# do one ping to URL: good in MRTG gauge graph to monitor connectivity
alias v='zless -N'									# -N means display line numbers (turn off line numbers with -n)
alias ve='vi ~/.vimrc'
alias vi='vim'
alias web='w3m'   									# terminal based web browser
alias which='type -all'
alias win='/media/win'
alias wtf='watch -n 1 w -hs'
alias xee='cat /var/log/Xorg.0.log |grep EE'
alias xevs="xev | grep 'keycode\|button'"						# only show button events for xev
alias xp='xprop | grep "WM_WINDOW_ROLE\|WM_CLASS" &amp;&amp; echo "WM_CLASS(STRING) = \"NAME\", \"CLASS\""'
alias x='startx'
alias xww='cat /var/log/Xorg.0.log |grep WW'
alias yt='youtube-dl -t '
alias z='zenity --info --text="You will not believe it, but your command has finished now! :-)" --display :0.0'	# get a desktop notification from the terminal
alias zen='fortune /usr/share/fortune/zen'



##################################################
# Command substitution (for typos)		 #
##################################################

alias findgrep='grepfind'
alias mann='man'
alias moer='more'
alias moew='more'
alias updtae='update'
alias vf='cd'
alias xs='cd'
alias yauort='yaourt'
alias yoaurt='yaourt'
alias youart='yaourt'
alias yuaort='yaourt'
alias yuoart='yaourt'



##################################################
# Computer cleanup				 #
##################################################

alias cleanup='sudo apt-get -y autoclean &amp;&amp; sudo apt-get -y autoremove &amp;&amp; sudo apt-get -y clean &amp;&amp; sudo apt-get -y remove &amp;&amp; sudo deborphan | xargs sudo apt-get -y remove --purge'
alias configpurge="sudo aptitude purge `dpkg --get-selections | grep deinstall | awk '{print $1}'`"	# purge configuration files of removed packages on debian systems
alias kernelcleanup="dpkg -l 'linux-*' | sed '/^ii/!d;/'"$(uname -r | sed "s/\(.*\)-\([^0-9]\+\)/\1/")"'/d;s/^[^ ]* [^ ]* \([^ ]*\).*/\1/;/[0-9]/!d' | xargs sudo apt-get -y purge"										# remove all unused Linux Kernel headers, images &amp; modules
alias orphaned='sudo deborphan | xargs sudo apt-get -y remove --purge'
alias tp='trash-put'											# sends files to trash instead of perm deleting w/rm
alias trash='rm -fr ~/.Trash'



##################################################
# DD substitution				 #
##################################################

alias backup-sda='sudo dd if=/dev/hda of=/dev/sda bs=64k conv=notrunc,noerror'		# to backup the existing drive to a USB drive
alias cdcopy='sudo dd if=/dev/cdrom of=cd.iso'						# for cdrom
alias cdiso='sudo dd if=/dev/hda of=cd.iso bs=2048 conv=sync,notrunc'			# to make an iso image of a CD
alias dd-sda-full='sudo dd if=/dev/urandom of=/dev/sda bs=8b conv=notrunc,noerror'	# to wipe hard drive with random data option (1)
alias dd-sda-r='sudo dd if=/dev/urandom of=/dev/sda bs=102400'				# to wipe hard drive with random data option (2)
alias dd-sda='sudo dd if=/dev/zero of=/dev/sda conv=notrunc'				# to wipe hard drive with zero
alias dd-sdb-full='sudo dd if=/dev/urandom of=/dev/sdb bs=8b conv=notrunc,noerror'	# to wipe hard drive with random data option (1)
alias dd-sdb-r='sudo dd if=/dev/urandom of=/dev/sdb bs=102400'				# to wipe hard drive with random data option (2)
alias dd-sdb='sudo dd if=/dev/zero of=/dev/sdb conv=notrunc'				# to wipe hard drive with zero
alias dd-sdc-full='sudo dd if=/dev/urandom of=/dev/sdc bs=8b conv=notrunc,noerror'	# to wipe hard drive with random data option (1)
alias dd-sdc-r='sudo dd if=/dev/urandom of=/dev/sdc bs=102400'				# to wipe hard drive with random data option (2)
alias dd-sdc='sudo dd if=/dev/zero of=/dev/sdc conv=notrunc'				# to wipe hard drive with zero
alias dd-sdd-full='sudo dd if=/dev/urandom of=/dev/sdd bs=8b conv=notrunc,noerror'	# to wipe hard drive with random data option (1)
alias dd-sdd-r='sudo dd if=/dev/urandom of=/dev/sdd bs=102400'				# to wipe hard drive with random data option (2)
alias dd-sdd='sudo dd if=/dev/zero of=/dev/sdd conv=notrunc'				# to wipe hard drive with zero
alias dd-sde-full='sudo dd if=/dev/urandom of=/dev/sde bs=8b conv=notrunc,noerror'	# to wipe hard drive with random data option (1)
alias dd-sde-r='sudo dd if=/dev/urandom of=/dev/sde bs=102400'				# to wipe hard drive with random data option (2)
alias dd-sde='sudo dd if=/dev/zero of=/dev/sde conv=notrunc'				# to wipe hard drive with zero
alias dd-sdf-full='sudo dd if=/dev/urandom of=/dev/sdf bs=8b conv=notrunc,noerror'	# to wipe hard drive with random data option (1)
alias dd-sdf-r='sudo dd if=/dev/urandom of=/dev/sdf bs=102400'				# to wipe hard drive with random data option (2)
alias dd-sdf='sudo dd if=/dev/zero of=/dev/sdf conv=notrunc'				# to wipe hard drive with zero
alias dd-sdg-full='sudo dd if=/dev/urandom of=/dev/sdg bs=8b conv=notrunc,noerror'	# to wipe hard drive with random data option (1)
alias dd-sdg-r='sudo dd if=/dev/urandom of=/dev/sdg bs=102400'				# to wipe hard drive with random data option (2)
alias dd-sdg='sudo dd if=/dev/zero of=/dev/sdg conv=notrunc'				# to wipe hard drive with zero
alias diskcopy='sudo dd if=/dev/dvd of=/dev/cdrecorder'
alias dvdcopy='sudo dd if=/dev/dvd of=dvd.iso'						# for dvd
alias floppycopy='sudo dd if=/dev/fd0 of=floppy.image'					# to duplicate a floppy disk to hard drive image file
alias partitioncopy='sudo dd if=/dev/sda1 of=/dev/sda2 bs=4096 conv=notrunc,noerror'	# to duplicate one hard disk partition to another hard disk partition
alias restore-sda='sudo dd if=/dev/sda of=/dev/hda bs=64k conv=notrunc,noerror'		# to restore from the USB drive to the existing drive
alias scsicopy='sudo dd if=/dev/scd0 of=cd.iso'						# if cdrom is scsi



##################################################
# Defragmenting and Fragmentation-Checking	 #
# Tools						 #
##################################################

alias defrag-home='defrag ~'			# uses 'defrag' function
alias defrag-root='defrag /root'		# uses 'defrag' function
alias defrag-system='defrag /'			# uses 'defrag' function
alias defrag2-home='defrag2 ~'			# uses 'defrag2' function
alias defrag2-root='defrag2 /root'		# uses 'defrag2' function
alias defrag2-system='defrag2 /'		# uses 'defrag2' function
alias fragcheck-home='fragcheck ~'		# uses 'fragcheck' function
alias fragcheck-root='fragcheck /root'		# uses 'fragcheck' function
alias fragcheck-system='fragcheck /'		# uses 'fragcheck' function
alias fragcheck2-home='fragcheck2 ~'		# uses 'fragcheck2' function
alias fragcheck2-root='fragcheck2 /root'	# uses 'fragcheck2' function
alias fragcheck2-system='fragcheck2 /'		# uses 'fragcheck2' function



##################################################
# Directory shortcuts				 #
##################################################

alias back='cd $OLDPWD'
alias backgrounds='cd ~/Pictures/Backgrounds'
alias backups='cd ~/Backups'
alias books='cd ~/eBooks'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'
alias documents='cd ~/Documents'
alias downloads='cd ~/Downloads'
alias drive-c='cd ~/.wine/drive_c'
alias dropbox='cd ~/Dropbox'
alias home='cd ~/'
alias images='cd ~/Images'
alias localhost='cd /var/www'
alias movies='cd ~/Videos'
alias music='cd ~/Music'
alias nautilus-scripts='cd ~/.gnome2/nautilus-scripts'
alias packages='cd ~/Packages'
alias packets='cd ~/.packets'
alias pictures='cd ~/Pictures'
alias ppc='cd ~/PPC'
alias public='cd ~/Public'
alias temp='cd ~/Temp'
alias test='cd ~/.test'
alias torrents='cd ~/Torrents'
alias ubuntu-texts='cd ~/Documents/"Ubuntu Texts"'
alias videos='cd ~/Videos'
alias webdesign='cd ~/Web/Design'
alias whereami='display_info'



##################################################
# Espeak commands				 #
##################################################

alias espeak-file='espeak -s 150 -f'
alias espeak-us='espeak -v en-us -s 150'
alias espeak-wav='espeak -s 150 -w voice.wav'
alias espeak-wav-file='espeak -s 150 -w voice.wav -f'



##################################################
# Git stuff					 #
##################################################

alias gitouch='find . \( -type d -empty \) -and \( -not -regex ./\.git.* \) -exec touch {}/.gitignore \;'
alias gitup='git pull'
alias gitci='git commit -a -m'
alias gitco='git clone'
alias gita='git add'
alias gitb='git branch'
alias gitc='git checkout'



##################################################
# Hardware Shortcuts				 #
##################################################

alias 0='amixer set PCM 0'
alias -- -='amixer set PCM 2-'
alias +='amixer set PCM 2+'
alias blankcd='cdrecord -v dev=/dev/cdrom blank=fast gracetime=3'
alias blankdvd='cdrecord -v dev=/dev/dvd blank=fast gracetime=3'
alias blueoff='sudo /etc/rc.d/bluetooth stop'
alias blueon='sudo /etc/rc.d/bluetooth start'
alias blueres='sudo /etc/rc.d/bluetooth restart'
alias brand='growisofs -Z /dev/cdrw -v -l -R -J -joliet-long'
alias burnaudiocd='mkdir ./temp &amp;&amp; for i in *.[Mm][Pp]3;do mpg123 -w "./temp/${i%%.*}.wav" "$i";done;cdrecord -pad ./temp/* &amp;&amp; rm -r ./temp'	# burn a directory of mp3s to an audio cd
alias cdc='eject -t /dev/cdrecorder'
alias cdo='eject /dev/cdrecorder'
alias cruzer='mount /media/cruzer'
alias dvdc='eject -t /dev/dvd'
alias dvdo='eject /dev/dvd'
alias dvdrip='vobcopy -i /dev/dvd/ -o ~/DVDs/ -l'
alias dvdrip_='mplayer dvd://1 -dumpstream -alang es -dumpfile "$HOME/$DVD".mpg &amp;&amp; ffmpeg -i "$HOME/$DVD".mpg -acodec libmp3lame -alang spa -vcodec libx264 -crf 26 -vpre hq -threads 0 "$HOME/$DVD.mp4"'
alias ipod='mount /media/ipod &amp;&amp; cd /media/ipod'
alias kingston='mount /media/kingston &amp;&amp; cd /media/kingston'
alias laptop_display='sudo cat /proc/acpi/video/VGA/LCD/brightness'		# set laptop display brightness	(path may vary depending on laptop model
alias laptop_displays='echo &lt;percentage&gt; &gt; /proc/acpi/video/VGA/LCD/brightness'	# to discover the possible values for your display
alias mountcd='sudo mount -t is09660 /dev/sr0 /media/cdrom'
alias mountedinfo='df -hT'
alias mountiso='sudo mount ${1} ${2} -t iso9660 -o ro,loop=/dev/loop0'
alias mountwin='mount -t ntfs /dev/sda1 /media/win'
alias mp3='mount /media/mp3 &amp;&amp; cd /media/mp3'
alias playm='for i in *.mp3; do play $i; done'
alias playo='for i in *.ogg; do play $i; done'
alias playw='for i in *.wav; do play $i; done'
alias scan='scanimage -L'
alias sd='mount /media/sd'
alias ucruzer='umount /media/cruzer'
alias uipod='umount /media/ipod'
alias ukingston='umount /media/kingston'
alias umountiso='sudo umount /media/iso'
alias ump3='umount /media/mp3'
alias usd='umount /media/sd'
alias uverbatim='umount /media/verbatim'
alias verbatim='mount /media/verbatim &amp;&amp; cd /media/verbatim'



##################################################
# Information					 #
##################################################

alias biggest='BLOCKSIZE=1048576; du -x | sort -nr | head -10'				# show biggest directories
alias boothistory='for wtmp in `dir -t /var/log/wtmp*`; do last reboot -f $wtmp; done | less'
alias charcount='wc -c $1'								# count number of characters in text file
alias cpu_hogs='ps wwaxr -o pid,stat,%cpu,time,command | head -10'			# to find CPU hogs
alias df='df -h -x tmpfs -x usbfs'							# displays global disk usage by partition, excluding supermounted devices
alias directorydiskusage='du -s -k -c * | sort -rn'
alias dir='ls --color=auto --format=vertical'
alias diskwho='sudo iotop'
alias dmidecode='sudo dmidecode --type 17 | more'					# check RAM sed and type in Linux
alias ducks='ls -A | grep -v -e '\''^\.\.$'\'' |xargs -i du -ks {} |sort -rn |head -16 | awk '\''{print $2}'\'' | xargs -i du -hs {}'	# useful alias to browse your filesystem for heavy usage quickly						# to show processes reading/writing to disk
alias du='du -h --max-depth=1'								# displays disk usage by directory, in human readable format
alias dush='du -sm *|sort -n|tail'							# easily find megabyte eating files or directories
alias env2='for _a in {A..Z} {a..z};do _z=\${!${_a}*};for _i in `eval echo "${_z}"`;do echo -e "$_i: ${!_i}";done;done|cat -Tsv'	# print all environment variables, including hidden ones
alias exportkeys='sudo apt-key exportall &gt; repokeys.txt'				# exports all repo keys info into single 'repokeys.txt' document
alias exportkey='sudo apt-key export'							# show single repo key info using keyid found in 'sudo apt-key list'
alias ffind='sudo find / -name $1'
alias free='free -m'									# RAM and SWAP detail in MBs
alias freqwatch='watch --interval 1 "cat /proc/acpi/thermal_zone/THRM/*; cat /proc/cpuinfo | grep MHz; cat /proc/acpi/processor/*/throttling"'  # monitor cpu freq and temperature
alias hardware='sudo lshw -html &gt; hardware.html'					# overview of the hardware in the computer
# alias hgrep='history | grep --color=always'						# search commands history
alias hiddenpnps='unhide (proc|sys|brute)'						# forensic tool to find hidden processes and ports
alias hogc='ps -e -o %cpu,pid,ppid,user,cmd | sort -nr | head'				# display the processes that are using the most CPU time and memory
alias hogm='ps -e -o %mem,pid,ppid,user,cmd | sort -nr | head'				# display the processes that are using the most CPU time and memory
alias la_='ls -Al'									# show hidden files
alias l?='cat ~/technical/tips/ls'
alias lc='ls -ltcr'       								# sort by and show change time, most recent last
alias ldir='ls -lhA |grep ^d'
alias ld='ls -ltr' 									# sort by date
alias lfiles='ls -lhA |grep ^-'
alias lf="ls -Alh --color | awk '{k=0;for(i=0;i&lt;=8;i++)k+=((substr(\$1,i+2,1)~/[rwx]/)*2^(8-i));if(k)printf(\" %0o \",k);print}'"	# full ls with octal+symbolic permissions
alias lgg='ls --color=always | grep --color=always -i'					# quick case-insenstive partial filename search
alias lh='ls -Al' 									# show hidden files
alias lh='ls -lAtrh' 									# sort by date and human readable
alias libpath='echo -e ${LD_LIBRARY_PATH//:/\\n}'
alias li='ls -ai1|sort' 								# sort by index number
alias linecount='wc -l $1'								# count number of lines in text file
alias lk='ls -lSr'									# sort by size
alias llllll='ls -FlaXo --color=auto'							# sort the extensions alphabetically; good for winfiles
alias lllll='ls -Fla --full-time -o -Q --color=auto'					# whatever
alias llll='ls -laS --color=auto'							# sort by size
alias lll='ls -Falot --color=auto'							# sort by mod time
alias ll_='ls -l'									# long listing
alias l.='ls -d .[[:alnum:]]* 2&gt; /dev/null || echo "No hidden file here..."'		# list only hidden files
alias l='ls -hF --color'								# quick listing
alias lm_='ls -al |more'    								# pipe through 'more'
alias ln='ln -s'
alias lr='ls -lR'									# recursice ls
alias lrt='ls -lart'									# list files with last modified at the end
alias lsam='ls -am' 									# List files horizontally
alias lsdd='ls -latr'                                 					# sort by date
alias lsd='ls -l | grep "^d"'								# list only directories
alias lsize='ls --sort=size -lhr'							# list by size
alias lsl='ls -lah'                                   					# long list, human-readable
alias ls='ls -hF --color'								# add colors for filetype recognition
alias lsnew='ls -Alh --color=auto --time-style=+%D | grep `date +%D`'
alias lss='ls -shaxSr'                         			       			# sort by size
alias lsss='ls -lrt | grep $1'								# to see something coming into ls output: lss
alias lsx='ls -ax' 									# sort right to left rather then in columns
alias lt_='ls -alt|head -20' 								# 20, all, long listing, modification time
alias lt='ls -ltr'         								# sort by date, most recent last
alias lu='ls -ltur'        								# sort by and show access time, most recent last
alias lx='ls -lXB'									# sort by extension
# alias man='TERMINFO=~/.terminfo TERM=mostlike LESS=C PAGER=less man'			# cool colors for manpages
alias mem_hogs_ps='ps wwaxm -o pid,stat,vsize,rss,time,command | head -10'		# to find memory hogs
alias mem_hogs_top='top -l 1 -o rsize -n 10'						# to find memory hogs
alias mem='~/.scripts/realmem'								# estimates memory usage
alias mypc="hal-get-property --udi /org/freedesktop/Hal/devices/computer --key 'system.hardware.product'"		# show computer model
alias myps='/bin/ps -u "$USER" -o user,pid,ppid,pcpu,pmem,args|less'			# ps
alias numFiles='echo $(ls -1 | wc -l)'							# numFiles: number of (non-hidden) files in current directory
alias packagelist="sudo aptitude search -F %p ~i --disable-columns"			# show list of all packages (columns)
alias packagelist_="sudo aptitude search -F %p ~i --disable-columns | sed 's/$/,/' | tr '\n\r' ' ' | sed 's/, $//'"	# list all packages (1-liner)
alias phonesearch='grep '[0-9]\{3\}-[0-9]\{4\}' "$1"'					# search phone #'s in file (requires XXX-XXX-XXXX format)
alias processbycpuusage="ps -e -o pcpu,cpu,nice,state,cputime,args --sort pcpu | sed '/^ 0.0 /d'"
alias processbymemusage='ps -e -o rss=,args= | sort -b -k1,1n | pr -TW$COLUMNS'
alias processtree='ps -e -o pid,args --forest'
alias pss='ps -ef | grep $1'								# to check a process is running in a box with a heavy load: pss
alias sete='set|sed -n "/^`declare -F|sed -n "s/^declare -f \(.*\)/\1 ()/p;q"`/q;p"'	# display environment vars only, using set
alias showallaliases='compgen -A alias'							# list bash alias defined in .bash_profile or .bashrc
alias showallfunctions='compgen -A function'						# list bash functions defined in .bash_profile or .bashrc
alias showkeys='sudo apt-key list'							# shows list of repository keys
alias sizeof='du -sh'
alias space='df -h'									# disk space usage
alias sshall='logwatch --service sshd --range all --detail high --print --archives'
alias sshtoday='logwatch --service sshd --range today --detail high --print --archives'
alias superfind='sudo find / ! \( -path /proc -prune -o -path /tmp -prune -o -path /dev -prune -o -path /mnt -prune \) -name'
alias top-commands='history | awk "{print $2}" | awk "BEGIN {FS="|"} {print $1}" |sort|uniq -c | sort -rn | head -10'	# show most popular commands
alias topforever='top -l 0 -s 10 -o cpu -n 15'						# continual 'top' listing (every 10 sec) showing top 15 CPU things
alias topten='du -sk $(/bin/ls -A) | sort -rn | head -10'				# displays the top ten biggest folders/files in the current directory
alias top20='du -xk | sort -n | tail -20'						# find the 20 biggest directories on the current filesystem
alias top_='xtitle Processes on $HOST &amp;&amp; top'						# uses the function 'xtitle'
alias treefind_="find . | sed 's/[^/]*\//|   /g;s/| *\([^| ]\)/+--- \1/'"		# displays a tree of the arborescence
alias tree='tree -Cs'									# nice alternative to 'ls'
alias unusedkernels="dpkg -l 'linux-*' | sed '/^ii/!d;/'"$(uname -r | sed "s/\(.*\)-\([^0-9]\+\)/\1/")"'/d;s/^[^ ]* [^ ]* \([^ ]*\).*/\1/;/[0-9]/!d'"											# show installed but unused linux headers, image, or modules
alias vdir='ls --color=auto --format=long'
alias ver='cat /etc/lsb-release'							# Ubuntu version detail
alias version='sudo apt-show-versions'							# show version
alias whichall='{ command alias; command declare -f; } | command which --read-functions --read-alias -a'		# which alias
alias wordcount='wc -w $1'								# count number of words in text file



##################################################
# Information (clock and date stuff)		 #
##################################################

alias bdate="date '+%a, %b %d %Y %T %Z'"
alias cal='cal -3' 									# show 3 months by default
alias da='date "+%Y-%m-%d %A    %T %Z"'							# date command
alias da_="date +'%a %Y-%m-%d %H:%M:%S %z'"						# another date command
alias dateh='date --help|sed "/^ *%a/,/^ *%Z/!d;y/_/!/;s/^ *%\([:a-z]\+\) \+/\1_/gI;s/%/#/g;s/^\([a-y]\|[z:]\+\)_/%%\1_%\1_/I"|while read L;do date "+${L}"|sed y/!#/%%/;done|column -ts_'	# view all date formats, quick reference help alias
alias daysleft='echo "There are $(($(date +%j -d"Dec 31, $(date +%Y)")-$(date +%j))) left in year $(date +%Y)."'	# how many days until the end of the year
alias epochtime='date +%s'								# report number of seconds since the Epoch
alias mytime='date +%H:%M:%S'								# shows just the current time
alias ntpdate='sudo ntpdate ntp.ubuntu.com pool.ntp.org'				# time synchronisation with NTP
alias oclock='read -a A&lt;&lt;&lt;".*.**..*....*** 8 9 5 10 6 0 2 11 7 4";for C in `date +"%H%M"|fold -w1`;do echo "${A:${A[C+1]}:4}";done'   # odd clock
alias onthisday='grep -h -d skip `date +%m/%d` /usr/share/calendar/*'			# on this day
alias secconvert='date -d@1234567890'							# convert seconds to human-readable format
alias stamp='date "+%Y%m%d%a%H%M"'							# timestamps
alias timestamp='date "+%Y%m%dT%H%M%S"'							# date command that lets you create timestamps in ISO 8601 format
alias today='date +"%A, %B %-d, %Y"'
alias weeknum='date +%V'								# perl one-liner to get the current week number



##################################################
# Miscellaneous					 #
##################################################

alias -- --='-;-'
alias -- ---='-;-;-'
alias -- ----='-;-;-;-'
alias -- -----='-;-;-;-;-'
alias ++='+;+'
alias +++='+;+;+'
alias ++++='+;+;+;+'
alias +++++='+;+;+;+;+'
alias addkey='sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys'
alias addrepo='sudo add-apt-repository'							# add a repo to repo .list
alias alert_helper='history|tail -n1|sed -e "s/^\s*[0-9]\+\s*//" -e "s/;\s*alert$//"'	# notified when job run in terminal is done using NotifyOSD
alias alert='notify-send -i gnome-terminal "Finished Terminal Job" "[$?] $(alert_helper)"'	# usage: sleep 5; alert
alias alsamixer='alsamixer -V all'
alias bashrc-copy-r='sudo cp /root/.bashrc ~/.bashrc'
alias bashrc-copy='sudo cp ~/.bashrc /root/.bashrc'
alias bashrc-cpr='sudo cp ~/.bashrc /root/.bashrc &amp;&amp; cp ~/.bashrc ~/Temp &amp;&amp; gedit ~/.bashrc &amp;&amp; exit'
alias bashrc='gedit ~/.bashrc &amp; exit'
alias bashrc-root='sudo gedit ~/.bashrc &amp; exit'
alias bashrc-temp='cp ~/.bashrc ~/Temp'
alias bbc='lynx -term=vt100 http://news.bbc.co.uk/text_only.stm'
alias bedit='vim ~/.bashrc; source ~/.bashrc'
alias beep='echo -en "\007"'								# ring the bell
alias bgedit='gedit ~/.bashrc; source ~/.bashrc'
alias blipfm="mpg123 `curl -s http://blip.fm/all | sed -e 's#"#\n#g'  | grep mp3$  | xargs`"	# play random music from blip.fm
alias capture='IMAGE="$HOME/Pictures/capture-`date +%Y%m%d%H%M%S`.png"; import -frame $IMAGE; echo "Image saved as $IMAGE"'	# save portion of desktop as image
alias cic='set completion-ignore-case On'						# make tab-completion case-insensitive
alias clisp='clisp -q'
alias color1='sh ~/.scripts/termcolor1'   						# displays colorset 1
alias color2='sh ~/.scripts/termcolor2'   						# displays colerset 2
alias color3='sh ~/.scripts/termcolor3'   						# displays colorset 3
alias commentremove="sed 's/[[:blank:]]*#.*//; /^$/d' "$1""				# this will remove comments that are at the end of lines
alias counts=sort | uniq -c | sort -nr							# a nice command for summarising repeated information
alias cut80='/usr/bin/cut -c 1-80'							# truncate lines longer than 80 characters (for use in pipes)
alias debrepack='sudo dpkg-repack'							# just an easier-to-remember alias for 'dpkg-repack'
alias differ='sdiff --suppress-common-lines'						# bash alias for sdiff: differ
alias dmregister='lynx http://desmoinesregister.com'
alias du0='du --max-depth=0'
alias du1='du --max-depth=1'
alias ebrc='nano ~/.bashrc'
alias ebrcupdate='source ~/.bashrc'
alias edit='nano'
alias elog='tai64nlocal'
alias encryptall='for f in * ; do [ -f $f ] &amp;&amp; openssl enc -aes-256-cbc -salt -in $f -out $f.enc -pass file:/tmp/password-file ; done'	# encrypt every file in current directory with 256-bit AES, retaining original
alias fixopera='rm -r ~/.opera/{mail,lock}'
alias fixres='xrandr --size 1600x1200'      						# reset resolution
alias fix_stty='stty sane'								# restore terminal settings when they get completely screwed up
alias flv2ogg='for i in $(ls *.flv); do ffmpeg2theora -v 6 --optimize $i; done'		# convert all FLV's in a directory to Ogg Theora (video)
alias flvaudio='ffmpeg -i "$1" -f mp3 -vn -acodec copy ouput.mp3'			# extract sound from flv &amp; make mp3
alias foldpb='pbpaste | fold -s | pbcopy'						# make text in clipboard wrap so as to not exceed 80 characters
alias funkcje="grep -o '^[a-zA-Z]\{1,\}.(*)' ~/.bashrc"
alias gdbbt='gdb -q -n -ex bt -batch'							# print stack trace of a core file without needing to enter gdb interactively
alias gifted='giftd -d &amp;&amp; giFTcurs'
alias gitk='screen -d -m gitk'
alias gmail='sh /$HOME/.scripts/gmail.sh'
alias googlevideo='wget -qO- "VURL" | grep -o "googleplayer.swf?videoUrl\\\x3d\(.\+\)\\\x26thumbnailUrl\\\x3dhttp" | grep -o "http.\+" | sed -e's/%\([0-9A-F][0-9A-F]\)/\\\\\x\1/g' | xargs echo -e | sed 's/.\{22\}$//g' | xargs wget -O "$1"'	# Google video download
alias gsop='gmplayer http://localhost:8909 -prefer-ipv4'
alias head='head -n $((${LINES:-`tput lines 2&gt;/dev/null||echo -n 12`} - 2))'		# alias HEAD for automatic smart output
alias hiresvideo='mplayer -framedrop -vfm ffmpeg -lavdopts lowres=1:fast:skiploopfilter=all'	# play high-res video files on a slow processor
alias image2pdf='convert -adjoin -page A4 *.jpeg multipage.pdf'				# convert images to a multi-page pdf
alias irb='irb --readline -r irb/completion -rubygems'
alias jargon='wget -m http://catb.org/~esr/jargon/html/ -nH --cut-dirs=2 -np -L -P ~/Jargon/'
alias kernbuild='make -j3 &amp;&amp; make modules_install &amp;&amp; ls -ld ../linux &amp;&amp; date'		# compile kernel, install modules, display kernel vers &amp; date
alias kfire='for i in `ps aux | grep [F]irefox `; do echo $i; kill $(($i)); done; '
# alias kfire='kill $(pidof firefox)'
# alias kfire='kill $(ps aux | awk '/firefox/ {print $2}' | tr '\n' ' ')'
alias killall='killall -u $USER -v' 							# only kill our own processes, and also be verbose about it
alias lastlog='lastlog | grep -v Never'
alias less='less -Mw'
alias lssd='ps ax | grep -v grep | grep -i firefox | while read pid; do kill "${pid%% *}"; done'
alias lstexfont='ls {/usr/share/texmf-dist/tex/latex/psnfss/*.sty,/usr/share/texmf-dist/tex/latex/pxfonts/*.sty}'
alias lvim="vim -c \"normal '0\""							# open the last file you edited in Vim.
alias makepasswd='makepasswd -minchars 8'
alias make_='xtitle Making $(basename $PWD) ; make'					# uses the function 'xtitle'
alias mencoder-join='mencoder -forceidx -ovc copy -oac copy -o'				# just add: whatever.avi whatever.pt1.avi whatever.pt2.avi ...
alias mic_record='arecord -q -f cd -r 44100 -c2 -t raw | lame -S -x -h -b 128 - `date +%Y%m%d%H%M`.mp3'	# record microphone input and output to date stamped mp3 file
alias minicom='minicom -c on' 								# enable colour (sudo apt-get install minicom)
alias mkdsp='sudo mknod /dev/dsp c 14 3 &amp;&amp; sudo chmod 777 /dev/dsp'			# remake /dev/dsp
alias mkpkg='makepkg -csi'
alias mp3ogg='mp32ogg *.mp3 &amp;&amp; rm *.mp3'
alias mpfb='mplayer -vo fbdev2 -fs -zoom -xy 1440'
alias mplayer_yt='mplayer -fs $(echo "http://youtube.com/get_video.php?$(curl -s "$1" | sed -n "/watch_fullscreen/s;.*\(video_id.\+\)&amp;title.*;\1;p")")'										# stream YouTube URL directly to mplayer
alias mtrue='sudo truecrypt /media/usbdisk/$USER.tc ~/$USER'
alias n2r='sudo /etc/init.d/nginx stop &amp;&amp; sleep 2 &amp;&amp; sudo /etc/init.d/nginx start'
alias ncftp='xtitle ncFTP ; ncftp'							# uses the function 'xtitle'
alias nytimes='lynx -term=vt100 http://nytimes.com'
alias passwords='passwd &amp;&amp; rm -rf ~/.gnome2/keyrings/*'					# removes keyring passwords and lets you change user password
alias ppa-purge='sudo ppa-purge'
alias pstree='/sw/bin/pstree -g 2 -w'
alias puttyreload='export TERM=putty &amp;&amp; source ~/.bashrc'
alias quota='quota -s'  								# human readable quota!
alias recursivetouch='find . -exec touch {} \;'						# be careful with this as it can modify time stamp of files
alias repo='gksudo gedit /etc/apt/sources.list'
alias restart-apache='sudo /etc/init.d/apache2 restart'
alias rkhunter='sudo rkhunter -c'
alias rmao='find . -iname a.out -exec rm {} \;'
alias rm_DS_Store_files='find . -name .DS_Store -exec rm {} \;'				# removes all .DS_Store file from the current dir and below
alias rsync-me='sudo rsync -a -v --progress --delete --modify-window=1 -s $HOME /home/rsync'
alias scpresume='rsync --partial --progress --rsh=ssh'
# alias screencast='ffmpeg -f alsa -ac 2 -i hw:0,0 -f x11grab -r 30 -s 1280x800+0+0 -i :0.0 -acodec pcm_s16le -vcodec libx264 -vpre lossless_ultrafast -threads 0 -y output.mkv'
# alias screencast='ffmpeg -f x11grab -r 30 -s 1280x800 -i :0.0 $HOME/outputFile.mpg'	# record a screencast and convert it to an mpeg
alias screencast="ffmpeg -y -f alsa -ac 2 -i pulse -f x11grab -r 30 -s `xdpyinfo | grep 'dimensions:'|awk '{print $2}'` -i :0.0 -acodec pcm_s16le output.wav -an -vcodec libx264 -vpre lossless_ultrafast -threads 0 output.mp4"		# capture video of a linux desktop
alias sdiff='/usr/bin/sdiff --expand-tabs --ignore-all-space --strip-trailing-cr --width=160'	# sdiff the way it was at IBM
alias sdirs='source ~/.dirs'
alias service='sudo service'								# access a system service
alias sh_diff='diff -abBpur'
alias sh_indent='indent -nsaf -npcs -cli2 -i2 -lp -nprs -nsaw -nut -cbi2 -bli0 -bls -nbad -npsl'
alias shot!='archey &amp;&amp; scrot -d 5 -c screen_`date +%Y-%m-%d`.png'			# is also a function of shot which does the screen for one window
alias show_='cat ~/.dirs'
alias show-colors='~/.bin/colors.sh'
alias show-info='~/.bin/info.pl'
alias show_options='shopt'								# show_options: display bash options settings
alias showrepo='cat /etc/apt/sources.list `ls /etc/apt/sources.list.d/*.list` | egrep -v "^$"'
alias sh_svnstat="svn status | awk '/^[^?]/'"
alias sourcea='source ~/.aliases.bash'							# to source this file (to make changes active after editing)
alias ssinfo='perl ~/.scripts/ssinfo.pl'
alias stopflash='for i in ~/.adobe ~/.macromedia ; do ( rm $i/ -rf ; ln -s /dev/null $i ) ; done'	# brute force way to block all LSO cookies with the non-free Flash browser plugin
# alias svnaddall='find "$PWD" -exec svn add {} 2&gt;/dev/null \;'				# add all files recursively
alias svnaddall='svn status | grep "^\?" | awk "{print \$2}" | xargs svn add'
alias svndelall='svn status | grep "^\!" | awk "{print \$2}" | xargs svn delete'
alias svnrmallentries='find . -name .svn -print0 | xargs -0 rm -rf'			# remove all .svn directories recursively
alias tailm='multitail'
alias tarred='( ( D=`builtin pwd`; F=$(date +$HOME/`sed "s,[/ ],#,g" &lt;&lt;&lt; ${D/${HOME}/}`#-%F.tgz); tar --ignore-failed-read --transform "s,^${D%/*},`date +${D%/*}.%F`,S" -czPf "$"F "$D" &amp;&gt;/dev/null ) &amp; )'					# create date-based tgz of current dir (runs in background)
# alias themeinfo='perl ~/Scripts/info.pl'
alias thumbit='mogrify -resize 25%'
alias tinyurl='~/.scripts/tinyurl'							# converts url to tinyurl
alias tkeys='tmux list-keys'  								# shows all tmux keys
alias trace='~/.scripts/trace'								# visual traceroute
alias txt2md='rename 's/\.txt$/\.md$/i' *'						# batch rename extension of all .txt files to .md files in a folder
alias ugrub2='sudo update-grub2'							# update grub2
alias ugrub='sudo update-grub'								# update grub
alias updatedb='sudo updatedb'
alias updatefonts='sudo fc-cache -vf'
alias usbb='rsync -avz /media/usbdisk/ ~/backup/usb/'
alias utrue='sudo truecrypt -d'
alias webcam='mplayer -cache 128 -tv driver=v4l2:width=176:height=177 -vo xv tv:// -noborder -geometry "95%:93%" -ontop'	# mplayer webcam window for screencasts
alias webshare='python -c "import SimpleHTTPServer; SimpleHTTPServer.test();"'
alias wiki='wikipedia2text -p'								# convert wiki to text output
alias xinitrc='vim ~/.xinitrc'
alias xsnow='(killall xsnow ; sleep 3 ; exec xsnow -nosanta -notrees -norudolf -nokeepsnow &gt;&amp; /dev/null &amp;)'	# xsnow



##################################################
# Miscellaneous Fun				 #
##################################################

alias 99bottles='x="bottles of beer";y="on the wall";for b in {99..1};do echo "$b $x $y, $b $x. Take one down pass it around, $(($b-1)) $x $y"; sleep 3;done'
alias addictive='count="1" ; while true ; do read next ; if [[ "$next" = "$last" ]] ; then count=$(($count+1)) ; echo "$count" ; else count="1" ; echo $count ; fi ; last="$next" ; done'								# simple addicting bash game
alias busy='for i in `seq 0 100`;do timeout 6 dialog --gauge "Install..." 6 40 "$i";done'	# pretend to be busy in office to enjoy a cup of coffee
alias busy2='my_file=$(find /usr/include -type f | sort -R | head -n 1); my_len=$(wc -l $my_file | awk "{print $1}"); let "r = $RANDOM % $my_len" 2&gt;/dev/null; vim +$r $my_file'
alias busy3='cat /dev/urandom | hexdump -C | highlight ca fe 3d 42 e1 b3 ae f8 | perl -MTime::HiRes -pnE "Time::HiRes::usleep(rand()*1000000)"'
alias earth='rm -f ~/Pictures/Backgrounds/mercator.jpg &amp;&amp; wget -r -N http://static.die.net/earth/mercator/1600.jpg -O ~/Pictures/Backgrounds/mercator.jpg &amp;&amp; gconftool-2 --type string --set /desktop/gnome/background/picture_filename ~/Pictures/Backgrounds/mercator.jpg'	# live earth wallpaper
# alias earth='mv ~/Pictures/Backgrounds/mercator.jpg ~/Pictures/Backgrounds/mercator.`timestamp`.jpg | wget -r -N http://static.die.net/earth/mercator/1600.jpg -O ~/Pictures/Backgrounds/mercator.jpg &amp;&amp; gconftool-2 --type string --set /desktop/gnome/background/picture_filename ~/Pictures/Backgrounds/mercator.jpg'	# live earth wallpaper (downloads and saves each time)
alias einsteiny='A=1;B=100;X=0;C=0;N=$[$RANDOM%$B+1];until [ $X -eq $N ];do read -p "N between $A and $B. Guess? " X;C=$(($C+1));A=$(($X&lt;$N?$X:$A));B=$(($X&gt;$N?$X:$B));done;echo "Took you $C tries, Einstein";'						# numbers guessing game
alias etchasketch='c=12322123;x=20;y=20;while read -sn1 p;do k=${c:(p-1)*2:2};let x+=$((k/10-2));let y+=$((k%10-2));echo -en \\033[$y\;"$x"HX;done'	# use the 1 2 3 and 4 keys to move the cursor around the screen (It's an etch-a-sketch for your terminal!)
alias excuses='echo `telnet bofh.jeffballard.us 666 2&gt;/dev/null` |grep --color -o "Your excuse is:.*$"'		# excuses
alias freechess='telnet fics.freechess.org 5000'						# connects to a telnet server for free internet chess
alias funfacts='wget http://www.randomfunfacts.com -O - 2&gt;/dev/null | grep \&lt;strong\&gt; | sed "s;^.*&lt;i&gt;\(.*\)&lt;/i&gt;.*$;\1;";'
alias funknet='telnet the-funk.net 7000'							# Access to Funk.net
alias futurama='curl -Is slashdot.org | sed -n '5p' | sed 's/^X-//''				# get Futurama quotations from slashdot.org servers
alias guitartune='for n in E2 A2 D3 G3 B3 E4;do play -n synth 4 pluck $n repeat 2;done'		# tune your guitar from the command line
alias iamcow='fortune | cowsay'
alias iamsurprise='fortune | cowsay -f $(random_cow)'
alias insults='wget http://www.randominsults.net -O - 2&gt;/dev/null | grep \&lt;strong\&gt; | sed "s;^.*&lt;i&gt;\(.*\)&lt;/i&gt;.*$;\1;";'
alias lotto='shuf -i 1-49 -n 6 | sort -n | xargs'						# lotto generator
alias matrix='echo -e "\e[32m"; while :; do for i in {1..16}; do r="$(($RANDOM % 2))"; if [[ $(($RANDOM % 5)) == 1 ]]; then if [[ $(($RANDOM % 4)) == 1 ]]; then v+="\e[1m $r   "; else v+="\e[2m $r   "; fi; else v+="     "; fi; done; echo -e "$v"; v=""; done'
alias matrix2='echo -e "\e[31m"; while $t; do for i in `seq 1 30`;do r="$[($RANDOM % 2)]";h="$[($RANDOM % 4)]";if [ $h -eq 1 ]; then v="\e[1m $r";else v="\e[2m $r";fi;v2="$v2 $v";done;echo -e $v2;v2="";done;'
alias matrix3='COL=$(( $(tput cols) / 2 )); clear; tput setaf 2; while :; do tput cup $((RANDOM%COL)) $((RANDOM%COL)); printf "%$((RANDOM%COL))s" $((RANDOM%2)); done'
alias matrix4='echo -ne "\e[32m" ; while true ; do echo -ne "\e[$(($RANDOM % 2 + 1))m" ; tr -c "[:print:]" " " &lt; /dev/urandom | dd count=1 bs=50 2&gt; /dev/null ; done'
alias matrix5='tr -c "[:digit:]" " " &lt; /dev/urandom | dd cbs=$COLUMNS conv=lcase,unblock | GREP_COLOR="1;32" grep --color "[^ ]"'
alias roulette='[ $[ $RANDOM % 6 ] == 0 ] &amp;&amp; echo Die || echo Live'				# command line Russian roulette
alias starwars='telnet towel.blinkenlights.nl'							# the famous starwars ASCII version from telnet
alias termvideo_bw='mplayer -vo aa'								# watch movies in ASCII (just direct to the video)
alias termvideo='mplayer -vo caca'								# watch movies in ASCII (just direct to the video)
alias wooters='telnet zerocarbs.wooters.us'							# connects to a telnet service monitoring Woot (Gives you an updating woot! item tracker!)



##################################################
# Network/Internet -oriented stuff		 #
##################################################

alias appson="netstat -lantp | grep -i stab | awk -F/ '{print $2}' | sort | uniq"	# view only the process name using an internet connection
alias bandwidth='dd if=/dev/zero of=/dev/null bs=1M count=32768'			# processor / memory bandwidthd? in GB/s
alias browse_bonjour='dns-sd -B'							# browse services advertised via Bonjour
# alias daemons='ls /var/run/daemons'  							# daemon managment (ommited for function)
alias dbdumpcp='scp -P 1234 username@12.34.56.78:$HOME/Backup/www/data/someSite/db.sql $HOME/Backup/data/db.sql'	# copy remote db to local
alias dns='cat /etc/resolv.conf'							# view DNS numbers
alias domain2ban='~/.scripts/Domain2Ban.sh'
alias estab='ss -p | grep STA' 								# view only established sockets (fails if "ss" is screensaver alias)
alias finchsync='java -jar ~/finchsync/finchsync.jar'					# start FinchSync Admin
# alias ftop='watch -d -n 2 'df; ls -FlAt;''						# like top, but for files
alias hdinfo='hdparm -i[I] /dev/sda'							# hard disk information - model/serial no.
alias hostip='wget http://checkip.dyndns.org/ -O - -o /dev/null | cut -d: -f 2 | cut -d\&lt; -f 1'
alias hostname_lookup='lookupd -d'							# interactive debugging mode for lookupd (use tab-completion)
alias http_trace='pkt_trace port 80'							# to show all HTTP packets
alias iftop='sudo iftop -i eth0' 							# start "iftop" program (sudo apt-get install iftop)
alias ip4grep="grep -E '([0-9]{1,3}\.){3}[0-9]{1,3}'"					# look for IPv4 address in files
alias ip='curl www.whatismyip.org'
alias ip_info='ipconfig getpacket en1'							# info on DHCP server, router, DNS server, etc (for en0 or en1)
alias ipt80='sudo iptstate -D 80'							# check out only iptables state of http port 80 (requires iptstate)
alias ip_trace='pkt_trace ip'								# to show all IP packets
alias ipttrans='sudo iptstate -D 51413'							# iptables state of Transmission-Daemon port (requires iptstate)
alias listen='sudo netstat -pnutl' 							# lists all listening ports together with PID of associated process
alias lsock='sudo /usr/sbin/lsof -i -P'							# to display open sockets ( -P option to lsof disables port names)
alias memrel='free &amp;&amp; sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches &amp;&amp; free'		# release memory used by the Linux kernel on caches
alias net1='watch --interval=2 "sudo netstat -apn -l -A inet"'
alias net2='watch --interval=2 "sudo netstat -anp --inet --inet6"'
alias net3='sudo lsof -i'
alias net4='watch --interval=2 "sudo netstat -p -e --inet --numeric-hosts"'
alias net5='watch --interval=2 "sudo netstat -tulpan"'
alias net6='sudo netstat -tulpan'
alias net7='watch --interval=2 "sudo netstat -utapen"'
alias net8='watch --interval=2 "sudo netstat -ano -l -A inet"'
alias netapps="lsof -P -i -n | cut -f 1 -d ' '| uniq | tail -n +2"
alias nethogs='sudo nethogs eth0' 							# start "nethogs" program (sudo apt-get install nethogs)
alias netl='sudo nmap -sT -O localhost'
alias netscan='sudo iwlist wlan0 scan'							# to scan your environment for available networks, do the following
alias netstats='sudo iwspy wlan0'							# if card supports it, you can collect wireless statistics by using
alias network='sudo lshw -C network' 							# view network device info
alias networkdump='sudo tcpdump not port 22' 						# dump all the network activity except ssh stuff
alias nsl='netstat -f inet | grep -v CLOSE_WAIT | cut -c-6,21-94 | tail +2'		# show all programs connected or listening on a network port
alias ns='netstat -alnp --protocol=inet | grep -v CLOSE_WAIT | cut -c-6,21-94 | tail +2'
alias openports='sudo netstat -nape --inet' 						# view open ports
alias pkt_trace='sudo tcpflow -i `active_net_iface` -c'
alias ports='lsof -i -n -P' 								# view programs using an internet connection
alias portstats='sudo netstat -s' 							# show statistics for all ports
alias proxy1='ssh -p 1234 -D 5678 username@12.34.56.78'					# SOCKS proxy - these anonomise browsing - 12.34.56.78
alias proxy2='ssh -p 8765 -D 4321 username@87.65.43.21'					# SOCKS proxy - these anonomise browsing - 87.65.43.21
alias ramvalue='sudo dd if=/dev/mem | cat | strings'					# will show you all the string (plain text) values in ram
alias randommac='python -c "from itertools import imap; from random import randint; print ':'.join(['%02x'%x for x in imap(lambda x:randint(0,255), range(6))])"'										# generate random valid mac addresses
alias remote='ssh -p 1234 12.34.56.78'							# access some remote host
alias restartnet='sudo /etc/rc.d/network restart;sudo /etc/rc.d/wicd restart'
alias rssup='php /srv/http/rssupdate.php'
alias setessid='sudo iwconfig wlan0 essid network-essid'				# set the essid, which identifies the network access point you want
alias smtp_trace='pkt_trace port smtp'							# to show all SMTP packets
alias someDBdump='sudo mysqldump someDB -uroot -p &gt; $HOME/www/_dbs/someDB.sql'
alias spavr='gtkterm -c avr'
# alias spavr='sudo chmod a=rw /dev/ttyUSB0; gtkterm -c avr'
alias spk800i='gtkterm -c k800i'
# alias spk800i='sudo chmod a=rw /dev/rfcomm0; gtkterm -c k800i'
alias sync='java -jar ~/finchsync/finchsync.jar -nogui'					# sync to PDA .. well, that'll be a sync then! - start FinchSync SVR
alias syncoff='java -jar ~/Apps/FinchSync/finchsync.jar -stopserver'			# sync to PDA .. well, that'll be a sync then! - stop FinchSync SVR
alias tcpstats='sudo netstat -st' 							# show statistics for tcp ports
alias tcp_='sudo netstat -atp' 								# list all TCP ports
alias tcp_trace='pkt_trace tcp'								# to show all TCP packets
alias topsites='curl -s -O http://s3.amazonaws.com/alexa-static/top-1m.csv.zip ; unzip -q -o top-1m.csv.zip top-1m.csv ; head -1000 top-1m.csv | cut -d, -f2 | cut -d/ -f1 &gt; topsites.txt'							# get a list of top 1000 sites from alexa
alias tproxy='ssh -ND 8118 user@server&amp;; export LD_PRELOAD="/usr/lib/libtsocks.so"'	# creates a proxy based on tsocks
alias udpstats='sudo netstat -su' 							# show statistics for udp ports
alias udp='sudo netstat -aup' 								# list all UDP ports
alias udp_trace='pkt_trace udp'								# to show all UDP packets
alias uploads='cd /some/folder'								# access some folder
alias vncup='x11vnc -nopw -ncache 10 -display :0 -localhost'
alias website_dl='wget --random-wait -r -p -e robots=off -U mozilla "$1"'		# download an entire website
alias website_images='wget -r -l1 --no-parent -nH -nd -P/tmp -A".gif,.jpg" "$1"'	# download all images from a site
alias whois='whois -H'
alias wscan='iwlist scan'								# terminal network scan for wireless signals
alias wwwmirror2='wget -k -r -l ${2} ${1}'						# wwwmirror2 usage: wwwmirror2 [level] [site_url]
alias wwwmirror='wget -ErkK -np ${1}'



##################################################
# Package making and installation		 #
##################################################

alias checkinstall-force='sudo checkinstall --dpkgflags "--force-overwrite"'
alias checkinstall-noinstall='sudo checkinstall -y --fstrans=no --install=no'
alias checkinstall='sudo checkinstall -y --fstrans=no'
alias debinstall-force='sudo dpkg -i --force-overwrite'
alias debinstall='sudo dpkg -i'
alias diffinstall='diff /tmp/install.pre /tmp/install.pos | grep \"^&gt;\" | sed \"s/^&gt; //g\"'	# run diffinstall fourth, after diffinstall to show what files were copied in your system
alias postinstall='sudo find / ! \( -path /proc -prune -o -path /tmp -prune -o -path /dev -prune -o -path /mnt -prune \) &gt; /tmp/install.pos'	# run postinstall third, after "make install"
alias preinstall='sudo find / ! \( -path /proc -prune -o -path /tmp -prune -o -path /dev -prune -o -path /mnt -prune \) &gt; /tmp/install.pre'	# run preinstall first, then "make install"



##################################################
# Permissions					 #
##################################################

alias 000='chmod 000'
alias 640='chmod 640'
alias 644='chmod 644'
alias 755='chmod 755'
alias 775='chmod 775'
alias mx='chmod a+x'
alias perm='stat --printf "%a %n \n "'								# requires a file name e.g. perm file
alias restoremod='chgrp users -R .;chmod u=rwX,g=rX,o=rX -R .;chown $(pwd |cut -d / -f 3) -R .'	# restore user,group and mod of an entire website



##################################################
# Personal help					 #
##################################################

alias a?='cat ~/.alias.help'
alias dn='OPTIONS=$(\ls -F | grep /$); select s in $OPTIONS; do cd $PWD/$s; break;done'
alias espanol='echo -e \"á Á é É í Í ó Ó ú Ú ñ Ñ ü Ü ¿ ¡ ¢ ‘ ’ “ ” „ ‚ …\"'
alias f?='cat ~/.function.help'
alias help='OPTIONS=$(\ls ~/.tips -F);select s in $OPTIONS; do less ~/.tips/$s; break;done'
alias testh='help test|sed -e :a -e "$!N;s/\(-n STRING\)\n/\1, /;s/\n\( \{23\}\| \{4\}\([a-z]\)\)/ \2/;ta;P;D"|sed "s/ \{1,\}/ /g;/^ $/d;/:$/s/^/\n/"|sed -n "/File operators:/,\$p"'				# test quick help alias



##################################################
# Secure-delete substitution			 #
##################################################

alias sfill-freespace='sudo sfill -I -l -l -v'
alias sfill-f='sudo sfill -f -l -l -v -z'
alias sfill='sudo sfill -l -l -v -z'
alias sfill-usedspace='sudo sfill -i -l -l -v'
alias smem-f='sudo sdmem -f -l -l -v'
alias smem-secure='sudo sdmem -v'
alias smem='sudo sdmem -l -l -v'
alias srm-m='sudo srm -f -m -z -v'
alias srm='sudo srm -f -s -z -v'
alias sswap-sda5='sudo sswap -f -l -l -v -z /dev/sda5'
alias sswap='sudo sswap -f -l -l -v -z'
alias swapoff='sudo swapoff /dev/sda5'
alias swapon='sudo swapon /dev/sda5'



##################################################
# Set up auto extension stuff			 #
##################################################

###### If -s flags present, define suffix alias: if command word on command line is in form `text.name',
# where text is any non-empty string, its replaced by text 'value text.name'. Note that names treated as literal
# string, not pattern.  A trailing space in value is not special in this case. For example, alias -s ps=gv
# will cause command `*.ps' to be expanded to `gv *.ps'. As alias expansion is carried out earlier than globbing,
# `*.ps' will then be expanded. Suffix aliases constitute different name space from other aliases (so in above
# example its still possible to create alias for command ps) and two sets are never listed together.
# alias -s avi=mplayer
# alias -s bz2=tar -xjvf
# alias -s com=$BROWSER
# alias -s cpp=vim
# alias -s doc=soffice
# alias -s eps=eog
# alias -s gif=eog
# alias -s gz=tar -xzvf
# alias -s html=$BROWSER
# alias -s img=mplayer
# alias -s install=$EDITOR
# alias -s iso=mplayer
# alias -s java=$EDITOR
# alias -s jpg=eog
# alias -s mkv=mplayer
# alias -s mp3=mplayer
# alias -s mpeg=mplayer
# alias -s mpg=mplayer
# alias -s mws=maple
# alias -s net=$BROWSER
# alias -s odt=soffice
# alias -s org=$BROWSER
# alias -s pdf=evince
# alias -s php=$BROWSER
# alias -s PKGBUILD=vim
# alias -s png=eog
# alias -s ppt=soffice
# alias -s ps=gv
# alias -s se=$BROWSER
# alias -s sh=vim
# alias -s sxw=soffice
# alias -s tex=$EDITOR
# alias -s txt=$EDITOR
# alias -s wmv=mplayer
# alias -s xls=soffice



##################################################
# Shred substitution				 #
##################################################

alias shred-sda-r='sudo shred -v -z -n 1 /dev/sda'
alias shred-sda='sudo shred -v -z -n 0 /dev/sda'
alias shred-sdb-r='sudo shred -v -z -n 1 /dev/sdb'
alias shred-sdb='sudo shred -v -z -n 0 /dev/sdb'
alias shred-sdc-r='sudo shred -v -z -n 1 /dev/sdc'
alias shred-sdc='sudo shred -v -z -n 0 /dev/sdc'
alias shred-sdd-r='sudo shred -v -z -n 1 /dev/sdd'
alias shred-sdd='sudo shred -v -z -n 0 /dev/sdd'
alias shred-sde-r='sudo shred -v -z -n 1 /dev/sde'
alias shred-sde='sudo shred -v -z -n 0 /dev/sde'
alias shred-sdf-r='sudo shred -v -z -n 1 /dev/sdf'
alias shred-sdf='sudo shred -v -z -n 0 /dev/sdf'
alias shred-sdg-r='sudo shred -v -z -n 1 /dev/sdg'
alias shred-sdg='sudo shred -v -z -n 0 /dev/sdg'



##################################################
# Xterm and Aterm				 #
##################################################

alias aterm='xterm -ls -fg gray -bg black'
alias termb='xterm -bg AntiqueWhite -fg NavyBlue &amp;'
alias termg='xterm -bg AntiqueWhite -fg OliveDrab &amp;'
alias termr='xterm -bg AntiqueWhite -fg DarkRed &amp;'
alias term='xterm -bg AntiqueWhite -fg Black &amp;'
alias xsu='xterm -fn 7x14 -bg DarkOrange4 -fg white -e su &amp;'
alias xtop='xterm -fn 6x13 -bg LightSlateGray -fg black -e top &amp;'



##################################################
##################################################
##################################################
</t>
<t tx="sa.20110119002240.1277"># check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize
</t>
<t tx="sa.20110119002240.1278"># set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] &amp;&amp; [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi
</t>
<t tx="sa.20110119002240.1279"># make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] &amp;&amp; eval "$(SHELL=/bin/sh lesspipe)"
</t>
<t tx="sa.20110119002240.1280"># Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] &amp;&amp; echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//'\'')"'

</t>
<t tx="sa.20110119002240.1281"># autoload -U compinit
# compinit
export BLOCKSIZE=K
export BROWSER='firefox'
# export BROWSER=$(find_alternatives chromium-browser google-chrome opera firefox firefox-bin iceweasel konqueror w3m lynx)	# uses function 'find_alternatives'
# export CDPATH=.:~:~/src:/etc
# export DISPLAY=:79
# export EDITOR="gedit -w --resume" Typing 'fc'	# open last command for editing in gedit, then execute on save
export EDITOR='vi'
# export ftp_proxy=${MY_PROXY}
# export GPG_TTY='tty'				# gpg-agent says it needs this
# export GREP_OPTIONS='-D skip --binary-files=without-match --ignore-case'		# most commonly used grep options
export HISTCONTROL=ignoreboth:erasedups		# for 'ignoreboth': ignore duplicates and /^\s/
# export HISTCONTROL=ignoredups			# don't put duplicate lines in the history. See bash(1) for more options
# export HISTFILE='$HOME/.history'
# export HISTFILESIZE=10000
# export HISTFILESIZE=${HISTSIZE}		# bash will remember N commands
export HISTIGNORE='&amp;:bg:fg:ll:h'
# export HISTIGNORE='${HISTIGNORE:+$HISTIGNORE:}la:ll:lah:lat:;a:-:fg:bg:j:sync:esu:rma:rmp:fol:pfol'
# export HISTIGNORE="&amp;:ls:[bf]g:exit"		# duplicate entries in bash history, as well as ls, bg, fg &amp; exit, making for cleaner bash history
# export HISTIGNORE="&amp;:ls:ll:la:l.:pwd:exit:clear"
# export HISTIGNORE='pwd:cd:ls:ls -l:'		# ignore commands given
export HISTSIZE=10000
# export HISTTIMEFORMAT='| %d/%m/%y %T | '	# make 'History' Show The Date For Each Command
# export HISTTIMEFORMAT='%F %T '		# adds date and time to history
export HISTTIMEFORMAT='%H:%M &gt; '
# export HISTTIMEFORMAT='%s' 			# the beloved Second of Our Linux
# export HISTTIMEFORMAT='%Y-%b-%d::%Hh:%Mm:%Ss '
export HISTTIMEFORMAT='%Y-%m-%d_%H:%M:%S_%a  '	# makes history display in YYYY-MM-DD_HH:MM:SS_3CharWeekdaySpaceSpace format
export HOSTFILE=$HOME/.hosts    		# put list of remote hosts in ~/.hosts ...
# export http_proxy=${MY_PROXY}
# export https_proxy=${MY_PROXY}
# export IGNOREEOF=1				# prevent CTRL-D from immediately logging out
# export INPUTRC=/etc/inputrc			# it's possible that this will make bash find my delete key (and everything else)((but i don't think it did))
# export LC_COLLATE="en_CA.utf8"		# change sorting methods [a-Z] instead of [A-Z]
export LESSCHARSET='latin1'
export LESS='-i -N -w  -z-4 -g -e -M -X -F -R -P%t?f%f \'
# export LESSOPEN="|lesspipe.sh %s"; export LESSOPEN
export LESSOPEN='|/usr/bin/lesspipe.sh %s 2&gt;&amp;-'	# use this if lesspipe.sh exists
# export LESS="-QR"				# tell less not to beep and also display colours
# export LESS='-R'
# export LESS_TERMCAP_mb=$'\E[01;31m'      	# less colors for Man pages # begin blinking
# export LESS_TERMCAP_md=$'\E[01;38;5;74m'  	# less colors for Man pages # begin bold
# export LESS_TERMCAP_me=$'\E[0m'           	# less colors for Man pages # end mode
# export LESS_TERMCAP_se=$'\E[0m'           	# less colors for Man pages # end standout-mode
# export LESS_TERMCAP_so=$'\E[38;5;246m'    	# less colors for Man pages # begin standout-mode - info box
# export LESS_TERMCAP_ue=$'\E[0m'           	# less colors for Man pages # end underline
# export LESS_TERMCAP_us=$'\E[04;38;5;146m' 	# less colors for Man pages # begin underline
# export MY_PROXY='http://YOUR_USERNAME:YOUR_PASSWORD@PROXY_IP:PROXY_PORT/'
# export OOO_FORCE_DESKTOP=gnome   		# openoffice preferences
export PAGER='less -e'
# export PATH=$PATH:$HOME/scripts
# export PILOTRATE=57600			# make pilot-xfer go faster than 9600
export TERM='xterm'
export TIMEFORMAT=$'\nreal %3R\tuser %3U\tsys %3S\tpcpu %P\n'
export TMOUT=600				# auto logout after n seconds of inactivity
# export USER_CLIENT=deluge
# export USER_DPRT=22218
# export USER_OPRT=47426
# export USER_VPRT=79
# export USER_WPRT=30818
export VISUAL='vi'
</t>
<t tx="sa.20110119002240.1282">##################################################
# Color chart					 #
##################################################

txtblk='\e[0;30m' # Black - Regular
txtred='\e[0;31m' # Red
txtgrn='\e[0;32m' # Green
txtylw='\e[0;33m' # Yellow
txtblu='\e[0;34m' # Blue
txtpur='\e[0;35m' # Purple
txtcyn='\e[0;36m' # Cyan
txtwht='\e[0;37m' # White
bldblk='\e[1;30m' # Black - Bold
bldred='\e[1;31m' # Red
bldgrn='\e[1;32m' # Green
bldylw='\e[1;33m' # Yellow
bldblu='\e[1;34m' # Blue
bldpur='\e[1;35m' # Purple
bldcyn='\e[1;36m' # Cyan
bldwht='\e[1;37m' # White
unkblk='\e[4;30m' # Black - Underline
undred='\e[4;31m' # Red
undgrn='\e[4;32m' # Green
undylw='\e[4;33m' # Yellow
undblu='\e[4;34m' # Blue
undpur='\e[4;35m' # Purple
undcyn='\e[4;36m' # Cyan
undwht='\e[4;37m' # White
bakblk='\e[40m'   # Black - Background
bakred='\e[41m'   # Red
badgrn='\e[42m'   # Green
bakylw='\e[43m'   # Yellow
bakblu='\e[44m'   # Blue
bakpur='\e[45m'   # Purple
bakcyn='\e[46m'   # Cyan
bakwht='\e[47m'   # White
txtrst='\e[0m'    # Text Reset
</t>
<t tx="sa.20110119002240.1283">##################################################
# More command prompt choices (CHOOSE ONE, either#
# one of single lines below, or one of the	 #
# fancier ones farther below - just uncomment	 #
# one want and comment mine above)		 #
##################################################

# PS1='\[\033[01;31m\]\u\[\033[01;36m\]@\[\033[01;32m\]\h\[\033[01;33m\]:\[\033[01;33m\]\w\n\[\033[01;31m\]\$ \[\033[00;32m\]'	# red, cyan, green, yellow with green output
# PS1="\[\033[01;32m\]\u@\h\[\033[01;34m\] \w \$\[\033[00m\] "					# green and blue prompt with pc name &amp; default black output
# PS1="\[\033[0;31m\][\u] [ \w ] \[\033[0m\] \n # "						# red with default black output (2-tier)
# PS1="\[\033[0;33m\][\!]\`if [[ \$? = "0" ]]; then echo "\\[\\033[32m\\]"; else echo "\\[\\033[31m\\]"; fi\`[\u.\h: \`if [[ `pwd|wc -c|tr -d " "` &gt; 18 ]]; then echo "\\W"; else echo "\\w"; fi\`]\$\[\033[0m\] "; echo -ne "\033]0;`hostname -s`:`pwd`\007"	# yellow and green with default black output
# PS1="\[\033[0;33m\][\!]\`if [[ \$? = "0" ]]; then echo "\\[\\033[32m\\]"; else echo "\\[\\033[31m\\]"; fi\`[\u.\h: \`if [[ `pwd|wc -c|tr -d " "` &gt; 18 ]]; then echo "\\W"; else echo "\\w"; fi\`]\$\[\033[0m\] "; echo -ne "\033]0;`hostname -s`:`pwd`\007"	# yellow, green, w/black output w/color change upon bad command
# PS1="\[\033[0;34m\][\u] \[\033[0;0m\]\w \[\033[0m\]$ "					# blue username and default black output
# PS1="\[\033[0;34m\][\u] \[\033[0;31m\][ \w ] \[\033[0m\] \n &gt;&gt; "				# blue and red with default black output (2-tier)
# PS1="\[\033[0;34m\][\u] \[\033[0;33m\][ \t ] \[\033[0;31m\][ \w ] \[\033[0m\] \n &gt;&gt; "		# blue, yellow, red with default black output (2-tier)
# PS1='\[\033[1;30m\][\[\033[0;37m\]${PIPESTATUS}\[\033[1;30m\]:\[\033[0;37m\]${SHLVL}\[\033[1;30m\]:\[\033[0;37m\]\j\[\033[1;30m\]][\[\033[1;34m\]\u\[\033[0;34m\]@\[\033[1;34m\]\h\[\033[1;30m\]:\[\033[0;37m\]`tty | sed s/\\\\\/dev\\\\\/\//g`\[\033[1;30m\]]\[\033[0;37m\][\[\033[1;37m\]\W\[\033[0;37m\]]\[\033[1;30m\] \$\[\033[00m\] '									# grey and blue with default black output
# PS1="[\[\033[1;34m\]\u\[\033[0m\]@\h \W]\\$ "							# blue username with default colors (black)
# PS1="[\!] \033[1;36m[ \u@\h ]\033[1;32m\] [ \t ] [ \d ]\n\033[1;33m\[[ \w ] \033[00m\\n\[\e[30;1m\](\[\e[32;1m\]\$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') files, \$(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')b\[\e[30;1m\]) \[\e[0m\] $: "	# black, cyan, green, yellow, default black output (2-tier)
# PS1="[\[\033[32m\]\w]\[\033[0m\]\n\[\033[1;36m\]\u\[\033[1;33m\]-&gt; \[\033[0m\]"		# black, green, cyan, yellow, w/black output w/full path (2-tier)
# PS1="\[\033[34m\]   \u@\h `tty | sed 's/\/dev\///'` \t \d \[\033[35m\]\w/ \n\[\033[34m\] $\[\033[0m\] "	# cyan with green output
# PS1="\[\033[35m\]\t\[\033[m\]-\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ "	# purple, cyan, black, green, yellow, default black
# PS1="\[\033[35m\]\t\[\033[m\]-\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ "	# purple, cyan, black, green, yellow, w/black output
# PS1="\[\033[36m\]   \u@\h `tty | sed 's/\/dev\///'` \t \d \[\033[32m\]\w/ \n\[\033[36m\] $\[\033[0m\] "	# blue with purple output
# PS1="&gt;\[\033[s\]\[\033[1;\$((COLUMNS-4))f\]\$(date +%H:%M)\[\033[u\]"				# trimmed up prompt with clock using default colors (black)
# PS1='C:${PWD//\//\\\}&gt;'									# change prompt to MS-DOS one (joke)
# PS1='${debian_chroot:+($debian_chroot)}\[[ \033[01;31m\]\w\[\033[00m\]] '			# basic red with default black output
# PS1='\[\e[0;31m\]\u\[\e[m\] \[\e[1;34m\]\w\[\e[m\] \[\e[0;31m\]\$ \[\e[m\]\[\e[0;32m\]'	# red and blue prompt with green output
# PS1='\[\e[0;32m\]\u\[\e[m\] \[\e[1;34m\]\w\[\e[m\] \[\e[1;32m\]\$\[\e[m\] \[\e[1;37m\]'	# green and blue prompt with light grey output
# PS1='\[\e[0;32m\]\u\[\e[m\] \[\e[1;34m\]\w\[\e[m\] \[\e[1;32m\]\$\[\e[m\]'			# green and blue prompt with default black output
# PS1='\e[1;31;47m\u \e[1;32;47mon \h \e[1;35;47m\d \@\e[0;0m\n\e[1;31m[dir.= \w] \# &gt; \e[0;0m'	# red, green, purple, red with default black output
# PS1='\[\e[1;31m\][\[\e[0;37m\]\u\[\e[1;31m\]@\[\e[0;37m\]\h \W\[\e[1;31m\]]\$\[\e[0m\] '	# red and grey with default black output
# PS1='\[\e[1;31m\][\u@\h \W]\$\[\e[0m\] '							# red color with default black output
# PS1='\[\e[1;32m\]\u@\H:\[\e[m\] \[\e[1;37m\]\w\[\e[m\]\n\[\e[1;33m\]hist:\! \[\e[0;33m\] \[\e[1;31m\]jobs:\j \$\[\e[m\] '	# green, yellow, red, grey and default black output (2-tier)
# PS1='\[\e[1;32m\]\u@\H:\[\e[m\] \[\e[1;37m\]\w\[\e[m\]\n\[\e[1;33m\]hist:\! \[\e[0;33m\] \[\e[1;31m\]jobs:\j \$\[\e[m\] '	# green, yellow, red, w/black output (2-tier) w/background job count
# PS1='\[\e[1;32m\][\u@\h \W]\$\[\e[0m\] '							# green color with default black output
# PS1='\e[1;33;47m\u \e[1;32;47mon \h \e[1;35;47m\d \@\e[0;0m\n\e[1;34m[dir.= \w] \# &gt; \e[0;0m'	# yellow, green, purple, cyan with default black output
# PS1="\[\e[1;33m\] &gt; \[\033[0m\]"								# basic yellow with default black output &amp; nothing else
# PS1='\[\e[1m\]\h:\w\$\[\e[0m\] '								# black-bold with default colors (black)
# PS1="\[\e]2;\u@\H \w\a\e[30;1m\]&gt;\[\e[0m\] "							# trimmed up prompt w/black arrow &amp; title is current dir.
# PS1="\[\e[30;1m\]\w&gt; \[\e[0m\]"								# trimmed up prompt with just black arrow and default colors
# PS1="\[\e[36;1m\]\u@\[\e[32;1m\]\H&gt; \[\e[0m\]"						# cyan and green prompt with default black output
# PS1="\[\e[37;1m\]-{\[\e[34;1m\]\u@\h\[\e[37;1m\]}-\n\[\e[37;1m\](\[\e[34;1m\]\w: \$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') files, \$(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')b\[\e[37;1m\])\n--&gt; \[\e[0m\]"		# grey and cyan w/black output (2-tier) w/dir size
# PS1='\[\e[41m\]\[\e[1;37m\] \u \[\e[47m\]\[\e[1;30m\] \W \[\e[0m\]\[\e[1;37m\]\[\e[42m\] # \[\033[0m\] '	# red, grey, green boxed with default black
# PS1='\[\e[45m\]\[\e[1;37m\] \u@\h \[\e[47m\]\[\e[1;30m\] \W \[\e[0m\]\[\e[1;37m\]\[\e[42m\] &gt; \[\033[0m\] '	# purple, grey, green boxed with default black
# PS1='\[\e[m\n\e[0;33m\][$$:$PPID \j:\!\[\e[0;33m\]]\[\e[0;36m\] \T \d \[\e[1;34m\][\[\e[1;34m\]\u@\H\[\e[1;31m\]:\[\e[0;37m\]${SSH_TTY} \[\e[0;32m\]+${SHLVL}\[\e[1;30m\]] \[\e[1;31m\]\w\[\e[0;30m\] \n($SHLVL:\!)\$ '				# yellow, cyan, red, blue, white, green, black, red w/ default black output
# PS1="\`if [ \$? = 0 ]; then echo \[\e[33m\]^_^\[\e[0m\]; else echo \[\e[31m\]O_O\[\e[0m\]; fi\`[\u@\h:\w]\\$ "	# all black with happy face (yellow/red) upon successful completion
# PS1="\`if [ \$? = 0 ]; then echo \[\e[33m\]^_^\[\e[0m\]; else echo \[\e[31m\]O_O\[\e[0m\]; fi\`[\u@\h:\w]\\$ "	# basic prompt but with yellow smiley
# PS1="\n\[\033[32;1m\]It's \t\[\033[33;1m\] Currently browsing \[\033[1;36m\]\w \[\033[33;1m\]directory\n\[\033[34;1m\]\`if [ \$? = 0 ]; then echo \[\e[37m\]Last Command Was Successfully Executed \[\e[32m\]^_^\[\e[0m\]; else echo \[\e[37m\]Smeggin Hell !!! Last Command Was Unknown \[\e[32m\]O_O\[\e[0m\]; fi\` \n\[\033[31m\]What is thy bidding, my master? \n\n\[\033[34;1m\]"				# green, yellow, grey, green, red, w/cyan output (3-tier) Star Wars version
# PS1="\n\[\033[35m\]\$(/bin/date)\n\[\033[32m\]\w\n\[\033[1;31m\]\u@\h: \[\033[1;34m\]\$(/usr/bin/tty | /bin/sed -e 's:/dev/::'): \[\033[1;36m\]\$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') files \[\033[1;33m\]\$(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')b\[\033[0m\] -&gt; \[\033[0m\]"	- purple, green, blue, cyan, yellow, with default black output (3-tier)
# PS1="\n\[\033[35m\]\$(/bin/date)\n\[\033[32m\]\w\n\[\033[1;31m\]\u@\h: \[\033[1;34m\]\$(/usr/bin/tty | /bin/sed -e 's:/dev/::'): \[\033[1;36m\]\$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') files \[\033[1;33m\]\$(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')b\[\033[0m\] -&gt; \[\033[0m\]"												# purple, red, blue, cyan, yellow, w/white output (3-tier)
# PS1="\n\[$bldgrn\][\[$txtrst\]\w\[$bldgrn\]]\[$bldwht\]\n\[$bldwht\][\[$txtrst\]\t\[$bldwht\]]\[$bldylw\]$ \[$txtrst\]"	# green, black, grey, yellow with default black output (3-tier)
# PS1="\n#--[\[\e[1;36m\]\u@\h\[\e[m\]]-[\[\e[1;34m\]\w\[\e[m\]]-[\$(date +%k:%M)]--&gt;\n"	# black, cyan, blue, black, w/black output (2-tier)
# PS1="\n\[\e[30;1m\]\[\016\]l\[\017\](\[\e[34;1m\]\u@\h\[\e[30;1m\])-(\[\e[34;1m\]\j\[\e[30;1m\])-(\[\e[34;1m\]\@ \d\[\e[30;1m\])-&gt;\[\e[30;1m\]\n\[\016\]m\[\017\]-(\[\[\e[32;1m\]\w\[\e[30;1m\])-(\[\e[32;1m\]\$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') files, \$(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')b\[\e[30;1m\])--&gt; \[\e[0m\]"				# grey, cyan, green, w/black output (2-tier) w/ dir. info
# PS1="\n\[\e[30;1m\]?(\[\e[34;1m\]\u@\h\[\e[30;1m\])-(\[\e[34;1m\]\j\[\e[30;1m\])-(\[\e[34;1m\]\@ \d\[\e[30;1m\])-&gt;\[\e[30;1m\]\n??(\[\e[32;1m\]\w\[\e[30;1m\])-(\[\e[32;1m\]$(/bin/ls -1 | /usr/bin/wc -l | /bin/sed 's: ::g') files, $(/bin/ls -lah | /bin/grep -m 1 total | /bin/sed 's/total //')b\[\e[30;1m\])--&gt; \[\e[0m\]"	# black, cyan, green w/black output (2-tier)
# PS1="\n\[\e[32;1m\](\[\e[37;1m\]\u\[\e[32;1m\])-(\[\e[37;1m\]jobs:\j\[\e[32;1m\])-(\[\e[37;1m\]\w\[\e[32;1m\])\n(\[\[\e[37;1m\]! \!\[\e[32;1m\])-&gt; \[\e[0m\]"	# grey and green with default black output (3-tier)
# PS1="\n\[\e[m\][\[\033[01;32m\]\w\[\e[m\]] [\t] \n\[\033[01;33m\]$ \[\033[00m\]"		# green, black, yellow, with default black output (3-tier)
# PS1="\t \u@\h\$ "										# simple prompt with time (black)
# PS1="\t \u@\h `tty | sed 's/\/dev\///'` \w \$ "						# longer prompt with time (black)
# PS1="\u@\h\$ "										# simple default prompt (black)
# PS1="\u@\h `tty | sed 's/\/dev\///'` \w \$ "							# longer prompt with brief info (black)
# PS1='[\u@\h \W]\$ '										# default colors (black)
# PS1="\u@\h [\w] \$ "										# simple prompt with directory (black)
# PS1="\u `tty | sed 's/\/dev\///'` [\W] \$ "							# prompt with brief info (black)



##################################################
# Jsnx's prompt of power (disabled by a single 	 #
# "#")			 			 #
##################################################

## I used to have the prompt set up as a bunch of functions; but that
## didn't work very well with sh. Now, I have mastered the various
## levels of evaluation and quoting of the shell and can confidently
## write hideous macros!
# DARK="\[\e[01;34m\]"
# NORM="\[\e[01;32m\]"
# FADE="\[\e[01;30m\]"
# REST="\[\e[00;00m\]"
# HIGH="\[\e[01;33m\]"
# dir="pwd -P | awk '{ printf \"%-65.65s\", \$1 }'"
# sub="sed -r 's/^/$NORM/ ; s|/|$FADE&amp;$NORM|g ; s/:/$DARK&amp;$NORM/g'"
# t="date +%H:%M"
# hist="history 1 | xargs echo '' | awk '{ printf \"%03.3d\", \$1 + 1 }'"
# warn="[ $USER = root ] &amp;&amp; echo -n '$HIGH' || echo -n '$FADE'"
# bang="echo -ne '\x21'"  ## this gives me a single '!' in bash and sh
# prompt=" $DARK: \`$dir | $sub\` \`$warn;$bang;\`$NORM\`$hist\` \`$t | $sub\`
# $DARK:\`$warn\`; $REST"
# prepend=''
# if [ "${TERM}" = "xterm" ]
# then
#  my_tty=`tty | awk -F/ '{ print $3 $4}'`
#  xterm_title="\[\e]0;${my_tty} \u@\H\007\]"
#  prepend="${xterm_title}"
# fi
## export  PROMPT_COMMAND="export PS1=\"${prepend}${prompt}\""
# export  PS1="${prepend}${prompt}"
# export  PS2='  '



##################################################
# Nate Mitchell's (Kasyx's) Bash Prompt (red with#
# green dashes and black output) (disabled by a	 #
# single "#")		 			 #
##################################################

# function prompt() {
# Black="\e[30m"
# Red="\e[31m"
# Green="\e[32m"
# LightGreen="\e[32;1m"
# Blue="\e[34m"
# LightBlue="\e[34;1m"
# NC="\e[0m" # No Color
# PS1="\[$LightGreen\033(0\154\033(B\][\[\033(0\161\161\033(B$Green\][\[$Red\]\u@\h\[$Green\]]\[\033(0\161\033(B\][\[$Red\]\w\[$Green\]]\[\033(0\161\033(B\][\[$Red\]\!\[$Green\]]\[\033(0\161\161\033(B\]]\n\[$LightGreen\033(0\155\161\033(B$Green\][\[$Red\]\#\[$Green\]]\[\033(0\161\033(B\][\[$Red\]\$\[$Green\]]\[\033(0\161\161\033(B\][\[$NC\]"
# PS2="&gt; "
# }
# prompt



##################################################
# Wolfman's prompt (disabled by a single "#")	 #
##################################################

## Fancy PWD display function
## The home directory (HOME) is replaced with a ~
## The last pwdmaxlen characters of the PWD are displayed
## Leading partial directory names are striped off
## /home/me/stuff          -&gt; ~/stuff               if USER=me
## /usr/share/big_dir_name -&gt; ../share/big_dir_name if pwdmaxlen=20
# function bash_prompt_command() {
#    # How many characters of the $PWD should be kept
#    local pwdmaxlen=25
#    # Indicate that there has been dir truncation
#    local trunc_symbol=".."
#    local dir=${PWD##*/}
#    pwdmaxlen=$(( ( pwdmaxlen &lt; ${#dir} ) ? ${#dir} : pwdmaxlen ))
#    NEW_PWD=${PWD/#$HOME/\~}
#    local pwdoffset=$(( ${#NEW_PWD} - pwdmaxlen ))
#    if [ ${pwdoffset} -gt "0" ]
#    then
#        NEW_PWD=${NEW_PWD:$pwdoffset:$pwdmaxlen}
#        NEW_PWD=${trunc_symbol}/${NEW_PWD#*/}
#    fi
# }
# function bash_prompt() {
#    case $TERM in
#     xterm*|rxvt*)
#         local TITLEBAR='\[\033]0;\u:${NEW_PWD}\007\]'
#          ;;
#     *)
#         local TITLEBAR=""
#          ;;
#    esac
#    local NONE="\[\033[0m\]"    # unsets color to term's fg color
#    # regular colors
#    local K="\[\033[0;30m\]"    # black
#    local R="\[\033[0;31m\]"    # red
#    local G="\[\033[0;32m\]"    # green
#    local Y="\[\033[0;33m\]"    # yellow
#    local B="\[\033[0;34m\]"    # blue
#    local M="\[\033[0;35m\]"    # magenta
#    local C="\[\033[0;36m\]"    # cyan
#    local W="\[\033[0;37m\]"    # white
#    # emphasized (bolded) colors
#    local EMK="\[\033[1;30m\]"
#    local EMR="\[\033[1;31m\]"
#    local EMG="\[\033[1;32m\]"
#    local EMY="\[\033[1;33m\]"
#    local EMB="\[\033[1;34m\]"
#    local EMM="\[\033[1;35m\]"
#    local EMC="\[\033[1;36m\]"
#    local EMW="\[\033[1;37m\]"
#    # background colors
#    local BGK="\[\033[40m\]"
#    local BGR="\[\033[41m\]"
#    local BGG="\[\033[42m\]"
#    local BGY="\[\033[43m\]"
#    local BGB="\[\033[44m\]"
#    local BGM="\[\033[45m\]"
#    local BGC="\[\033[46m\]"
#    local BGW="\[\033[47m\]"
#    local UC=$W                 # user's color
#    [ $UID -eq "0" ] &amp;&amp; UC=$R   # root's color
##    PS1="$TITLEBAR ${EMK}[${UC}\u${EMK}@${UC}\h ${EMB}\${NEW_PWD}${EMK}]${UC}\\$ ${NONE}"
#    # without colors: PS1="[\u@\h \${NEW_PWD}]\\$ "
#    # extra backslash in front of \$ to make bash colorize the prompt
# }
# PROMPT_COMMAND=bash_prompt_command
# bash_prompt
# unset bash_prompt



##################################################
# Emmanuel Rouat's shell prompt (fancy all	 #
# black with info)				 #
##################################################

# if [[ "${DISPLAY%%:0*}" != "" ]]; then
#    HILIT=${red}   # remote machine: prompt will be partly red
# else
#    HILIT=${cyan}  # local machine: prompt will be partly cyan
# fi
##   --&gt; Replace instances of \W with \w in prompt functions below
## + --&gt; to get display of full path name.
# function fastprompt()
# {
#    unset PROMPT_COMMAND
#    case $TERM in
#        *term | rxvt )
#            PS1="${HILIT}[\h]$NC \W &gt; \[\033]0;\${TERM} [\u@\h] \w\007\]" ;;
#        linux )
#            PS1="${HILIT}[\h]$NC \W &gt; " ;;
#        *)
#            PS1="[\h] \W &gt; " ;;
#    esac
# }
# function _powerprompt()
# {
#    LOAD=$(uptime|sed -e "s/.*: \([^,]*\).*/\1/" -e "s/ //g")
# }
#
# function powerprompt()
# {
#    PROMPT_COMMAND=_powerprompt
#    case $TERM in
#        *term | rxvt  )
#            PS1="${HILIT}[\A - \$LOAD]$NC\n[\u@\h \#] \W &gt; \
#                 \[\033]0;\${TERM} [\u@\h] \w\007\]" ;;
#        linux )
#            PS1="${HILIT}[\A - \$LOAD]$NC\n[\u@\h \#] \W &gt; " ;;
#        * )
#            PS1="[\A - \$LOAD]\n[\u@\h \#] \W &gt; " ;;
#    esac
# }
# powerprompt     # This is the default prompt -- might be slow.
#                # If too slow, use fastprompt instead. ...



##################################################
# Xterm windowdressing (cyan and black with	 #
# grey output info prompt( (disabled by a	 #
# single '#')					 #
##################################################

# function elite()
#  {
#  local GRAY="\[\033[1;30m\]"
#  local LIGHT_GRAY="\[\033[0;37m\]"
#  local CYAN="\[\033[0;36m\]"
#  local LIGHT_CYAN="\[\033[1;36m\]"
#  case $TERM in
#      xterm*)
#          local TITLEBAR='\[\033]0;\u@\h:\w\007\]'
#          ;;
#      *)
#          local TITLEBAR=""
#          ;;
#  esac
#  local GRAD1=$(tty|cut -d/ -f3)
#  PS1="$TITLEBAR\
#  $GRAY-$CYAN-$LIGHT_CYAN(\
#  $CYAN\u$GRAY@$CYAN\h\
#  $LIGHT_CYAN)$CYAN-$LIGHT_CYAN(\
#  $CYAN\#$GRAY/$CYAN$GRAD1\
#  $LIGHT_CYAN)$CYAN-$LIGHT_CYAN(\
#  $CYAN\$(date +%H%M)$GRAY/$CYAN\$(date +%d-%b-%y)\
#  $LIGHT_CYAN)$CYAN-$GRAY-\
#  $LIGHT_GRAY\n\
#  $GRAY-$CYAN-$LIGHT_CYAN(\
#  $CYAN\$$GRAY:$CYAN\w\
#  $LIGHT_CYAN)$CYAN-$GRAY-$LIGHT_GRAY "
#  PS2="$LIGHT_CYAN-$CYAN-$GRAY-$LIGHT_GRAY "
#  }
# PROMPT_COMMAND=elite



##################################################
# Another prompt =				 #
# (PS1="\[\e]2;\u@\H \w\a\e[30;1m\]&gt;\[\e[0m\]	 #
# " but fixed for various systems - simple	 #
# prompt that shows currently directory in	 #
# title)					 #
##################################################

# if [ "$TERM" = "linux" ]
# then
#	# we're on the system console or maybe telnetting in
#	export PS1="\[\e[32;1m\]\u@\H &gt; \[\e[0m\]"
# else
#	# we're not on the console, assume an xterm
#	export PS1="\[\e]2;\u@\H \w\a\e[32;1m\]&gt;\[\e[0m\] "
# fi



##################################################
# Yet another prompt (simple black prompt with	 #
# the word 'bash$' only)			 #
##################################################

## Check if running in an xterm and give a more suitable prompt
## (two alternative blocks given below)
## mesg y allows talk(1) requests, here only if not an xterm
## Gives informative prompt, puts user,host,path in xterm title
## Comment or uncomment all of the following lines ('case' to 'esac')
# case $TERM in
#     xterm*)
#        PS1="\[\033]0;\u@\h: \w\007\]bash\$ "
#       ;;
#  *)
#      PS1="\t \u@\h `tty | sed 's/\/dev\///'`\$ "
#       mesg y
#        ;;
# esac



##################################################
# Still another prompt (cyan and red with	 #
# green output info prompt) (disabled by a	 #
# single '#')					 #
##################################################

### Colourful prompts
### Comment or uncomment all of the following lines ('case' to 'esac')
## case $TERM in
##      xterm*)
##          TERM=xterm-color; export TERM
##          PS1="\[\033[36m\]   \u@my_computer `tty | sed 's/\/dev\///'` \t \d \[\033[35m\]\w/ \n\[\033[36m\] $\[\033[0m\] "
##          ;;
##      *)
#          PS1="`setterm -bold on` \[\033[36m\] \u@my_computer `tty | sed 's/\/dev\///'` \t \d \[\033[1;31m\]\w/ \n\[\033[36m\]! \[\033[1;32m\] `setterm -#bold off`"
#    # this adds a bg color; comment out the above
##      PS1="\[\033[35m\]   \u@my_computer `tty | sed 's/\/dev\///'` \t \d \[\033[32m\]\w/ \n\[\033[36m\] $\[\033[44;1;36m\] `setterm -bold on` "
##          mesg y
##          ;;
## esac



##################################################
# More PROMPT_COMMANDS				 #
##################################################

###### Annoying PROMPT_COMMAND animation
# PROMPT_COMMAND='seq $COLUMNS | xargs -IX printf "%Xs\r" @'



###### Share history between using multiple commands (press enter before get history from other bash shells)
# PROMPT_COMMAND='history -a &amp;&amp; history -n'



###### Shows date
# PROMPT_COMMAND='date +%k:%m:%S'



###### Shows memory, load average, and history
# PROMPT_COMMAND='history -a;echo -en "\033[m\033[38;5;2m"$(( `sed -nu "s/MemFree:[\t ]\+\([0-9]\+\) kB/\1/p" /proc/meminfo`/1024))"\033[38;5;22m/"$((`sed -nu "s/MemTotal:[\t ]\+\([0-9]\+\) kB/\1/Ip" /proc/meminfo`/1024 ))MB"\t\033[m\033[38;5;55m$(&lt; /proc/loadavg)\033[m"'



###### Shows the return value of the last executed command (using smileys as to whether it was successful or not)
# PROMPT_COMMAND='RET=$?; if [[ $RET -eq 0 ]]; then echo -ne "\033[0;32m$RET\033[0m ;)"; else echo -ne "\033[0;31m$RET\033[0m ;("; fi; echo -n " "'
</t>
<t tx="sa.20110119013021.1292">##################################################
# Temporarily add to PATH			 #
##################################################

function apath()
{
    if [ $# -lt 1 ] || [ $# -gt 2 ]; then
        echo "Temporarily add to PATH"
        echo "usage: apath [dir]"
    else
        PATH=$1:$PATH
    fi
}
</t>
<t tx="sa.20110119013021.1293">##################################################
# Common commands piped through grep		 #
##################################################

function aptg()		# debian specific.
{
    if [ $# -lt 1 ] || [ $# -gt 1 ]; then
        echo "search debian package list"
        echo "usage: aptg [program/keyword]"
    else
        apt-cache search $1 | sort | less
    fi
}



###### grep by paragraph instead of by line
function grepp() { [ $# -eq 1 ] &amp;&amp; perl -00ne "print if /$1/i" || perl -00ne "print if /$1/i" &lt; "$2";}



function hgg()
{
    if [ $# -lt 1 ] || [ $# -gt 1 ]; then
        echo "search bash history"
        echo "usage: mg [search pattern]"
    else
        history | grep -i $1 | grep -v hg
    fi
}



function lsofg()
{
    if [ $# -lt 1 ] || [ $# -gt 1 ]; then
        echo "grep lsof"
        echo "usage: losfg [port/program/whatever]"
    else
        lsof | grep -i $1 | less
    fi
}



function psg()
{
    if [ $# -lt 1 ] || [ $# -gt 1 ]; then
        echo "grep running processes"
        echo "usage: psg [process]"
    else
        ps aux | grep USER | grep -v grep
        ps aux | grep -i $1 | grep -v grep
    fi
}
</t>
<t tx="sa.20110119013021.1295">##################################################
# To show Apt Log History			 #
##################################################

function apt-history() {
      case "$1" in
        install)
              cat /var/log/dpkg.log | grep 'install '
              ;;
        upgrade|remove)
              cat /var/log/dpkg.log | grep $1
              ;;
        rollback)
              cat /var/log/dpkg.log | grep upgrade | \
                  grep "$2" -A10000000 | \
                  grep "$3" -B10000000 | \
                  awk '{print $4"="$5}'
              ;;
        *)
              cat /var/log/dpkg.log
              ;;
      esac
}</t>
<t tx="sa.20110119013021.1296">##################################################
# Arch-wiki-docs simple search			 #
##################################################

function archwikisearch() {
	# old version
	# cd /usr/share/doc/arch-wiki/html/
	# grep -i "$1" index.html | sed 's/.*HREF=.\(.*\.html\).*/\1/g' | xargs opera -newpage
	cd /usr/share/doc/arch-wiki/html/
	for i in $(grep -li $1 *)
	do
		STRING=`grep -m1 -o 'wgTitle = "[[:print:]]\+"' $i`
		LEN=${#STRING}
		let LEN=LEN-12
		STRING=${STRING:11:LEN}
		LOCATION="/usr/share/doc/arch-wiki/html/$i"
		echo -e " \E[33m$STRING   \E[37m$LOCATION"
	done
}</t>
<t tx="sa.20110119013021.1297">##################################################
# Ask						 #
##################################################

function ask()
{
    echo -n "$@" '[y/n] ' ; read ans
    case "$ans" in
        y*|Y*) return 0 ;;
        *) return 1 ;;
    esac
}
</t>
<t tx="sa.20110119013021.1298">###### watch the National debt clock
function natdebt()
{
watch -n 10 "wget -q http://www.brillig.com/debt_clock -O - | grep debtiv.gif | sed -e 's/.*ALT=\"//' -e 's/\".*//' -e 's/ //g'"
}




</t>
<t tx="sa.20110119013021.1299">function oneliners()
{
w3m -dump_source http://www.onelinerz.net/random-one-liners/1/ | awk ' /.*&lt;div id=\"oneliner_[0-9].*/ {while (! /\/div/ ) { gsub("\n", ""); getline; }; gsub (/&lt;[^&gt;][^&gt;]*&gt;/, "", $0); print $0}'
}</t>
<t tx="sa.20110119013021.1300">##################################################
# Escape potential tarbombs			 #
##################################################

function atb() { l=$(tar tf $1); if [ $(echo "$l" | wc -l) -eq $(echo "$l" | grep $(echo "$l" | head -n1) | wc -l) ]; then tar xf $1; else mkdir ${1%.tar.gz} &amp;&amp; tar xf $1 -C ${1%.tar.gz}; fi ; }
</t>
<t tx="sa.20110119013021.1301">##################################################
# Creates a backup of the file passed as	 #
# parameter with the date and time		 #
##################################################

function bak()
{
  cp $1 $1_`date +%H:%M:%S_%d-%m-%Y`
}</t>
<t tx="sa.20110119013021.1302">##################################################
# Execute a given Linux command on a group of	 #
# files						 #
##################################################

###### Example: batchexec sh ls		# lists all files that have the extension 'sh'
# Example: batchexec sh chmod 755	# 'chmod 755' all files that have the extension 'sh'
function batchexec()
{
find . -type f -iname '*.'${1}'' -exec ${@:2}  {} \; ;
}</t>
<t tx="sa.20110119013021.1303">##################################################
# Substitutes underscores for blanks in all the  #
# filenames in a directory			 #
##################################################

function blank_rename()
{
ONE=1                     # For getting singular/plural right (see below).
number=0                  # Keeps track of how many files actually renamed.
FOUND=0                   # Successful return value.
for filename in *         #Traverse all files in directory.
do
     echo "$filename" | grep -q " "         #  Check whether filename
     if [ $? -eq $FOUND ]                   #+ contains space(s).
     then
       fname=$filename                      # Yes, this filename needs work.
       n=`echo $fname | sed -e "s/ /_/g"`   # Substitute underscore for blank.
       mv "$fname" "$n"                     # Do the actual renaming.
       let "number += 1"
     fi
done
if [ "$number" -eq "$ONE" ]                 # For correct grammar.
then
 echo "$number file renamed."
else
 echo "$number files renamed."
fi
}</t>
<t tx="sa.20110119013021.1304">##################################################
# Create box of '#' characters around given 	 #
# string					 #
##################################################

function box() { t="$1xxxx";c=${2:-#}; echo ${t//?/$c}; echo "$c $1 $c"; echo ${t//?/$c}; }

</t>
<t tx="sa.20110119013021.1305">##################################################
# Change directory and list files		 #
##################################################

function cds() {
    # only change directory if a directory is specified
    [ -n "${1}" ] &amp;&amp; cd $1
    lls
}
</t>
<t tx="sa.20110119013021.1306"></t>
<t tx="sa.20110119013021.1307">##################################################
# Network information and IP address stuff	 #
##################################################

###### clear iptables rules safely
function clearIptables()
{
iptables -P INPUT ACCEPT; iptables -P FORWARD ACCEPT; iptables -P OUTPUT ACCEPT; iptables -F; iptables -X; iptables -L
}



###### find an unused unprivileged TCP port
function findtcp()
{
(netstat  -atn | awk '{printf "%s\n%s\n", $4, $4}' | grep -oE '[0-9]*$'; seq 32768 61000) | sort -n | uniq -u | head -n 1
}



###### geoip lookup (need geoip database: sudo apt-get install geoip-bin)
function geoip() {
geoiplookup $1
}



###### geoip information
# requires 'html2text': sudo apt-get install html2text
function geoiplookup() { curl -A "Mozilla/5.0" -s "http://www.geody.com/geoip.php?ip=$1" | grep "^IP.*$1" | html2text; }



###### get IP address of a given interface
# Example: getip lo
# Example: getip eth0	# this is the default
function getip()		{ lynx -dump http://whatismyip.org/; }



###### display private IP
function ippriv()
{
    ifconfig eth0|grep "inet adr"|awk '{print $2}'|awk -F ':' '{print $2}'
}



###### ifconfig connection check
function ips()
{
    if [ "$OS" = "Linux" ]; then
        for i in $( /sbin/ifconfig | grep ^e | awk '{print $1}' | sed 's/://' ); do echo -n "$i: ";  /sbin/ifconfig $i | perl -nle'/dr:(\S+)/ &amp;&amp; print $1'; done
    elif [ "$OS" = "Darwin" ]; then
        for i in $( /sbin/ifconfig | grep ^e | awk '{print $1}' | sed 's/://' ); do echo -n "$i: ";  /sbin/ifconfig $i | perl -nle'/inet (\S+)/ &amp;&amp; print $1'; done
    fi
}



###### geolocate a given IP address
function ip2loc() { wget -qO - www.ip2location.com/$1 | grep "&lt;span id=\"dgLookup__ctl2_lblICountry\"&gt;" | sed 's/&lt;[^&gt;]*&gt;//g; s/^[\t]*//; s/&amp;quot;/"/g; s/&lt;/&lt;/g; s/&gt;/&gt;/g; s/&amp;amp;/\&amp;/g'; }



###### myip - finds your current IP if your connected to the internet
function myip()
{
lynx -dump -hiddenlinks=ignore -nolist http://checkip.dyndns.org:8245/ | awk '{ print $4 }' | sed '/^$/d; s/^[ ]*//g; s/[ ]*$//g'
}



###### netinfo - shows network information for your system
function netinfo()
{
echo "--------------- Network Information ---------------"
/sbin/ifconfig | awk /'inet addr/ {print $2}'
/sbin/ifconfig | awk /'Bcast/ {print $3}'
/sbin/ifconfig | awk /'inet addr/ {print $4}'
/sbin/ifconfig | awk /'HWaddr/ {print $4,$5}'
myip=`lynx -dump -hiddenlinks=ignore -nolist http://checkip.dyndns.org:8245/ | sed '/^$/d; s/^[ ]*//g; s/[ ]*$//g' `
echo "${myip}"
echo "---------------------------------------------------"
}



###### show ip
# copyright 2007 - 2010 Christopher Bratusek
function show_ip()
{
	case $1 in
		*help | "" )
			echo -e "\n${ewhite}Usage:\n"
			echo -e "${eorange}show_ip${ewhite} |${egreen} &lt;interface&gt; ${eiceblue}[show ip-address for &lt;interface&gt;]\
			\n${eorange}show_ip${ewhite} |${egreen} external${eiceblue} [show external ip address]\n"
			tput sgr0
		;;
		*external )
			wget -q -O - http://showip.spamt.net/
		;;
		* )
			LANG=C /sbin/ifconfig $1 | grep 'inet addr:' | cut -d: -f2 | gawk '{ print $1}'
		;;
	esac
}



###### display the ttl of a hostname in a human readable form
function ttl()
{
/usr/sbin/timetrans -count $(dig +noquestion +noadditional +noauthority $1 | grep "^$1" | awk '{print $2}')
}



###### show Url information
# Usage:	url-info "ur"
# This script is part of nixCraft shell script collection (NSSC)
# Visit http://bash.cyberciti.biz/ for more information.
# Modified by Silviu Silaghi (http://docs.opensourcesolutions.ro) to handle
# more ip adresses on the domains on which this is available (eg google.com or yahoo.com)
# Last updated on Sep/06/2010
function url-info()
{
doms=$@
if [ $# -eq 0 ]; then
echo -e "No domain given\nTry $0 domain.com domain2.org anyotherdomain.net"
fi
for i in $doms; do
_ip=$(host $i|grep 'has address'|awk {'print $4'})
if [ "$_ip" == "" ]; then
echo -e "\nERROR: $i DNS error or not a valid domain\n"
continue
fi
ip=`echo ${_ip[*]}|tr " " "|"`
echo -e "\nInformation for domain: $i [ $ip ]\nQuerying individual IPs"
 for j in ${_ip[*]}; do
echo -e "\n$j results:"
whois $j |egrep -w 'OrgName:|City:|Country:|OriginAS:|NetRange:'
done
done
}
</t>
<t tx="sa.20110119013021.1308">###### takes a name of a color and some text and then echoes out the text in the named color
# Usage:	colorize_text "color" "whatever text"
function colorize-text()
{
b='[0;30m'
# Implement command-line options
while getopts "nr" opt
 do
  case $opt in
   n  )  o='-n' ;;
   r  )  b=''   ;;
  esac
 done
shift $(($OPTIND - 1))
# Set variables
col=$1
shift
text="$*"
# Set a to console color code
case $col in
 'black'  ) a='[0;30m' ;;
 'blue'   ) a='[0;34m' ;;
 'green'  ) a='[0;32m' ;;
 'cyan'   ) a='[0;36m' ;;
 'red'    ) a='[0;31m' ;;
 'purple' ) a='[0;35m' ;;
 'brown'  ) a='[0;33m' ;;
 'ltgray' ) a='[0;37m' ;;
 'white'  ) a='[1;30m' ;;
 'ltblue' ) a='[1;34m' ;;
 'ltgreen') a='[1;32m' ;;
 'ltcyan' ) a='[1;36m' ;;
 'ltred'  ) a='[1;31m' ;;
 'pink'   ) a='[1;35m' ;;
 'yellow' ) a='[1;33m' ;;
 'gray'   ) a='[1;37m' ;;
esac
# Display text in designated color, no newline
echo -en "\033$a$text"
# If 'b' switch not on, restore color to black
if [ -n $b ]
 then
  echo -en "\033$b"
fi
# If 'n' switch on, do not display final newline
# otherwise output newline
echo $o
}



###### shows the colors in a kewl way...partially stolen from HH
function colors()
{
       # Display ANSI colours.
    esc="\033["
    echo -e "\t  40\t   41\t   42\t    43\t      44       45\t46\t 47"
    for fore in 30 31 32 33 34 35 36 37; do
        line1="$fore  "
        line2="    "
        for back in 40 41 42 43 44 45 46 47; do
            line1="${line1}${esc}${back};${fore}m Normal  ${esc}0m"
            line2="${line2}${esc}${back};${fore};1m Bold    ${esc}0m"
        done
        echo -e "$line1\n$line2"
    done
    echo ""
    echo "# Example:"
    echo "#"
    echo "# Type a Blinkin TJEENARE in Swedens colours (Yellow on Blue)"
    echo "#"
    echo "#           ESC"
    echo "#            |  CD"
    echo "#            |  | CD2"
    echo "#            |  | | FG"
    echo "#            |  | | |  BG + m"
    echo "#            |  | | |  |         END-CD"
    echo "#            |  | | |  |            |"
    echo "# echo -e '\033[1;5;33;44mTJEENARE\033[0m'"
    echo "#"
    echo "# Sedika Signing off for now ;-&gt;"
}



###### displays all 256 possible background colors, using ANSI escape sequences.
# author: Chetankumar Phulpagare
# used in ABS Guide with permission.
function colors2()
{
T1=8
T2=6
T3=36
offset=0
for num1 in {0..7}
do {
   for num2 in {0,1}
       do {
          shownum=`echo "$offset + $T1 * ${num2} + $num1" | bc`
          echo -en "\E[0;48;5;${shownum}m color ${shownum} \E[0m"
          }
       done
   echo
   }
done
offset=16
for num1 in {0..5}
do {
   for num2 in {0..5}
       do {
          for num3 in {0..5}
              do {
                 shownum=`echo "$offset + $T2 * ${num3} \
                 + $num2 + $T3 * ${num1}" | bc`
                 echo -en "\E[0;48;5;${shownum}m color ${shownum} \E[0m"
                 }
               done
          echo
          }
       done
}
done
offset=232
for num1 in {0..23}
do {
   shownum=`expr $offset + $num1`
   echo -en "\E[0;48;5;${shownum}m ${shownum}\E[0m"
}
done
echo
}



###### print all 256 colors for testing TERM or for a quick reference
# show numerical values for each of the 256 colors in bash
function colors2nums()
{
for code in {0..255}; do echo -e "\e[38;05;${code}m $code: Test"; done
}

</t>
<t tx="sa.20110119013021.1309">##################################################
# Lookup a word with dict.org			 #
##################################################

###### define "whatever"
function dic() { curl dict://dict.org/d:"$@" ; }



###### find matches of $1, with optional strat $2 and optional db $3
function ref()
{
    if [[ -z $3 ]]; then
        curl dict://dict.org/m:${1}:english:${2};
    else
        curl dict://dict.org/m:${1}:${3}:${2};
    fi
}



###### look in Webster
function webster() { curl dict://dict.org/d:${1}:web1913; }



###### look in WordNet
function wordnet() { curl dict://dict.org/d:${1}:wn; }</t>
<t tx="sa.20110119013021.1310">##################################################
# User friendly ps				 #
##################################################

function my_ps() { ps $@ -u $USER -o pid,%cpu,%mem,bsdtime,command ; }



function pp() { my_ps f | awk '!/awk/ &amp;&amp; $0~var' var=${1:-".*"} ; }



function psaux() {
    [ $# == 1 ] &amp;&amp; ps aux | grep $1
}



</t>
<t tx="sa.20110119013021.1311">##################################################
# Stupid simple note taker			 #
##################################################

function note()
{
        # if file doesn't exist, create it
        [ -f $HOME/.notes ] || touch $HOME/.notes
        # no arguments, print file
        if [ $# = 0 ]
        then
                cat $HOME/.notes
        # clear file
        elif [ $1 = -c ]
        then
                &gt; $HOME/.notes
        # add all arguments to file
        else
                echo "$@" &gt;&gt; $HOME/.notes
        fi
}

</t>
<t tx="sa.20110119013021.1312"></t>
<t tx="sa.20110119013021.1313">##################################################
# Remove apps with style: nuke it from orbit	 #
##################################################

###### You can't stand programs x, y, and z. Remove all trace of their existence by adding this function to your config. It will remove the cruft, the settings, #and such and such. This function doesn't even give a damn about you trying to remove programs that don't exist: it'll just for loop to the next one on #your hit list.
function nuke() { if [ $(whoami) != "root" ] ; then for x in $@; do sudo apt-get autoremove --purge $x; done; else for x in $@; do apt-get autoremove --purge $x; done; fi }

</t>
<t tx="sa.20110119013021.1314">##################################################
# Download all installed deb packages from 	 #
# official repos currently on system		 #
##################################################

function packagelistdl()
{
sudo dpkg --get-selections | awk '{ print $1};' | while read package; do apt-cache show "$package"| wget -c 'http://ae.archive.ubuntu.com/ubuntu/'`sed -ne '/^Filename/s/^Filename: //p'`; done
}</t>
<t tx="sa.20110119013021.1315">###### search Debian (or Ubuntu) package database (apt) using dpkg
#   $1 = search term (package name)
function sp() { apt-cache search "$1" | grep -i "$1"; }  # search all available</t>
<t tx="sa.20110119013021.1316"></t>
<t tx="sa.20110119013021.1317">##################################################
# Size of directories in MB			 #
##################################################

function ds()
{
    echo "size of directories in MB"
    if [ $# -lt 1 ] || [ $# -gt 2 ]; then
        echo "you did not specify a directy, using pwd"
        DIR=$(pwd)
        find $DIR -maxdepth 1 -type d -exec du -sm \{\} \; | sort -nr
    else
        find $1 -maxdepth 1 -type d -exec du -sm \{\} \; | sort -nr
    fi
}</t>
<t tx="sa.20110119013021.1318">##################################################
# Size of items in directory			 #
##################################################

function dubigf() {
  du -sh * | awk '/[[:space:]]*[[:digit:]]+,*[[:digit:]]*G/' | sort -nr
  du -sh * | awk '/[[:space:]]*[[:digit:]]+,*[[:digit:]]*M/' | sort -nr
}


</t>
<t tx="sa.20110119013021.1319">

##################################################
# Monitor progress of data through a pipeline	 #
##################################################

function tarcp() {
    if (( $# &gt;= 2 )); then
        echo "copy ${@[1, -2]} =&gt; ${@[-1]}"
        # http://www.ivarch.com/programs/pv.shtml
        if which pv ; then
            tar -c -f - ${@[1, -2]} | pv -t -b -r | tar -x -f - -C ${@[-1]}
        else
            tar -c -v -f - ${@[1, -2]} | tar -x -f - -C ${@[-1]}
        fi
    else
        "error, not enough parameters."
        return 1
    fi
}</t>
<t tx="sa.20110119013021.1320">##################################################
# Find a file(s) ...				 #
##################################################

###### ... with pattern $1 in name and Execute $2 on it
function fe() { find . -type f -iname '*'$1'*' -exec "${2:-file}" {} \;  ; }



###### ... under the current directory
function ff() { /usr/bin/find . -name "$@" ; }



###### ... whose name ends with a given string
function ffe() { /usr/bin/find . -name '*'"$@" ; }



###### ... whose name starts with a given string
function ffs() { /usr/bin/find . -name "$@"'*' ; }



###### ... larger than a certain size (in bytes)
function find_larger() { find . -type f -size +${1}c ; }



###### find a file with a pattern in name in the local directory
function fp()
{
    find . -type f -iname '*'$*'*' -ls ;
}


###### ... who is the newest file in a directory
function newest() { find ${1:-\.} -type f |xargs ls -lrt ; }
</t>
<t tx="sa.20110119013021.1321">###### find pattern in a set of files and highlight them
function fstr()
{
    OPTIND=1
    local case=""
    local usage="fstr: find string in files.
Usage: fstr [-i] \"pattern\" [\"filename pattern\"] "
    while getopts :it opt
    do
        case "$opt" in
        i) case="-i " ;;
        *) echo "$usage"; return;;
        esac
    done
    shift $(( $OPTIND - 1 ))
    if [ "$#" -lt 1 ]; then
        echo "$usage"
        return;
    fi
    local SMSO=$(tput smso)
    local RMSO=$(tput rmso)
    find . -type f -name "${2:-*}" -print0 | xargs -0 grep -sn ${case} "$1" 2&gt;&amp;- | \
sed "s/$1/${SMSO}\0${RMSO}/gI" | more
}



###### searches through the text of all the files in your current directory
# http://seanp2k.com/?p=13
# Good for debugging a PHP script you didn't write and can't trackdown where MySQL connect string actually is
# function grip() {
# grep -ir "$1″ "$PWD"
# }

##################################################
# Find in file and ( AND relation )		 #
##################################################

# Will search PWD for text files that contain $1 AND $2 AND $3 etc...
# Actually it does the same as grep word1|grep word2|grep word3 etc, but in a more elegant way.
function ffa() { (($# &lt; 2)) &amp;&amp; { echo "usage: ffa pat1 pat2 [...]" &gt;&amp;2; return 1; };awk "/$1/$(printf "&amp;&amp;/%s/" "${@:2}")"'{ print FILENAME ":" $0 }' *; }

</t>
<t tx="sa.20110119013021.1322"></t>
<t tx="sa.20110119013021.1323">##################################################
# Print the corresponding error message		 #
##################################################

function strerror() { python -c "import os; print os.strerror($1)"; }
</t>
<t tx="sa.20110119013021.1324"></t>
<t tx="sa.20110119013021.1325">##################################################
# Edit files in place to ensure Unix line-	 #
# endings					 #
##################################################

function fixlines() { /usr/bin/perl -pi~ -e 's/\r\n?/\n/g' "$@" ; }

</t>
<t tx="sa.20110119013021.1326">

##################################################
# Easily run a program in the background without #
# losing output	 				 #
##################################################

function fork() { tf=$(tempfile -d /tmp -p $1.);echo -n "$tf "; $@ &amp;&gt;$tf&amp; }

</t>
<t tx="sa.20110119013021.1327">##################################################
# Find out the pid of a specified process	 #
##################################################

######  note that the command name can be specified via a regex
#    E.g. findPid '/d$/' finds pids of all processes with names ending in 'd'
#    Without the 'sudo' it will only find processes of the current user
function findPid() { sudo /usr/sbin/lsof -t -c "$@" ; }

</t>
<t tx="sa.20110119013021.1328"></t>
<t tx="sa.20110119013021.1329">##################################################
# Extract a particular column of space-		 #
# separated output				 #
##################################################

###### e.g.: lsof | getcolumn 0 | sort | uniq
function getcolumn() { perl -ne '@cols = split; print "$cols['$1']\n"' ; }



</t>
<t tx="sa.20110119013021.1330"></t>
<t tx="sa.20110119013021.1331">##################################################
# Git stuff					 #
##################################################

###### copyright 2007 - 2010 Christopher Bratusek
function git_action() {
	if [[ -d .git ]]; then
		if [[ -f .git/dotest/rebasing ]]; then
			ACTION="rebase"
		elif [[ -f .git/dotest/applying ]]; then
			ACTION="apply"
		elif [[ -f .git/dotest-merge/interactive ]]; then
			ACTION="rebase -i"
		elif [[ -d .git/dotest-merge ]]; then
			ACTION="rebase -m"
		elif [[ -f .git/MERGE_HEAD ]]; then
			ACTION="merge"
		elif [[ -f .git/index.lock ]]; then
			ACTION="locked"
		elif [[ -f .git/BISECT_LOG ]]; then
			ACTION="bisect"
		else	ACTION="nothing"
		fi
		echo $ACTION
	else	echo --
	fi
}



function git_branch() {
	if [[ -d .git ]]; then
		BRANCH=$(git symbolic-ref HEAD 2&gt;/dev/null)
		echo ${BRANCH#refs/heads/}
	else	echo --
	fi
}



function git_bzip() {
	git archive master | bzip2 -9 &gt;"$PWD".tar.bz2
}



function git_e() {
	if [[ "$SVN_USER_ENLIGTENMENT" &amp;&amp; $1 == "-m" ]]; then
		svn co svn+ssh://"$SVN_USER_ENLIGTENMENT"@svn.enlightenment.org/var/svn/$2
	else
		svn co http://svn.enlightenment.org/svn/$2
	fi
}



function git_export() {
	if [[ "$1" != "" ]]; then
		git checkout-index --prefix="$1"/ -a
	fi
}



function git_gnome() {
	if [[ $GIT_USER_GNOME ]]; then
		if [[ $1 == "-m" ]]; then
			git clone git+ssh://$GIT_USER_GNOME@git.gnome.org/git/$2
		elif [[ $1 == "-mb" ]]; then
			git clone -b $3 git+ssh://$GIT_USER_GNOME@git.gnome.org/git/$2
		fi
	fi
	if [[ $1 == "-b" ]]; then
		git clone -b $3 git://git.gnome.org/$2
	else 	git clone git://git.gnome.org/$1
	fi
}



function git_kde() {
	if [[ "$SVN_USER_KDE" ]]; then
		if [[ $1 == "-m" ]]; then
			svn co --user-name="$SVN_USER_KDE" svn+ssh://svn.kde.org/home/kde/trunk/KDE/$2
		elif [[ $1 == "-mb" ]]; then
			svn co --user-name="$SVN_USER_KDE" svn+ssh://svn.kde.org/home/kde/branches/KDE/$2
		fi
	fi
	if [[ $1 == "-b" ]]; then
		svn co svn://svn.kde.org/home/kde/branches/KDE/$2
	else	svn co svn://svn.kde.org/home/kde/trunk/KDE/$2
	fi
}



function git_revision() {
	if [[ -d .git ]]; then
		REVISION=$(git rev-parse HEAD 2&gt;/dev/null)
		REVISION=${REVISION/HEAD/}
		echo ${REVISION:0:6}
	else	echo --
	fi
}



function git_xfce() {
	if [[ $GIT_USER_XFCE ]]; then
		if [[ $1 == "-m" ]]; then
			git clone ssh://$GIT_USER_XFCE@git.xfce.org/git/$2
		elif [[ $1 == "-mb" ]]; then
			git clone -b $3 ssh://$GIT_USER_XFCE@git.xfce.org/git/$2
		fi
	fi
	if [[ $1 == "-b" ]]; then
		git clone -b $3 git://git.xfce.org/$2
	else	git clone git://git.xfce.org/$1
	fi
}



function git_xz() {
	git archive master | xz -9 &gt; "$PWD".tar.xz
}



function gup() {
  git fetch &amp;&amp; git rebase origin/$(git branch | grep '^\*' | cut -d\  -f2)
}
</t>
<t tx="sa.20110119013021.1332">##################################################
# Grep, grep, grep				 #
##################################################

###### to grep through files found by find, e.g. grepf pattern '*.c'
# note that 'grep -r pattern dir_name' is an alternative if want all files
function grepfind() { find . -type f -name "$2" -print0 | xargs -0 grep "$1" ; }



###### to grep through the /usr/include directory
function grepincl() { (cd /usr/include; find . -type f -name '*.h' -print0 | xargs -0 grep "$1" ) ; }



###### hgrep, hgrepl (I use these so much I miss them not being on my other machines and should copy them over)
function hgrepl() {
history | sed s/.*\ \ // | grep $@
}



function hgrep() {
history | sed s/.*\ \ // | grep $@ | tail -n 30
}



function hhgrep() {
history | egrep "$@" | egrep -v "hgrep $@"
}</t>
<t tx="sa.20110119013021.1333">##################################################
# Kill a process by name			 #
##################################################

###### example: killps firefox-bin
function killps()
{
    local pid pname sig="-TERM" # default signal
    if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
        echo "Usage: killps [-SIGNAL] pattern"
        return;
    fi
    if [ $# = 2 ]; then sig=$1 ; fi
    for pid in $(myps | nawk '!/nawk/ &amp;&amp; $0~pat { print $2 }' pat=${!#}) ; do
        pname=$(myps | nawk '$2~var { print $6 }' var=$pid )
        if ask "Kill process $pid &lt;$pname&gt; with signal $sig ? "
            then kill $sig $pid
        fi
    done
}



###### example: pskill firefox-bin
# copyright 2007 - 2010 Christopher Bratusek
function psgrep() {
	if [[ $1 == "-u" ]]; then
		ps aux | grep -v grep | grep $2 | awk '{ print $2 " : " $11}' | tee .temp
		CMDS=$(cat .temp)
	elif [[ $1 != "" ]]; then
		ps aux | grep -v grep | grep "$1" | awk '{ print $11 " : " $2 " : " $1 }' | tee .temp
		CMDS=$(cat .temp)
	fi
	if [[ $CMDS == "" ]]; then
		echo "no matching process"
	fi
	rm -f .temp
}



function pskill() {
	if [[ $1 ]]; then
		psgrep $1
		shift
		if [[ $CMDS != "" ]]; then
			echo -e "\nenter process number to kill:\n"
			read ID
			if [[ ! $ID == 0 || ! $ID == "" ]]; then
				kill $@ $ID
			fi
		fi
	fi
}

</t>
<t tx="sa.20110119013021.1334">




##################################################
# Advanced ls functions				 #
##################################################

function la() {
	# copyright 2007 - 2010 Christopher Bratusek
	ls -A --group-directories-first "$@"
}



function lg() {
	# copyright 2007 - 2010 Christopher Bratusek
	if [[ "$@" == "" ]]; then
		$@="*"
	fi
	ls -l --group-directories-first "$@" | gawk '{print $9, "belongs to Group -&gt;", $4}' | column -t
}



function ll() {
	# copyright 2007 - 2010 Christopher Bratusek
	ls -l --group-directories-first "$@"
}



###### Counts files, subdirectories and directory size and displays details
# about files depending on the available space
function lls() {
	# count files
	echo -n "&lt;`find . -maxdepth 1 -mindepth 1 -type f | wc -l | tr -d '[:space:]'` files&gt;"
	# count sub-directories
	echo -n " &lt;`find . -maxdepth 1 -mindepth 1 -type d | wc -l | tr -d '[:space:]'` dirs/&gt;"
	# count links
	echo -n " &lt;`find . -maxdepth 1 -mindepth 1 -type l | wc -l | tr -d '[:space:]'` links@&gt;"
	# total disk space used by this directory and all subdirectories
	echo " &lt;~`du -sh . 2&gt; /dev/null | cut -f1`&gt;"
	ROWS=`stty size | cut -d' ' -f1`
	FILES=`find . -maxdepth 1 -mindepth 1 |
	wc -l | tr -d '[:space:]'`
	# if the terminal has enough lines, do a long listing
	if [ `expr "${ROWS}" - 6` -lt "${FILES}" ]; then
		ls
	else
		ls -hlAF --full-time
	fi
}



function lo() {
	# copyright 2007 - 2010 Christopher Bratusek
	if [[ "$@" == "" ]]; then
		$@="*"
	fi
	ls -l --group-directories-first "$@" | gawk '{print $9, "belongs to User -&gt;", $3}' | sed -e '1d' | column -t
}



function l1() {
	# copyright 2007 - 2010 Christopher Bratusek
	ls -1 --group-directories-first "$@"
}




function lm() {
	# copyright 2007 - 2010 Christopher Bratusek
	if [[ ! "$@" == "" ]]; then
		for file in "$@"; do
			stat -c "%A %a %n" "$file" | gawk '{print "Permissions of:", $3, "-&gt;", $1, "("$2")"}'
		done | column -t
	fi
}



###### inspired by http://tldp.org/HOWTO/Bash-Prompt-HOWTO/x279.html
# but I made it a single awk instead of an awk, forloop and a bc
# asumes we have awk available.  but really, who doesnt have awk?
# let's get the size of the files in this dir
function lsbytes() {
    echo -n $(ls -l | awk '/^-/{total += $5} END{printf "%.2f", total/1048576}')
}



function lscd() {
	# copyright 2007 - 2010 Christopher Bratusek
	builtin cd "${@}" &amp;&gt;/dev/null
	. $BSNG_RC_DIR/dirinfo/display
	dirinfo_display
	echo -e "${epink}content:"
	ls $LSCD_OPTS
	echo "$PWD" &gt; $HOME/.lastpwd
}



###### display long list of files with the given extension
# example: lsext txt
function lsext()
{
find . -type f -iname '*.'${1}'' -exec ls -l {} \; ;
}



###### another way to call for a list of files/folders
function lsr() { /bin/ls -l "$@"/..namedfork/rsrc ; }

</t>
<t tx="sa.20110119013021.1335">##################################################
# Delete function				 #
##################################################

function del()
{
    mv "$@" "/${HOME}/.local/share/Trash/files/"
}



function delete() {
    DIR=$1
    shift
    for i in $*; do
        if [ -f $DIR/$i ]; then
            rm $DIR/$i
        fi
    done
}


##################################################
# Moves specified files to ~/.Trash		 #
##################################################

###### will not overwrite files that have the same name
function trashit()
{   local trash_dir=$HOME/.Trash
    for file in "$@" ; do
        if [[ -d $file ]] ; then
            local already_trashed=$trash_dir/`basename $file`
            if [[ -n `/bin/ls -d $already_trashed*` ]] ; then
                local count=`/bin/ls -d $already_trashed* | /usr/bin/wc -l`
                count=$((++count))
                /bin/mv --verbose "$file" "$trash_dir/$file$count"
                continue
            fi
        fi
        /bin/mv --verbose --backup=numbered "$file" $HOME/.Trash
    done
}</t>
<t tx="sa.20110119013021.1336">##################################################
# Cp with progress bar (using pv)		 #
##################################################

function cp_p() {
	if [ `echo "$2" | grep ".*\/$"` ]
	then
		pv "$1" &gt; "$2""$1"
	else
		pv "$1" &gt; "$2"/"$1"
	fi
}</t>
<t tx="sa.20110119013021.1337">###### lowercase all files in the current directory
function lcfiles() {
	print -n 'Really lowercase all files? (y/n) '
	if read -q ; then
		for i in * ; do
			mv $i $i:l
	done
	fi
}
</t>
<t tx="sa.20110119013021.1338">###### move filenames to lowercase
function lowercase()
{
    for file ; do
        filename=${file##*/}
        case "$filename" in
        */*) dirname==${file%/*} ;;
        *) dirname=.;;
        esac
        nf=$(echo $filename | tr A-Z a-z)
        newname="${dirname}/${nf}"
        if [ "$nf" != "$filename" ]; then
            mv "$file" "$newname"
            echo "lowercase: $file --&gt; $newname"
        else
            echo "lowercase: $file not changed."
        fi
    done
}</t>
<t tx="sa.20110119013021.1339">###### Space removal and lowercases folders in current dir.
function rmspaces() {
    ls | while read -r FILE
        do
        mv -v "$FILE" `echo $FILE | tr ' ' '_' | tr -d '[{}(),\!]' | tr -d "\'" | tr '[A-Z]' '[a-z]' | sed 's/_-_/_/g'`
        done
}
</t>
<t tx="sa.20110119013021.1340">###### sort lines in a text file
function linesort()
{
sort -u "$1" &gt; "$1".new
}</t>
<t tx="sa.20110119013021.1341">###### remove duplicate lines in a file (without resorting)
function removeduplines()
{
awk '!x[$0]++' "$1" &gt; "$1".new
}</t>
<t tx="sa.20110119013021.1342">


##################################################
# Makes directory then moves into it		 #
##################################################

function mkcdr() {
    mkdir -p -v $1
    cd $1
}



function mkdircd()	{ mkdir -p "$@" &amp;&amp; eval cd "\"\$$#\""; }

</t>
<t tx="sa.20110119013021.1343">function mktar() { tar cvf  "${1%%/}.tar"     "${1%%/}/"; }

</t>
<t tx="sa.20110119013021.1344">
function mktbz() { tar cvjf "${1%%/}.tar.bz2" "${1%%/}/"; }
</t>
<t tx="sa.20110119013021.1345">##################################################
# Creates an archive from directory		 #
##################################################


function mktgz() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }

</t>
<t tx="sa.20110119013021.1346"></t>
<t tx="sa.20110119013021.1347">
##################################################
# Creates a dated tarball			 #
##################################################

function tarball()
{
    name=$1
    shift
    tar zcvf $name-`date +%Y%m%d`.tar.gz "$@"
}

</t>
<t tx="sa.20110119013021.1348">##################################################
# Extract - extract most common compression	 #
# types						 #
##################################################

function extract() {
  local e=0 i c
  for i; do
    if [[ -f $i &amp;&amp; -r $i ]]; then
        c=''
        case $i in
          *.t@(gz|lz|xz|b@(2|z?(2))|a@(z|r?(.@(Z|bz?(2)|gz|lzma|xz)))))
                 c='bsdtar xvf' ;;
          *.7z)  c='7z x'       ;;
          *.Z)   c='uncompress' ;;
          *.bz2) c='bunzip2'    ;;
          *.exe) c='cabextract' ;;
          *.gz)  c='gunzip'     ;;
          *.rar) c='unrar x'    ;;
          *.xz)  c='unxz'       ;;
          *.zip) c='unzip'      ;;
          *)     echo "$0: cannot extract \`$i': Unrecognized file extension" &gt;&amp;2; e=1 ;;
        esac
        [[ $c ]] &amp;&amp; command $c "$i"
    else
        echo "$0: cannot extract \`$i': File is unreadable" &gt;&amp;2; e=2
    fi
  done
  return $e
}</t>
<t tx="sa.20110119013021.1349">
##################################################
# Computes most frequent used words of text file #
##################################################

###### usage:	most_frequent "file.txt"
function most_frequent()
{
cat "$1" | tr -cs "[:alnum:]" "\n"| tr "[:lower:]" "[:upper:]" | awk '{h[$1]++}END{for (i in h){print h[i]" "i}}'|sort -nr | cat -n | head -n 30
}

</t>
<t tx="sa.20110119013021.1350">

##################################################
# Run command detached from terminal and without #
# output					 #
##################################################

###### Usage: nh
function nh() {
    nohup "$@" &amp;&gt;/dev/null &amp;
}

</t>
<t tx="sa.20110119013021.1351">
##################################################
# Open a GUI app from CLI			 #
##################################################

function open() {
  $1 &gt;/dev/null 2&gt;&amp;1 &amp;
}

</t>
<t tx="sa.20110119013021.1352">
##################################################
# Scans a port, returns what's on it.		 #
##################################################

function port() {
lsof -i :"$1"
}



##################################################
# Portscan in one line				 #
##################################################

function portscan()
{
$HOST=127.0.0.1;for((port=1;port&lt;=65535;++port));do echo -en "$port ";if echo -en "open $HOST $port\nlogout\quit" | telnet 2&gt;/dev/null | grep 'Connected to' &gt; /dev/null;then echo -en "\n\nport $port/tcp is open\n\n";fi;done
}
</t>
<t tx="sa.20110119013021.1353">
##################################################
# Print a row of characters across the terminal	 #
##################################################

###### Default character is "=", default color is white
function println()
{
echo -n -e "\e[038;05;${2:-255}m";printf "%$(tput cols)s"|sed "s/ /${1:-=}/g"
}</t>
<t tx="sa.20110119013021.1354">

##################################################
# Run program on a timer			 #
##################################################

###### Example: program-timer 20 viewnior arg1
function program-timer() { perl -e 'alarm shift; exec @ARGV' "$@" &amp; exit; }

</t>
<t tx="sa.20110119013021.1355">
##################################################
# Progress visuals				 #
##################################################







# Function that outputs dots every second until
# command completes	
function sleeper() { while `ps -p $1 &amp;&gt;/dev/null`; do echo -n "${2:-.}"; sleep ${3:-1}; done; }; export -f sleeper



function progressbar()
# copyright 2007 - 2010 Christopher Bratusek
{
	SP_COLOUR="\e[37;44m"
	SP_WIDTH=5.5
	SP_DELAY=0.2
	SP_STRING=${2:-"'|/=\'"}
	while [ -d /proc/$1 ]
	do
		printf "$SP_COLOUR\e7  %${SP_WIDTH}s  \e8\e[01;37m" "$SP_STRING"
		sleep ${SP_DELAY:-.2}
		SP_STRING=${SP_STRING#"${SP_STRING%?}"}${SP_STRING%?}
	done
	tput sgr0
}



###### please wait...
# copyright 2007 - 2010 Christopher Bratusek
function spanner() {
	PROC=$1;COUNT=0
	echo -n "Please wait "
	while [ -d /proc/$PROC ];do
		while [ "$COUNT" -lt 10 ];do
			echo -ne '\x08  ' ; sleep 0.1
			((COUNT++))
		done
		until [ "$COUNT" -eq 0 ];do
			echo -ne '\x08\x08 ' ; sleep 0.1
			((COUNT -= 1))
		done
	done
}



function spin() {
	# copyright 2007 - 2010 Christopher Bratusek
        echo -n "|/     |"
        while [ -d /proc/$1 ]
        do
        # moving right
        echo -ne "\b\b\b\b\b\b\b-     |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\b\\     |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\b|     |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\b /    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b-    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\\    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b|    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b /   |"
        sleep .05
        echo -ne "\b\b\b\b\b-   |"
        sleep .05
        echo -ne "\b\b\b\b\b\\   |"
        sleep .05
        echo -ne "\b\b\b\b\b|   |"
        sleep .05
        echo -ne "\b\b\b\b\b /  |"
        sleep .05
        echo -ne "\b\b\b\b-  |"
        sleep .05
        echo -ne "\b\b\b\b\\  |"
        sleep .05
        echo -ne "\b\b\b\b|  |"
        sleep .05
        echo -ne "\b\b\b\b / |"
        sleep .05
        echo -ne "\b\b\b- |"
        sleep .05
        echo -ne "\b\b\b\\ |"
        sleep .05
        echo -ne "\b\b\b| |"
        sleep .05
        echo -ne "\b\b\b /|"
        sleep .05
        echo -ne "\b\b-|"
        sleep .05
        echo -ne "\b\b\\|"
        sleep .05
        echo -ne "\b\b||"
        sleep .05
        echo -ne "\b\b/|"
        sleep .05
        # moving left
        echo -ne "\b\b||"
        sleep .05
        echo -ne "\b\b\\|"
        sleep .05
        echo -ne "\b\b-|"
        sleep .05
        echo -ne "\b\b\b/ |"
        sleep .05
        echo -ne "\b\b\b| |"
        sleep .05
        echo -ne "\b\b\b\\ |"
        sleep .05
        echo -ne "\b\b\b- |"
        sleep .05
        echo -ne "\b\b\b\b/  |"
        sleep .05
        echo -ne "\b\b\b\b|  |"
        sleep .05
        echo -ne "\b\b\b\b\\  |"
        sleep .05
        echo -ne "\b\b\b\b-  |"
        sleep .05
        echo -ne "\b\b\b\b\b/   |"
        sleep .05
        echo -ne "\b\b\b\b\b|   |"
        sleep .05
        echo -ne "\b\b\b\b\b\\   |"
        sleep .05
        echo -ne "\b\b\b\b\b-   |"
        sleep .05
        echo -ne "\b\b\b\b\b\b/    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b|    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\\    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b-    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\b/     |"
        sleep .05
        done
	echo -e "\b\b\b\b\b\b\b\b\b|=======| done!"
}



function spinner()
# copyright 2007 - 2010 Christopher Bratusek
{
	PROC=$1
	while [ -d /proc/$PROC ];do
		echo -ne '\e[01;32m/\x08' ; sleep 0.05
		echo -ne '\e[01;32m-\x08' ; sleep 0.05
		echo -ne '\e[01;32m\\\x08' ; sleep 0.05
		echo -ne '\e[01;32m|\x08' ; sleep 0.05
	done
}



###### Display a progress process
# To start the spinner2 function, you have to send the function
# into the background. To stop the spinner2 function, you have
# to define the argument "stop".
# EXAMPLE:
#    echo -n "Starting some daemon "; spinner2 &amp;
#    if sleep 10; then
#       spinner2 "stop"; echo -e "\t[ OK ]"
#    else
#       spinner2 "stop"; echo -e "\t[ FAILED ]"
#    fi
function spinner2() {
      local action=${1:-"start"}
      declare -a sign=( "-" "/" "|" "\\\\" )
      # define singnal file...
      [ "$action" = "start" ] &amp;&amp; echo 1 &gt; /tmp/signal
      [ "$action" = "stop" ] &amp;&amp; echo 0 &gt; /tmp/signal
      while [ "$( cat /tmp/signal 2&gt;/dev/null )" == "1" ] ; do
          for (( i=0; i&lt;${#sign[@]}; i++ )); do
              echo -en "${sign[$i]}\b"
              # with this command you can use millisecond as sleep time - perl rules ;-)
              perl -e 'select( undef, undef, undef, 0.1 );'
          done
      done
      # clear the last ${sign[$i]} sign at finish...
      [ "$action" = "stop" ] &amp;&amp; echo -ne " \b"
}



function working()
# copyright 2007 - 2010 Christopher Bratusek
{
   while [ -d /proc/$1 ]
   do
	echo -ne "w      \b\b\b\b\b\b\b";sleep .08;
	echo -ne "wo     \b\b\b\b\b\b\b";sleep .08;
	echo -ne "wor    \b\b\b\b\b\b\b";sleep .08;
	echo -ne "work   \b\b\b\b\b\b\b";sleep .08;
	echo -ne "worki  \b\b\b\b\b\b\b";sleep .08;
	echo -ne "workin \b\b\b\b\b\b\b";sleep .08;
	echo -ne "working\b\b\b\b\b\b\b";sleep .08;
	echo -ne " orking\b\b\b\b\b\b\b";sleep .08;
	echo -ne "  rking\b\b\b\b\b\b\b";sleep .08;
	echo -ne "   king\b\b\b\b\b\b\b";sleep .08;
	echo -ne "    ing\b\b\b\b\b\b\b";sleep .08;
	echo -ne "     ng\b\b\b\b\b\b\b";sleep .08;
	echo -ne "      g\b\b\b\b\b\b\b";sleep .08;
   done
}
</t>
<t tx="sa.20110119013021.1356"></t>
<t tx="sa.20110119013021.1357">
##################################################
# Sanitize - set file/directory owner and	 #
# permissions to normal values (644/755)	 #
##################################################

###### usage: sanitize &lt;file&gt;
function sanitize()
{
  chmod -R u=rwX,go=rX "$@"
  chown -R ${USER}:users "$@"
}

</t>
<t tx="sa.20110119013021.1358">##################################################
# Save a file to ~/Temp				 #
##################################################

function saveit() {
cp $1 ${HOME}/tmp/${1}.saved
}

</t>
<t tx="sa.20110119013021.1359">##################################################
# Make a backup before editing a file		 #
##################################################

function safeedit() {
cp $1 ${1}.backup &amp;&amp; vim $1
}

</t>
<t tx="sa.20110119013021.1360">
##################################################
# Search and replace words/phrases from text file#
##################################################

###### usage:	searchnreplace "whatever oldtext" "whatever newtext" "file(s) to act on"
function searchnreplace()
{
# Store old text and new text in variables
old=$1;
new=$2;
# Shift positional parameters to places to left (get rid of old and
# new from command line)
shift;
shift;
# Store list of files as a variable
files=$@;
a='';
for a in $files
 do
  temp=$(echo "/tmp/$LOGNAME-$a");
# echo "$temp";
  echo -n ".";
  sed -e "s/$old/$new/g" $a &gt; $temp;
  mv $temp $a;
 done
echo;
echo -e "Searched $# files for '$old' and replaced with '$new'";
}
</t>
<t tx="sa.20110119013021.1361">##################################################
# Show the contents of a file, including 	 #
# additional useful info			 #
##################################################

function showfile()
{
width=72
for input
do
  lines="$(wc -l &lt; $input | sed 's/ //g')"
  chars="$(wc -c &lt; $input | sed 's/ //g')"
  owner="$(ls -ld $input | awk '{print $3}')"
  echo "-----------------------------------------------------------------"
  echo "File $input ($lines lines, $chars characters, owned by $owner):"
  echo "-----------------------------------------------------------------"
  while read line
    do
      if [ ${#line} -gt $width ] ; then
        echo "$line" | fmt | sed -e '1s/^/  /' -e '2,$s/^/+ /'
      else
        echo "  $line"
      fi
    done &lt; $input
  echo "-----------------------------------------------------------------"
done | more
}</t>
<t tx="sa.20110119013021.1362"></t>
<t tx="sa.20110119013021.1363">##################################################
###### command line way to get the stock quote via Yahoo
function stock()
{
curl -s 'http://download.finance.yahoo.com/d/quotes.csv?s=csco&amp;f=l1'
}


</t>
<t tx="sa.20110119013021.1364"></t>
<t tx="sa.20110119013021.1365">
##################################################
# Recursively fix dir/file permissions on a	 #
# given directory				 #
##################################################

function fix() {
if [ -d $1 ]; then
find $1 -type d -exec chmod 755 {} \;
find $1 -type f -exec chmod 644 {} \;
else
echo "$1 is not a directory."
fi
}</t>
<t tx="sa.20110119013021.1366"></t>
<t tx="sa.20110119013021.1367"></t>
<t tx="sa.20110119013021.1368">##################################################
# Change to specified pkg's documentation dir and#
# display the files				 #
##################################################s

###### Usage: doc
function doc() {
    pushd "/usr/share/doc/$1" &amp;&amp; ls
}

</t>
<t tx="sa.20110119013021.1369"></t>
<t tx="sa.20110119013021.1370">##################################################
# Show computer information of all sorts	 #
# (requires 'gawk': sudo apt-get install gawk)	 #
##################################################

###### machine details
function ii()
{
    echo -e "\n${RED}You are logged onto:$NC " ; hostname
    echo -e "\n${RED}Additionnal information:$NC " ; uname -a
    echo -e "\n${RED}Users logged on:$NC " ; w -h
    echo -e "\n${RED}Current date:$NC " ; date
    echo -e "\n${RED}Machine stat:$NC " ; uptime
    echo -e "\n${RED}Disk space:$NC " ; df -h
    echo -e "\n${RED}Memory stats (in MB):$NC " ;
    if [ "$OS" = "Linux" ]; then
        free -m
    elif [ "$OS" = "Darwin" ]; then
        vm_stat
    fi
    echo -e "\n${RED}IPs:$NC " ; ips
}

</t>
<t tx="sa.20110119013021.1371">

###### example:	man2text wipe	=	wipe.txt
function man2text()
{
man "$1" | col -b &gt; ~/man_"$1".txt
}


</t>
<t tx="sa.20110119013021.1372">##################################################
# Ownership Changes { own file user }		 #
##################################################

function own() { chown -R "$2":"$2" ${1:-.}; }
</t>
<t tx="sa.20110119013021.1373">##################################################
# Pacman Search					 #
##################################################

function pacsearch() {
       echo -e "$(pacman -Ss $@ | sed \
       -e 's#core/.*#\\033[1;31m&amp;\\033[0;37m#g' \
       -e 's#extra/.*#\\033[0;32m&amp;\\033[0;37m#g' \
       -e 's#community/.*#\\033[1;35m&amp;\\033[0;37m#g' \
       -e 's#^.*/.* [0-9].*#\\033[0;36m&amp;\\033[0;37m#g' )"
}


</t>
<t tx="sa.20110119013021.1374">##################################################
# Roll - archive wrapper			 #
##################################################

###### usage: roll &lt;foo.tar.gz&gt; ./foo ./bar
function roll()
{
  FILE=$1
  case $FILE in
    *.tar.bz2) shift &amp;&amp; tar cjf $FILE $* ;;
    *.tar.gz) shift &amp;&amp; tar czf $FILE $* ;;
    *.tgz) shift &amp;&amp; tar czf $FILE $* ;;
    *.zip) shift &amp;&amp; zip $FILE $* ;;
    *.rar) shift &amp;&amp; rar $FILE $* ;;
  esac
}
</t>
<t tx="sa.20110119013021.1375">##################################################
# RTFM function					 #
##################################################

function rtfm() { help $@ || man $@ || $BROWSER "http://www.google.com/search?q=$@"; }
</t>
<t tx="sa.20110119013021.1376">##################################################
# Display theme info				 #
##################################################

function themeinfo() {
  if [ `pgrep emerald` ]; then
    echo "  Emerald:    `cat $HOME/.emerald/theme/theme.ini | grep description | awk -F= '{print $2}'`"
  else
    echo "  Metacity:   `gconftool-2 -g /apps/metacity/general/theme`"
  fi
  echo "  GTK:        `gconftool-2 -g /desktop/gnome/interface/gtk_theme`"
  echo "  Icons:      `gconftool-2 -g /desktop/gnome/interface/icon_theme`"
  echo "  Cursor:     `gconftool-2 -g /desktop/gnome/peripherals/mouse/cursor_theme`"
  echo "  Font:       `gconftool-2 -g /desktop/gnome/interface/font_name`"
  echo "  Wallpaper:  `gconftool-2 -g /desktop/gnome/background/picture_filename | xargs basename | cut -d. -f 1`"
  echo
}

</t>
<t tx="sa.20110119013021.1377">##################################################
# To examine lots of files and potentially move  #
# them to a common directory			 #
##################################################

###### ex:	tmv -s /mnt/disk/5k
# ex:	make a playlist
# ex:	tmv eye-of-the-tiger.mp3 #  &lt;-&gt; mv eye-of-the-tiger.mp3 /mnt/disk/5k
function tmv() {
        if [ "$1" = "-s" -o "$1" = "--set-target" ]; then
                MOVE_TARGET="$(realpath $2)";
        elif [ "$1" = "-h" -o "$1" = "--help" ]; then
                echo "usage: tmv [-s|--set-target &lt;dir&gt;] | &lt;mv args&gt; &lt;files&gt;";
        else
                mv --target-directory "$MOVE_TARGET" "$@";
        fi
}
</t>
<t tx="sa.20110119013021.1378">##################################################
# Changes spaces to underscores in names	 #
##################################################

function underscore()
{
	for f in * ; do
    	[ "${f}" != "${f// /_}" ]
		mv -- "${f}" "${f// /_}"
	done
}</t>
<t tx="sa.20110119013021.1379">
##################################################
# Run a command, redirecting output to a file, 	 #
# then edit the file with vim			 #
##################################################

function vimcmd() { $1 &gt; $2 &amp;&amp; vim $2; }

</t>
<t tx="sa.20110119013021.1380">
##################################################
# Xchown something				 #
##################################################

function xchown() {
	# copyright 2007 - 2010 Christopher Bratusek
	user="$1"
	shift
	for df in "$@";
		do su -c "chown -R $user:$user \"$df\"";
	done
}

</t>
<t tx="sa.20110119013021.1381">

##################################################
# Overwrite a file with zeros			 #
##################################################

function zero() {
        case "$1" in
                "")     echo "Usage: zero &lt;file&gt;"

                        return -1;
        esac
        filesize=`wc -c  "$1" | awk '{print $1}'`
        `dd if=/dev/zero of=$1 count=$filesize bs=1`
}
</t>
<t tx="sa.20110119013021.1382">


##################################################
# To create a ZIP archive of a file or folder	 #
##################################################

function zipf() { zip -r "$1".zip "$1" ; }
</t>
<t tx="sa.20110119013021.1383">##################################################
# Manage services				 #
##################################################

function service() {
  if [ $# -lt 2 ]; then
    echo "Missing service name or command"
    return 1
  fi
  sudo /etc/init.d/$1 $2 &amp;&amp; return 0
}



###### service() { /etc/rc.d/$1 $2; }
function service_() {
        if [ -n "$2"  ]
        then
                /etc/rc.d/$1 $2
        else
                echo    "All daemons"
                ls --ignore=functions* /etc/rc.d/
                echo    "Running daemons"
                ls /var/run/daemons
        fi
}






##################################################
# Daemon management				 #
##################################################

# function restart() { sudo /etc/rc.d/$1 restart; }



# function start() { sudo /etc/rc.d/$1 start; }



# function stop() { sudo /etc/rc.d/$1 stop; }
</t>
<t tx="sa.20110119013021.1384">##################################################
# Pull a single file out of a .tar.gz		 #
##################################################

function pullout() {
  if [ $# -ne 2 ]; then
    echo "need proper arguments:"
    echo "pullout [file] [archive.tar.gz]"
    return 1
  fi
  case $2 in
    *.tar.gz|*.tgz)
    gunzip &lt; $2 | tar -xf - $1
    ;;
    *)
    echo $2 is not a valid archive
    return 1
    ;;
  esac
  return 0
}
</t>
<t tx="sa.20110119013021.1385">

##################################################
# Set permissions to "standard" values (644/755),#
# recursive					 #
##################################################

###### Usage: resetp
function resetp() {
    chmod -R u=rwX,go=rX "$@"
}
</t>
<t tx="sa.20110121142539.1490"></t>
<t tx="sa.20110121142539.1603">@language shell

@others
</t>
<t tx="sa.20110121142539.1604">





</t>
<t tx="sa.20110121142539.1605"># If not running interactively, don't do anything
[ -z "$PS1" ] &amp;&amp; return
</t>
<t tx="sa.20110121142539.1606"># don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

</t>
<t tx="sa.20110121142539.1607"># check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize
</t>
<t tx="sa.20110121142539.1608"># make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] &amp;&amp; eval "$(SHELL=/bin/sh lesspipe)"
</t>
<t tx="sa.20110121142539.1609"># set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] &amp;&amp; [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi
</t>
<t tx="sa.20110121142539.1610"># set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
# force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac
</t>
<t tx="sa.20110121142539.1611"># enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors &amp;&amp; eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    # alias dir='dir --color=auto'
    # alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
</t>
<t tx="sa.20110121142539.1612"># enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then
    . /etc/bash_completion
fi
</t>
<t tx="sa.20110121142539.1613"># Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

</t>
<t tx="sa.20110121142539.1614">######################################################################################################################################################
# ALIASES
######################################################################################################################################################

##################################################
# App-specific					 
##################################################

alias nano='nano -W -m'								
alias wget='wget -c'


##################################################
# Command substitution				
##################################################

alias c='clear'
alias vi='vim'
alias ck='killall conky &amp;&amp; conky -d'
alias cls='clear'
alias contents='/bin/tar -tzf'								# can View the contents of a Tar file
alias cp='cp -iv'
alias egrep='egrep –color=auto'
alias fgrep='fgrep –color=auto'
alias ge='geany'
alias grep='grep --color=auto'								# highlight matched pattern
alias g_='mocp -G'
alias halt='sudo /sbin/halt'
alias h='history | grep $1'

alias j='jobs -l'

alias last='last -a'

alias logs='tail -f /var/log/messages /var/log/*log'

alias mkdir='mkdir -p -v'
alias mktd='tdir=`mktemp -d` &amp;&amp; cd $tdir'						# make a temp dir, then immediately cd into it

alias more='less'

alias mv='mv -iv'
alias na='nano'
alias nmr='sudo /etc/rc.d/networkmanager restart'
alias n='nautilus &amp; exit'

alias packup='/bin/tar -czvf'							# compress a file in tar format

alias parts='cat /proc/partitions'

alias path='echo -e ${PATH//:/\\n}'

alias pg='ps aux | grep'
# requires an argument

alias ping='ping -c 10'
alias ps='ps auxf'

alias :q='exit'
alias q='exit'

alias rd='cd "`pwd -P`"' 								# if in directory containing symlink in path, change to "real" path
alias reboot='sudo /sbin/reboot'
# alias reboot='sudo shutdown -r now'   							# easy shutdown management
alias refresh='nautilus -q &amp;&amp; killall gnome-panel'
alias rgrep='find . \( ! -name .svn -o -prune \) -type f -print0 | xargs -0 grep'	# rgrep: recursive grep without .svn
alias rh='rehash'
alias rmdir='rmdir -v'
alias rm='rm -iv'
alias root='sudo bash -l'								# generic shortcut for switching to root user depending on system
# alias root='sudo -i'									# generic shortcut for switching to root user depending on system
# alias root='su -'									# generic shortcut for switching to root user depending on system

alias shutdown='sudo shutdown -h now'							# proper restart

alias sn='sudo nano'
alias sql='mysql -p -u root'


alias svi='sudo vim'
alias tc='tar cfvz'
alias tf='tail -50f /var/log/iptables.log'
alias tm='tail -50f /var/log/messages.log'
alias ts='tail -50f /var/log/auth.log'

alias tx='tar xfvz'

alias unpack='/bin/tar -xzvpf'								# uncompress a a Tar file

alias ve='vi ~/.vimrc'
alias vi='vim'
alias web='w3m'   									# terminal based web browser





##################################################
# Computer cleanup				 #
##################################################

alias cleanup='sudo apt-get -y autoclean &amp;&amp; sudo apt-get -y autoremove &amp;&amp; sudo apt-get -y clean &amp;&amp; sudo apt-get -y remove &amp;&amp; sudo deborphan | xargs sudo apt-get -y remove --purge'
alias configpurge="sudo aptitude purge `dpkg --get-selections | grep deinstall | awk '{print $1}'`"	# purge configuration files of removed packages on debian systems
alias kernelcleanup="dpkg -l 'linux-*' | sed '/^ii/!d;/'"$(uname -r | sed "s/\(.*\)-\([^0-9]\+\)/\1/")"'/d;s/^[^ ]* [^ ]* \([^ ]*\).*/\1/;/[0-9]/!d' | xargs sudo apt-get -y purge"										# remove all unused Linux Kernel headers, images &amp; modules
alias orphaned='sudo deborphan | xargs sudo apt-get -y remove --purge'
alias tp='trash-put'											# sends files to trash instead of perm deleting w/rm
alias trash='rm -fr ~/.Trash'










##################################################
# Information					 #
##################################################


alias boothistory='for wtmp in `dir -t /var/log/wtmp*`; do last reboot -f $wtmp; done | less'
alias charcount='wc -c $1'								# count number of characters in text file
alias cpu_hogs='ps wwaxr -o pid,stat,%cpu,time,command | head -10'			# to find CPU hogs
alias df='df -h -x tmpfs -x usbfs'							# displays global disk usage by partition, excluding supermounted devices
alias directorydiskusage='du -s -k -c * | sort -rn'
alias dir='ls --color=auto --format=vertical'
alias diskwho='sudo iotop'
alias dmidecode='sudo dmidecode --type 17 | more'					# check RAM sed and type in Linux
alias ducks='ls -A | grep -v -e '\''^\.\.$'\'' |xargs -i du -ks {} |sort -rn |head -16 | awk '\''{print $2}'\'' | xargs -i du -hs {}'	# useful alias to browse your filesystem for heavy usage quickly						# to show processes reading/writing to disk
alias du='du -h --max-depth=1'								# displays disk usage by directory, in human readable format
alias dush='du -sm *|sort -n|tail'							# easily find megabyte eating files or directories
alias env2='for _a in {A..Z} {a..z};do _z=\${!${_a}*};for _i in `eval echo "${_z}"`;do echo -e "$_i: ${!_i}";done;done|cat -Tsv'	# print all environment variables, including hidden ones
alias exportkeys='sudo apt-key exportall &gt; repokeys.txt'				# exports all repo keys info into single 'repokeys.txt' document
alias exportkey='sudo apt-key export'							# show single repo key info using keyid found in 'sudo apt-key list'
alias ffind='sudo find / -name $1'
alias free='free -m'									# RAM and SWAP detail in MBs
alias freqwatch='watch --interval 1 "cat /proc/acpi/thermal_zone/THRM/*; cat /proc/cpuinfo | grep MHz; cat /proc/acpi/processor/*/throttling"'  # monitor cpu freq and temperature
alias hardware='sudo lshw -html &gt; hardware.html'					# overview of the hardware in the computer
# alias hgrep='history | grep --color=always'						# search commands history
alias hiddenpnps='unhide (proc|sys|brute)'						# forensic tool to find hidden processes and ports
alias hogc='ps -e -o %cpu,pid,ppid,user,cmd | sort -nr | head'				# display the processes that are using the most CPU time and memory
alias hogm='ps -e -o %mem,pid,ppid,user,cmd | sort -nr | head'				# display the processes that are using the most CPU time and memory
alias la_='ls -Al'									# show hidden files
alias l?='cat ~/technical/tips/ls'
alias lc='ls -ltcr'       								# sort by and show change time, most recent last
alias ldir='ls -lhA |grep ^d'
alias ld='ls -ltr' 									# sort by date
alias lfiles='ls -lhA |grep ^-'
alias lf="ls -Alh --color | awk '{k=0;for(i=0;i&lt;=8;i++)k+=((substr(\$1,i+2,1)~/[rwx]/)*2^(8-i));if(k)printf(\" %0o \",k);print}'"	# full ls with octal+symbolic permissions
alias lgg='ls --color=always | grep --color=always -i'					# quick case-insenstive partial filename search
alias lh='ls -Al' 									# show hidden files
alias lh='ls -lAtrh' 									# sort by date and human readable
alias libpath='echo -e ${LD_LIBRARY_PATH//:/\\n}'
alias li='ls -ai1|sort' 								# sort by index number
alias linecount='wc -l $1'								# count number of lines in text file
alias lk='ls -lSr'									# sort by size
alias llllll='ls -FlaXo --color=auto'							# sort the extensions alphabetically; good for winfiles
alias lllll='ls -Fla --full-time -o -Q --color=auto'					# whatever
alias llll='ls -laS --color=auto'							# sort by size
alias lll='ls -Falot --color=auto'							# sort by mod time
alias ll_='ls -l'									# long listing
alias l.='ls -d .[[:alnum:]]* 2&gt; /dev/null || echo "No hidden file here..."'		# list only hidden files
alias l='ls -hF --color'								# quick listing
alias lm_='ls -al |more'    								# pipe through 'more'
alias ln='ln -s'
alias lr='ls -lR'									# recursice ls
alias lrt='ls -lart'									# list files with last modified at the end
alias lsam='ls -am' 									# List files horizontally
alias lsdd='ls -latr'                                 					# sort by date
alias lsd='ls -l | grep "^d"'								# list only directories
alias lsize='ls --sort=size -lhr'							# list by size
alias lsl='ls -lah'                                   					# long list, human-readable
alias ls='ls -hF --color'								# add colors for filetype recognition
alias lsnew='ls -Alh --color=auto --time-style=+%D | grep `date +%D`'
alias lss='ls -shaxSr'                         			       			# sort by size
alias lsss='ls -lrt | grep $1'								# to see something coming into ls output: lss
alias lsx='ls -ax' 									# sort right to left rather then in columns
alias lt_='ls -alt|head -20' 								# 20, all, long listing, modification time
alias lt='ls -ltr'         								# sort by date, most recent last
alias lu='ls -ltur'        								# sort by and show access time, most recent last
alias lx='ls -lXB'									# sort by extension
# alias man='TERMINFO=~/.terminfo TERM=mostlike LESS=C PAGER=less man'			# cool colors for manpages
alias mem_hogs_ps='ps wwaxm -o pid,stat,vsize,rss,time,command | head -10'		# to find memory hogs
alias mem_hogs_top='top -l 1 -o rsize -n 10'						# to find memory hogs
alias mem='~/.scripts/realmem'								# estimates memory usage
alias mypc="hal-get-property --udi /org/freedesktop/Hal/devices/computer --key 'system.hardware.product'"		# show computer model
alias myps='/bin/ps -u "$USER" -o user,pid,ppid,pcpu,pmem,args|less'			# ps
alias numFiles='echo $(ls -1 | wc -l)'							# numFiles: number of (non-hidden) files in current directory
alias packagelist="sudo aptitude search -F %p ~i --disable-columns"			# show list of all packages (columns)
alias packagelist_="sudo aptitude search -F %p ~i --disable-columns | sed 's/$/,/' | tr '\n\r' ' ' | sed 's/, $//'"	# list all packages (1-liner)
alias phonesearch='grep '[0-9]\{3\}-[0-9]\{4\}' "$1"'					# search phone #'s in file (requires XXX-XXX-XXXX format)
alias processbycpuusage="ps -e -o pcpu,cpu,nice,state,cputime,args --sort pcpu | sed '/^ 0.0 /d'"
alias processbymemusage='ps -e -o rss=,args= | sort -b -k1,1n | pr -TW$COLUMNS'
alias processtree='ps -e -o pid,args --forest'
alias pss='ps -ef | grep $1'								# to check a process is running in a box with a heavy load: pss
alias sete='set|sed -n "/^`declare -F|sed -n "s/^declare -f \(.*\)/\1 ()/p;q"`/q;p"'	# display environment vars only, using set
alias showallaliases='compgen -A alias'							# list bash alias defined in .bash_profile or .bashrc
alias showallfunctions='compgen -A function'						# list bash functions defined in .bash_profile or .bashrc
alias showkeys='sudo apt-key list'							# shows list of repository keys
alias sizeof='du -sh'
alias space='df -h'									# disk space usage
alias sshall='logwatch --service sshd --range all --detail high --print --archives'
alias sshtoday='logwatch --service sshd --range today --detail high --print --archives'
alias superfind='sudo find / ! \( -path /proc -prune -o -path /tmp -prune -o -path /dev -prune -o -path /mnt -prune \) -name'
alias top-commands='history | awk "{print $2}" | awk "BEGIN {FS="|"} {print $1}" |sort|uniq -c | sort -rn | head -10'	# show most popular commands
alias topforever='top -l 0 -s 10 -o cpu -n 15'						# continual 'top' listing (every 10 sec) showing top 15 CPU things
alias topten='du -sk $(/bin/ls -A) | sort -rn | head -10'				# displays the top ten biggest folders/files in the current directory
alias top20='du -xk | sort -n | tail -20'						# find the 20 biggest directories on the current filesystem
alias top_='xtitle Processes on $HOST &amp;&amp; top'						# uses the function 'xtitle'
alias treefind_="find . | sed 's/[^/]*\//|   /g;s/| *\([^| ]\)/+--- \1/'"		# displays a tree of the arborescence
alias tree='tree -Cs'									# nice alternative to 'ls'
alias unusedkernels="dpkg -l 'linux-*' | sed '/^ii/!d;/'"$(uname -r | sed "s/\(.*\)-\([^0-9]\+\)/\1/")"'/d;s/^[^ ]* [^ ]* \([^ ]*\).*/\1/;/[0-9]/!d'"											# show installed but unused linux headers, image, or modules
alias vdir='ls --color=auto --format=long'
alias ver='cat /etc/lsb-release'							# Ubuntu version detail
alias version='sudo apt-show-versions'							# show version
alias whichall='{ command alias; command declare -f; } | command which --read-functions --read-alias -a'		# which alias
alias wordcount='wc -w $1'								# count number of words in text file



##################################################
# Information (clock and date stuff)		 #
##################################################

alias bdate="date '+%a, %b %d %Y %T %Z'"
alias cal='cal -3' 									# show 3 months by default
alias da='date "+%Y-%m-%d %A    %T %Z"'							# date command
alias da_="date +'%a %Y-%m-%d %H:%M:%S %z'"						# another date command
alias dateh='date --help|sed "/^ *%a/,/^ *%Z/!d;y/_/!/;s/^ *%\([:a-z]\+\) \+/\1_/gI;s/%/#/g;s/^\([a-y]\|[z:]\+\)_/%%\1_%\1_/I"|while read L;do date "+${L}"|sed y/!#/%%/;done|column -ts_'	# view all date formats, quick reference help alias
alias daysleft='echo "There are $(($(date +%j -d"Dec 31, $(date +%Y)")-$(date +%j))) left in year $(date +%Y)."'	# how many days until the end of the year
alias epochtime='date +%s'								# report number of seconds since the Epoch
alias mytime='date +%H:%M:%S'								# shows just the current time
alias ntpdate='sudo ntpdate ntp.ubuntu.com pool.ntp.org'				# time synchronisation with NTP
alias oclock='read -a A&lt;&lt;&lt;".*.**..*....*** 8 9 5 10 6 0 2 11 7 4";for C in `date +"%H%M"|fold -w1`;do echo "${A:${A[C+1]}:4}";done'   # odd clock
alias onthisday='grep -h -d skip `date +%m/%d` /usr/share/calendar/*'			# on this day
alias secconvert='date -d@1234567890'							# convert seconds to human-readable format
alias stamp='date "+%Y%m%d%a%H%M"'							# timestamps
alias timestamp='date "+%Y%m%dT%H%M%S"'							# date command that lets you create timestamps in ISO 8601 format
alias today='date +"%A, %B %-d, %Y"'
alias weeknum='date +%V'								# perl one-liner to get the current week number





alias counts=sort | uniq -c | sort -nr							# a nice command for summarising repeated information
alias cut80='/usr/bin/cut -c 1-80'							# truncate lines longer than 80 characters (for use in pipes)
alias debrepack='sudo dpkg-repack'							# just an easier-to-remember alias for 'dpkg-repack'
alias differ='sdiff --suppress-common-lines'						# bash alias for sdiff: differ

alias encryptall='for f in * ; do [ -f $f ] &amp;&amp; openssl enc -aes-256-cbc -salt -in $f -out $f.enc -pass file:/tmp/password-file ; done'	# encrypt every file in current directory with 256-bit AES, retaining original

alias fixres='xrandr --size 1600x1200'      						# reset resolution
alias fix_stty='stty sane'								# restore terminal settings when they get completely screwed up

alias irb='irb --readline -r irb/completion -rubygems'

alias kfire='for i in `ps aux | grep [F]irefox `; do echo $i; kill $(($i)); done; '
# alias kfire='kill $(pidof firefox)'
# alias kfire='kill $(ps aux | awk '/firefox/ {print $2}' | tr '\n' ' ')'
alias killall='killall -u $USER -v' 							# only kill our own processes, and also be verbose about it
alias lastlog='lastlog | grep -v Never'
alias less='less -Mw'
alias lssd='ps ax | grep -v grep | grep -i firefox | while read pid; do kill "${pid%% *}"; done'

alias lvim="vim -c \"normal '0\""							# open the last file you edited in Vim.
alias makepasswd='makepasswd -minchars 8'

alias ppa-purge='sudo ppa-purge'
alias pstree='/sw/bin/pstree -g 2 -w'

alias sdiff='/usr/bin/sdiff --expand-tabs --ignore-all-space --strip-trailing-cr --width=160'	# sdiff the way it was at IBM

alias service='sudo service'								# access a system service
alias sh_diff='diff -abBpur'
alias sh_indent='indent -nsaf -npcs -cli2 -i2 -lp -nprs -nsaw -nut -cbi2 -bli0 -bls -nbad -npsl'

##################################################
# Network/Internet -oriented stuff		 #
##################################################

alias appson="netstat -lantp | grep -i stab | awk -F/ '{print $2}' | sort | uniq"	# view only the process name using an internet connection
alias bandwidth='dd if=/dev/zero of=/dev/null bs=1M count=32768'			# processor / memory bandwidthd? in GB/s

# browse services advertised via Bonjour
# alias daemons='ls /var/run/daemons'  							# daemon managment (ommited for function)

# copy remote db to local
alias dns='cat /etc/resolv.conf'							# view DNS numbers
alias domain2ban='~/.scripts/Domain2Ban.sh'
alias estab='ss -p | grep STA' 								# view only established sockets (fails if "ss" is screensaver alias)

# alias ftop='watch -d -n 2 'df; ls -FlAt;''						# like top, but for files
alias hdinfo='hdparm -i[I] /dev/sda'							# hard disk information - model/serial no.
alias hostip='wget http://checkip.dyndns.org/ -O - -o /dev/null | cut -d: -f 2 | cut -d\&lt; -f 1'
alias hostname_lookup='lookupd -d'							# interactive debugging mode for lookupd (use tab-completion)
alias http_trace='pkt_trace port 80'							# to show all HTTP packets
alias iftop='sudo iftop -i eth0' 							# start "iftop" program (sudo apt-get install iftop)
alias ip4grep="grep -E '([0-9]{1,3}\.){3}[0-9]{1,3}'"					# look for IPv4 address in files
alias ip='curl www.whatismyip.org'
alias ip_info='ipconfig getpacket en1'							# info on DHCP server, router, DNS server, etc (for en0 or en1)
alias ipt80='sudo iptstate -D 80'							# check out only iptables state of http port 80 (requires iptstate)
alias ip_trace='pkt_trace ip'								# to show all IP packets
alias ipttrans='sudo iptstate -D 51413'							# iptables state of Transmission-Daemon port (requires iptstate)
alias listen='sudo netstat -pnutl' 							# lists all listening ports together with PID of associated process
alias lsock='sudo /usr/sbin/lsof -i -P'							# to display open sockets ( -P option to lsof disables port names)
alias memrel='free &amp;&amp; sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches &amp;&amp; free'		# release memory used by the Linux kernel on caches
alias net1='watch --interval=2 "sudo netstat -apn -l -A inet"'
alias net2='watch --interval=2 "sudo netstat -anp --inet --inet6"'
alias net3='sudo lsof -i'
alias net4='watch --interval=2 "sudo netstat -p -e --inet --numeric-hosts"'
alias net5='watch --interval=2 "sudo netstat -tulpan"'
alias net6='sudo netstat -tulpan'
alias net7='watch --interval=2 "sudo netstat -utapen"'
alias net8='watch --interval=2 "sudo netstat -ano -l -A inet"'
alias netapps="lsof -P -i -n | cut -f 1 -d ' '| uniq | tail -n +2"
alias nethogs='sudo nethogs eth0' 							# start "nethogs" program (sudo apt-get install nethogs)
alias netl='sudo nmap -sT -O localhost'
alias netscan='sudo iwlist wlan0 scan'							# to scan your environment for available networks, do the following
alias netstats='sudo iwspy wlan0'							# if card supports it, you can collect wireless statistics by using
alias network='sudo lshw -C network' 							# view network device info
alias networkdump='sudo tcpdump not port 22' 						# dump all the network activity except ssh stuff
alias nsl='netstat -f inet | grep -v CLOSE_WAIT | cut -c-6,21-94 | tail +2'		# show all programs connected or listening on a network port
alias ns='netstat -alnp --protocol=inet | grep -v CLOSE_WAIT | cut -c-6,21-94 | tail +2'
alias openports='sudo netstat -nape --inet' 						# view open ports
alias pkt_trace='sudo tcpflow -i `active_net_iface` -c'
alias ports='lsof -i -n -P' 								# view programs using an internet connection
alias portstats='sudo netstat -s' 							
alias ramvalue='sudo dd if=/dev/mem | cat | strings'					# will show you all the string (plain text) values in ram



##################################################
# Permissions					 #
##################################################

alias 000='chmod 000'
alias 640='chmod 640'
alias 644='chmod 644'
alias 755='chmod 755'
alias 775='chmod 775'
alias mx='chmod a+x'
alias perm='stat --printf "%a %n \n "'								# requires a file name e.g. perm file
alias restoremod='chgrp users -R .;chmod u=rwX,g=rX,o=rX -R .;chown $(pwd |cut -d / -f 3) -R .'	# restore user,group and mod of an entire website






</t>
<t tx="sa.20110121142539.1615"># Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] &amp;&amp; echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//'\'')"'

</t>
<t tx="sa.20110121142539.1616">export BLOCKSIZE=K
export BROWSER='firefox'
export EDITOR='vi'
export PAGER='less -e'
export PATH=$PATH:$HOME/scripts

export WORKON_HOME=$HOME/.virtualenvs
source /usr/local/bin/virtualenvwrapper.sh
export PIP_VIRTUALENV_BASE=$WORKON_HOME
export EDITOR=vi
export PATH="$PATH:$HOME/bin:$HOME/.cabal/bin:/var/lib/gems/1.8/bin"
export BROWSER=/usr/bin/firefox
export CLOJURE_EXT=~/.clojure


export CHHOME=/home/sa/apps/ch6.3.0
export PATH=/home/sa/apps/ch6.3.0/bin:$PATH
export MANPATH=$MANPATH:/home/sa/apps/ch6.3.0/docs/man
</t>
<t tx="sa.20110121142539.1617"></t>
<t tx="sa.20110121142539.1618"></t>
<t tx="sa.20110121142539.1619">
##################################################
# Sanitize - set file/directory owner and	 #
# permissions to normal values (644/755)	 #
##################################################

###### usage: sanitize &lt;file&gt;
function sanitize()
{
  chmod -R u=rwX,go=rX "$@"
  chown -R ${USER}:users "$@"
}

</t>
<t tx="sa.20110121142539.1620">
##################################################
# Recursively fix dir/file permissions on a	 #
# given directory				 #
##################################################

function fix() {
if [ -d $1 ]; then
find $1 -type d -exec chmod 755 {} \;
find $1 -type f -exec chmod 644 {} \;
else
echo "$1 is not a directory."
fi
}</t>
<t tx="sa.20110121142539.1621">##################################################
# Ownership Changes { own file user }		 #
##################################################

function own() { chown -R "$2":"$2" ${1:-.}; }
</t>
<t tx="sa.20110121142539.1622">
##################################################
# Xchown something				 #
##################################################

function xchown() {
	# copyright 2007 - 2010 Christopher Bratusek
	user="$1"
	shift
	for df in "$@";
		do su -c "chown -R $user:$user \"$df\"";
	done
}

</t>
<t tx="sa.20110121142539.1623">

##################################################
# Set permissions to "standard" values (644/755),#
# recursive					 #
##################################################

###### Usage: resetp
function resetp() {
    chmod -R u=rwX,go=rX "$@"
}
</t>
<t tx="sa.20110121142539.1624"></t>
<t tx="sa.20110121142539.1625">##################################################
# Edit files in place to ensure Unix line-	 #
# endings					 #
##################################################

function fixlines() { /usr/bin/perl -pi~ -e 's/\r\n?/\n/g' "$@" ; }

</t>
<t tx="sa.20110121142539.1626">##################################################
# Delete function				 #
##################################################

function del()
{
    mv "$@" "/${HOME}/.local/share/Trash/files/"
}



function delete() {
    DIR=$1
    shift
    for i in $*; do
        if [ -f $DIR/$i ]; then
            rm $DIR/$i
        fi
    done
}


##################################################
# Moves specified files to ~/.Trash		 #
##################################################

###### will not overwrite files that have the same name
function trashit()
{   local trash_dir=$HOME/.Trash
    for file in "$@" ; do
        if [[ -d $file ]] ; then
            local already_trashed=$trash_dir/`basename $file`
            if [[ -n `/bin/ls -d $already_trashed*` ]] ; then
                local count=`/bin/ls -d $already_trashed* | /usr/bin/wc -l`
                count=$((++count))
                /bin/mv --verbose "$file" "$trash_dir/$file$count"
                continue
            fi
        fi
        /bin/mv --verbose --backup=numbered "$file" $HOME/.Trash
    done
}</t>
<t tx="sa.20110121142539.1627">##################################################
# Cp with progress bar (using pv)		 #
##################################################

function cp_p() {
	if [ `echo "$2" | grep ".*\/$"` ]
	then
		pv "$1" &gt; "$2""$1"
	else
		pv "$1" &gt; "$2"/"$1"
	fi
}</t>
<t tx="sa.20110121142539.1628">##################################################
# Creates a backup of the file passed as	 #
# parameter with the date and time		 #
##################################################

function bak()
{
  cp $1 $1_`date +%H:%M:%S_%d-%m-%Y`
}</t>
<t tx="sa.20110121142539.1629">###### lowercase all files in the current directory
function lcfiles() {
	print -n 'Really lowercase all files? (y/n) '
	if read -q ; then
		for i in * ; do
			mv $i $i:l
	done
	fi
}
</t>
<t tx="sa.20110121142539.1630">###### move filenames to lowercase
function lowercase()
{
    for file ; do
        filename=${file##*/}
        case "$filename" in
        */*) dirname==${file%/*} ;;
        *) dirname=.;;
        esac
        nf=$(echo $filename | tr A-Z a-z)
        newname="${dirname}/${nf}"
        if [ "$nf" != "$filename" ]; then
            mv "$file" "$newname"
            echo "lowercase: $file --&gt; $newname"
        else
            echo "lowercase: $file not changed."
        fi
    done
}</t>
<t tx="sa.20110121142539.1631">###### Space removal and lowercases folders in current dir.
function rmspaces() {
    ls | while read -r FILE
        do
        mv -v "$FILE" `echo $FILE | tr ' ' '_' | tr -d '[{}(),\!]' | tr -d "\'" | tr '[A-Z]' '[a-z]' | sed 's/_-_/_/g'`
        done
}
</t>
<t tx="sa.20110121142539.1632">###### sort lines in a text file
function linesort()
{
sort -u "$1" &gt; "$1".new
}</t>
<t tx="sa.20110121142539.1633">###### remove duplicate lines in a file (without resorting)
function removeduplines()
{
awk '!x[$0]++' "$1" &gt; "$1".new
}</t>
<t tx="sa.20110121142539.1634">##################################################
# Save a file to ~/Temp				 #
##################################################

function saveit() {
cp $1 ${HOME}/tmp/${1}.saved
}

</t>
<t tx="sa.20110121142539.1635">##################################################
# Make a backup before editing a file		 #
##################################################

function safeedit() {
cp $1 ${1}.backup &amp;&amp; vim $1
}

</t>
<t tx="sa.20110121142539.1636">##################################################
# Show the contents of a file, including 	 #
# additional useful info			 #
##################################################

function showfile()
{
width=72
for input
do
  lines="$(wc -l &lt; $input | sed 's/ //g')"
  chars="$(wc -c &lt; $input | sed 's/ //g')"
  owner="$(ls -ld $input | awk '{print $3}')"
  echo "-----------------------------------------------------------------"
  echo "File $input ($lines lines, $chars characters, owned by $owner):"
  echo "-----------------------------------------------------------------"
  while read line
    do
      if [ ${#line} -gt $width ] ; then
        echo "$line" | fmt | sed -e '1s/^/  /' -e '2,$s/^/+ /'
      else
        echo "  $line"
      fi
    done &lt; $input
  echo "-----------------------------------------------------------------"
done | more
}</t>
<t tx="sa.20110121142539.1637">##################################################
# To examine lots of files and potentially move  #
# them to a common directory			 #
##################################################

###### ex:	tmv -s /mnt/disk/5k
# ex:	make a playlist
# ex:	tmv eye-of-the-tiger.mp3 #  &lt;-&gt; mv eye-of-the-tiger.mp3 /mnt/disk/5k
function tmv() {
        if [ "$1" = "-s" -o "$1" = "--set-target" ]; then
                MOVE_TARGET="$(realpath $2)";
        elif [ "$1" = "-h" -o "$1" = "--help" ]; then
                echo "usage: tmv [-s|--set-target &lt;dir&gt;] | &lt;mv args&gt; &lt;files&gt;";
        else
                mv --target-directory "$MOVE_TARGET" "$@";
        fi
}
</t>
<t tx="sa.20110121142539.1638">##################################################
# Changes spaces to underscores in names	 #
##################################################

function underscore()
{
	for f in * ; do
    	[ "${f}" != "${f// /_}" ]
		mv -- "${f}" "${f// /_}"
	done
}</t>
<t tx="sa.20110121142539.1639">
##################################################
# Run a command, redirecting output to a file, 	 #
# then edit the file with vim			 #
##################################################

function vimcmd() { $1 &gt; $2 &amp;&amp; vim $2; }

</t>
<t tx="sa.20110121142539.1640">

##################################################
# Overwrite a file with zeros			 #
##################################################

function zero() {
        case "$1" in
                "")     echo "Usage: zero &lt;file&gt;"

                        return -1;
        esac
        filesize=`wc -c  "$1" | awk '{print $1}'`
        `dd if=/dev/zero of=$1 count=$filesize bs=1`
}
</t>
<t tx="sa.20110121142539.1641"></t>
<t tx="sa.20110121142539.1642">




##################################################
# Advanced ls functions				 #
##################################################

function la() {
	# copyright 2007 - 2010 Christopher Bratusek
	ls -A --group-directories-first "$@"
}



function lg() {
	# copyright 2007 - 2010 Christopher Bratusek
	if [[ "$@" == "" ]]; then
		$@="*"
	fi
	ls -l --group-directories-first "$@" | gawk '{print $9, "belongs to Group -&gt;", $4}' | column -t
}



function ll() {
	# copyright 2007 - 2010 Christopher Bratusek
	ls -l --group-directories-first "$@"
}



###### Counts files, subdirectories and directory size and displays details
# about files depending on the available space
function lls() {
	# count files
	echo -n "&lt;`find . -maxdepth 1 -mindepth 1 -type f | wc -l | tr -d '[:space:]'` files&gt;"
	# count sub-directories
	echo -n " &lt;`find . -maxdepth 1 -mindepth 1 -type d | wc -l | tr -d '[:space:]'` dirs/&gt;"
	# count links
	echo -n " &lt;`find . -maxdepth 1 -mindepth 1 -type l | wc -l | tr -d '[:space:]'` links@&gt;"
	# total disk space used by this directory and all subdirectories
	echo " &lt;~`du -sh . 2&gt; /dev/null | cut -f1`&gt;"
	ROWS=`stty size | cut -d' ' -f1`
	FILES=`find . -maxdepth 1 -mindepth 1 |
	wc -l | tr -d '[:space:]'`
	# if the terminal has enough lines, do a long listing
	if [ `expr "${ROWS}" - 6` -lt "${FILES}" ]; then
		ls
	else
		ls -hlAF --full-time
	fi
}



function lo() {
	# copyright 2007 - 2010 Christopher Bratusek
	if [[ "$@" == "" ]]; then
		$@="*"
	fi
	ls -l --group-directories-first "$@" | gawk '{print $9, "belongs to User -&gt;", $3}' | sed -e '1d' | column -t
}



function l1() {
	# copyright 2007 - 2010 Christopher Bratusek
	ls -1 --group-directories-first "$@"
}




function lm() {
	# copyright 2007 - 2010 Christopher Bratusek
	if [[ ! "$@" == "" ]]; then
		for file in "$@"; do
			stat -c "%A %a %n" "$file" | gawk '{print "Permissions of:", $3, "-&gt;", $1, "("$2")"}'
		done | column -t
	fi
}



###### inspired by http://tldp.org/HOWTO/Bash-Prompt-HOWTO/x279.html
# but I made it a single awk instead of an awk, forloop and a bc
# asumes we have awk available.  but really, who doesnt have awk?
# let's get the size of the files in this dir
function lsbytes() {
    echo -n $(ls -l | awk '/^-/{total += $5} END{printf "%.2f", total/1048576}')
}



function lscd() {
	# copyright 2007 - 2010 Christopher Bratusek
	builtin cd "${@}" &amp;&gt;/dev/null
	. $BSNG_RC_DIR/dirinfo/display
	dirinfo_display
	echo -e "${epink}content:"
	ls $LSCD_OPTS
	echo "$PWD" &gt; $HOME/.lastpwd
}



###### display long list of files with the given extension
# example: lsext txt
function lsext()
{
find . -type f -iname '*.'${1}'' -exec ls -l {} \; ;
}



###### another way to call for a list of files/folders
function lsr() { /bin/ls -l "$@"/..namedfork/rsrc ; }

</t>
<t tx="sa.20110121142539.1643">##################################################
# Size of items in directory			 #
##################################################

function dubigf() {
  du -sh * | awk '/[[:space:]]*[[:digit:]]+,*[[:digit:]]*G/' | sort -nr
  du -sh * | awk '/[[:space:]]*[[:digit:]]+,*[[:digit:]]*M/' | sort -nr
}


</t>
<t tx="sa.20110121142539.1644">##################################################
# Change directory and list files		 #
##################################################

function cds() {
    # only change directory if a directory is specified
    [ -n "${1}" ] &amp;&amp; cd $1
    lls
}
</t>
<t tx="sa.20110121142539.1645">##################################################
# Size of directories in MB			 #
##################################################

function ds()
{
    echo "size of directories in MB"
    if [ $# -lt 1 ] || [ $# -gt 2 ]; then
        echo "you did not specify a directy, using pwd"
        DIR=$(pwd)
        find $DIR -maxdepth 1 -type d -exec du -sm \{\} \; | sort -nr
    else
        find $1 -maxdepth 1 -type d -exec du -sm \{\} \; | sort -nr
    fi
}</t>
<t tx="sa.20110121142539.1646">


##################################################
# Makes directory then moves into it		 #
##################################################

function mkcdr() {
    mkdir -p -v $1
    cd $1
}



function mkdircd()	{ mkdir -p "$@" &amp;&amp; eval cd "\"\$$#\""; }

</t>
<t tx="sa.20110121142539.1647">##################################################
# Substitutes underscores for blanks in all the  #
# filenames in a directory			 #
##################################################

function blank_rename()
{
ONE=1                     # For getting singular/plural right (see below).
number=0                  # Keeps track of how many files actually renamed.
FOUND=0                   # Successful return value.
for filename in *         #Traverse all files in directory.
do
     echo "$filename" | grep -q " "         #  Check whether filename
     if [ $? -eq $FOUND ]                   #+ contains space(s).
     then
       fname=$filename                      # Yes, this filename needs work.
       n=`echo $fname | sed -e "s/ /_/g"`   # Substitute underscore for blank.
       mv "$fname" "$n"                     # Do the actual renaming.
       let "number += 1"
     fi
done
if [ "$number" -eq "$ONE" ]                 # For correct grammar.
then
 echo "$number file renamed."
else
 echo "$number files renamed."
fi
}</t>
<t tx="sa.20110121142539.1648"></t>
<t tx="sa.20110121142539.1649"></t>
<t tx="sa.20110121142539.1650">
##################################################
# Search and replace words/phrases from text file#
##################################################

###### usage:	searchnreplace "whatever oldtext" "whatever newtext" "file(s) to act on"
function searchnreplace()
{
# Store old text and new text in variables
old=$1;
new=$2;
# Shift positional parameters to places to left (get rid of old and
# new from command line)
shift;
shift;
# Store list of files as a variable
files=$@;
a='';
for a in $files
 do
  temp=$(echo "/tmp/$LOGNAME-$a");
# echo "$temp";
  echo -n ".";
  sed -e "s/$old/$new/g" $a &gt; $temp;
  mv $temp $a;
 done
echo;
echo -e "Searched $# files for '$old' and replaced with '$new'";
}
</t>
<t tx="sa.20110121142539.1651">##################################################
# Find a file(s) ...				 #
##################################################

###### ... with pattern $1 in name and Execute $2 on it
function fe() { find . -type f -iname '*'$1'*' -exec "${2:-file}" {} \;  ; }



###### ... under the current directory
function ff() { /usr/bin/find . -name "$@" ; }



###### ... whose name ends with a given string
function ffe() { /usr/bin/find . -name '*'"$@" ; }



###### ... whose name starts with a given string
function ffs() { /usr/bin/find . -name "$@"'*' ; }



###### ... larger than a certain size (in bytes)
function find_larger() { find . -type f -size +${1}c ; }



###### find a file with a pattern in name in the local directory
function fp()
{
    find . -type f -iname '*'$*'*' -ls ;
}


###### ... who is the newest file in a directory
function newest() { find ${1:-\.} -type f |xargs ls -lrt ; }
</t>
<t tx="sa.20110121142539.1652">###### find pattern in a set of files and highlight them
function fstr()
{
    OPTIND=1
    local case=""
    local usage="fstr: find string in files.
Usage: fstr [-i] \"pattern\" [\"filename pattern\"] "
    while getopts :it opt
    do
        case "$opt" in
        i) case="-i " ;;
        *) echo "$usage"; return;;
        esac
    done
    shift $(( $OPTIND - 1 ))
    if [ "$#" -lt 1 ]; then
        echo "$usage"
        return;
    fi
    local SMSO=$(tput smso)
    local RMSO=$(tput rmso)
    find . -type f -name "${2:-*}" -print0 | xargs -0 grep -sn ${case} "$1" 2&gt;&amp;- | \
sed "s/$1/${SMSO}\0${RMSO}/gI" | more
}



###### searches through the text of all the files in your current directory
# http://seanp2k.com/?p=13
# Good for debugging a PHP script you didn't write and can't trackdown where MySQL connect string actually is
# function grip() {
# grep -ir "$1″ "$PWD"
# }

##################################################
# Find in file and ( AND relation )		 #
##################################################

# Will search PWD for text files that contain $1 AND $2 AND $3 etc...
# Actually it does the same as grep word1|grep word2|grep word3 etc, but in a more elegant way.
function ffa() { (($# &lt; 2)) &amp;&amp; { echo "usage: ffa pat1 pat2 [...]" &gt;&amp;2; return 1; };awk "/$1/$(printf "&amp;&amp;/%s/" "${@:2}")"'{ print FILENAME ":" $0 }' *; }

</t>
<t tx="sa.20110121142539.1653">##################################################
# Print the corresponding error message		 #
##################################################

function strerror() { python -c "import os; print os.strerror($1)"; }
</t>
<t tx="sa.20110121142539.1654"></t>
<t tx="sa.20110121142539.1655">##################################################
# Extract a particular column of space-		 #
# separated output				 #
##################################################

###### e.g.: lsof | getcolumn 0 | sort | uniq
function getcolumn() { perl -ne '@cols = split; print "$cols['$1']\n"' ; }



</t>
<t tx="sa.20110121142539.1656">##################################################
# Create box of '#' characters around given 	 #
# string					 #
##################################################

function box() { t="$1xxxx";c=${2:-#}; echo ${t//?/$c}; echo "$c $1 $c"; echo ${t//?/$c}; }

</t>
<t tx="sa.20110121142539.1657">
##################################################
# Computes most frequent used words of text file #
##################################################

###### usage:	most_frequent "file.txt"
function most_frequent()
{
cat "$1" | tr -cs "[:alnum:]" "\n"| tr "[:lower:]" "[:upper:]" | awk '{h[$1]++}END{for (i in h){print h[i]" "i}}'|sort -nr | cat -n | head -n 30
}

</t>
<t tx="sa.20110121142539.1658">
##################################################
# Print a row of characters across the terminal	 #
##################################################

###### Default character is "=", default color is white
function println()
{
echo -n -e "\e[038;05;${2:-255}m";printf "%$(tput cols)s"|sed "s/ /${1:-=}/g"
}</t>
<t tx="sa.20110121142539.1659"></t>
<t tx="sa.20110121142539.1660">##################################################
# Change to specified pkg's documentation dir and#
# display the files				 #
##################################################s

###### Usage: doc
function doc() {
    pushd "/usr/share/doc/$1" &amp;&amp; ls
}

</t>
<t tx="sa.20110121142539.1661">##################################################
# Arch-wiki-docs simple search			 #
##################################################

function archwikisearch() {
	# old version
	# cd /usr/share/doc/arch-wiki/html/
	# grep -i "$1" index.html | sed 's/.*HREF=.\(.*\.html\).*/\1/g' | xargs opera -newpage
	cd /usr/share/doc/arch-wiki/html/
	for i in $(grep -li $1 *)
	do
		STRING=`grep -m1 -o 'wgTitle = "[[:print:]]\+"' $i`
		LEN=${#STRING}
		let LEN=LEN-12
		STRING=${STRING:11:LEN}
		LOCATION="/usr/share/doc/arch-wiki/html/$i"
		echo -e " \E[33m$STRING   \E[37m$LOCATION"
	done
}</t>
<t tx="sa.20110121142539.1662">

###### example:	man2text wipe	=	wipe.txt
function man2text()
{
man "$1" | col -b &gt; ~/man_"$1".txt
}


</t>
<t tx="sa.20110121142539.1663">##################################################
# RTFM function					 #
##################################################

function rtfm() { help $@ || man $@ || $BROWSER "http://www.google.com/search?q=$@"; }
</t>
<t tx="sa.20110121142539.1664"></t>
<t tx="sa.20110121142539.1665">##################################################
# Show computer information of all sorts	 #
# (requires 'gawk': sudo apt-get install gawk)	 #
##################################################

###### machine details
function ii()
{
    echo -e "\n${RED}You are logged onto:$NC " ; hostname
    echo -e "\n${RED}Additionnal information:$NC " ; uname -a
    echo -e "\n${RED}Users logged on:$NC " ; w -h
    echo -e "\n${RED}Current date:$NC " ; date
    echo -e "\n${RED}Machine stat:$NC " ; uptime
    echo -e "\n${RED}Disk space:$NC " ; df -h
    echo -e "\n${RED}Memory stats (in MB):$NC " ;
    if [ "$OS" = "Linux" ]; then
        free -m
    elif [ "$OS" = "Darwin" ]; then
        vm_stat
    fi
    echo -e "\n${RED}IPs:$NC " ; ips
}

</t>
<t tx="sa.20110121142539.1666">##################################################
# Display theme info				 #
##################################################

function themeinfo() {
  if [ `pgrep emerald` ]; then
    echo "  Emerald:    `cat $HOME/.emerald/theme/theme.ini | grep description | awk -F= '{print $2}'`"
  else
    echo "  Metacity:   `gconftool-2 -g /apps/metacity/general/theme`"
  fi
  echo "  GTK:        `gconftool-2 -g /desktop/gnome/interface/gtk_theme`"
  echo "  Icons:      `gconftool-2 -g /desktop/gnome/interface/icon_theme`"
  echo "  Cursor:     `gconftool-2 -g /desktop/gnome/peripherals/mouse/cursor_theme`"
  echo "  Font:       `gconftool-2 -g /desktop/gnome/interface/font_name`"
  echo "  Wallpaper:  `gconftool-2 -g /desktop/gnome/background/picture_filename | xargs basename | cut -d. -f 1`"
  echo
}

</t>
<t tx="sa.20110121142539.1667"></t>
<t tx="sa.20110121142539.1668">##################################################
# Git stuff					 #
##################################################

###### copyright 2007 - 2010 Christopher Bratusek
function git_action() {
	if [[ -d .git ]]; then
		if [[ -f .git/dotest/rebasing ]]; then
			ACTION="rebase"
		elif [[ -f .git/dotest/applying ]]; then
			ACTION="apply"
		elif [[ -f .git/dotest-merge/interactive ]]; then
			ACTION="rebase -i"
		elif [[ -d .git/dotest-merge ]]; then
			ACTION="rebase -m"
		elif [[ -f .git/MERGE_HEAD ]]; then
			ACTION="merge"
		elif [[ -f .git/index.lock ]]; then
			ACTION="locked"
		elif [[ -f .git/BISECT_LOG ]]; then
			ACTION="bisect"
		else	ACTION="nothing"
		fi
		echo $ACTION
	else	echo --
	fi
}



function git_branch() {
	if [[ -d .git ]]; then
		BRANCH=$(git symbolic-ref HEAD 2&gt;/dev/null)
		echo ${BRANCH#refs/heads/}
	else	echo --
	fi
}



function git_bzip() {
	git archive master | bzip2 -9 &gt;"$PWD".tar.bz2
}



function git_e() {
	if [[ "$SVN_USER_ENLIGTENMENT" &amp;&amp; $1 == "-m" ]]; then
		svn co svn+ssh://"$SVN_USER_ENLIGTENMENT"@svn.enlightenment.org/var/svn/$2
	else
		svn co http://svn.enlightenment.org/svn/$2
	fi
}



function git_export() {
	if [[ "$1" != "" ]]; then
		git checkout-index --prefix="$1"/ -a
	fi
}



function git_gnome() {
	if [[ $GIT_USER_GNOME ]]; then
		if [[ $1 == "-m" ]]; then
			git clone git+ssh://$GIT_USER_GNOME@git.gnome.org/git/$2
		elif [[ $1 == "-mb" ]]; then
			git clone -b $3 git+ssh://$GIT_USER_GNOME@git.gnome.org/git/$2
		fi
	fi
	if [[ $1 == "-b" ]]; then
		git clone -b $3 git://git.gnome.org/$2
	else 	git clone git://git.gnome.org/$1
	fi
}



function git_kde() {
	if [[ "$SVN_USER_KDE" ]]; then
		if [[ $1 == "-m" ]]; then
			svn co --user-name="$SVN_USER_KDE" svn+ssh://svn.kde.org/home/kde/trunk/KDE/$2
		elif [[ $1 == "-mb" ]]; then
			svn co --user-name="$SVN_USER_KDE" svn+ssh://svn.kde.org/home/kde/branches/KDE/$2
		fi
	fi
	if [[ $1 == "-b" ]]; then
		svn co svn://svn.kde.org/home/kde/branches/KDE/$2
	else	svn co svn://svn.kde.org/home/kde/trunk/KDE/$2
	fi
}



function git_revision() {
	if [[ -d .git ]]; then
		REVISION=$(git rev-parse HEAD 2&gt;/dev/null)
		REVISION=${REVISION/HEAD/}
		echo ${REVISION:0:6}
	else	echo --
	fi
}



function git_xfce() {
	if [[ $GIT_USER_XFCE ]]; then
		if [[ $1 == "-m" ]]; then
			git clone ssh://$GIT_USER_XFCE@git.xfce.org/git/$2
		elif [[ $1 == "-mb" ]]; then
			git clone -b $3 ssh://$GIT_USER_XFCE@git.xfce.org/git/$2
		fi
	fi
	if [[ $1 == "-b" ]]; then
		git clone -b $3 git://git.xfce.org/$2
	else	git clone git://git.xfce.org/$1
	fi
}



function git_xz() {
	git archive master | xz -9 &gt; "$PWD".tar.xz
}



function gup() {
  git fetch &amp;&amp; git rebase origin/$(git branch | grep '^\*' | cut -d\  -f2)
}
</t>
<t tx="sa.20110121142539.1669">##################################################
# Temporarily add to PATH			 #
##################################################

function apath()
{
    if [ $# -lt 1 ] || [ $# -gt 2 ]; then
        echo "Temporarily add to PATH"
        echo "usage: apath [dir]"
    else
        PATH=$1:$PATH
    fi
}
</t>
<t tx="sa.20110121142539.1670">##################################################
# Grep, grep, grep				 #
##################################################

###### to grep through files found by find, e.g. grepf pattern '*.c'
# note that 'grep -r pattern dir_name' is an alternative if want all files
function grepfind() { find . -type f -name "$2" -print0 | xargs -0 grep "$1" ; }



###### to grep through the /usr/include directory
function grepincl() { (cd /usr/include; find . -type f -name '*.h' -print0 | xargs -0 grep "$1" ) ; }



###### hgrep, hgrepl (I use these so much I miss them not being on my other machines and should copy them over)
function hgrepl() {
history | sed s/.*\ \ // | grep $@
}



function hgrep() {
history | sed s/.*\ \ // | grep $@ | tail -n 30
}



function hhgrep() {
history | egrep "$@" | egrep -v "hgrep $@"
}</t>
<t tx="sa.20110121142539.1671">##################################################
# Common commands piped through grep		 #
##################################################

function aptg()		# debian specific.
{
    if [ $# -lt 1 ] || [ $# -gt 1 ]; then
        echo "search debian package list"
        echo "usage: aptg [program/keyword]"
    else
        apt-cache search $1 | sort | less
    fi
}



###### grep by paragraph instead of by line
function grepp() { [ $# -eq 1 ] &amp;&amp; perl -00ne "print if /$1/i" || perl -00ne "print if /$1/i" &lt; "$2";}



function hgg()
{
    if [ $# -lt 1 ] || [ $# -gt 1 ]; then
        echo "search bash history"
        echo "usage: mg [search pattern]"
    else
        history | grep -i $1 | grep -v hg
    fi
}



function lsofg()
{
    if [ $# -lt 1 ] || [ $# -gt 1 ]; then
        echo "grep lsof"
        echo "usage: losfg [port/program/whatever]"
    else
        lsof | grep -i $1 | less
    fi
}



function psg()
{
    if [ $# -lt 1 ] || [ $# -gt 1 ]; then
        echo "grep running processes"
        echo "usage: psg [process]"
    else
        ps aux | grep USER | grep -v grep
        ps aux | grep -i $1 | grep -v grep
    fi
}
</t>
<t tx="sa.20110121142539.1672"></t>
<t tx="sa.20110121142539.1673"></t>
<t tx="sa.20110121142539.1674">##################################################
# Download all installed deb packages from 	 #
# official repos currently on system		 #
##################################################

function packagelistdl()
{
sudo dpkg --get-selections | awk '{ print $1};' | while read package; do apt-cache show "$package"| wget -c 'http://ae.archive.ubuntu.com/ubuntu/'`sed -ne '/^Filename/s/^Filename: //p'`; done
}</t>
<t tx="sa.20110121142539.1675">##################################################
# Remove apps with style: nuke it from orbit	 #
##################################################

###### You can't stand programs x, y, and z. Remove all trace of their existence by adding this function to your config. It will remove the cruft, the settings, #and such and such. This function doesn't even give a damn about you trying to remove programs that don't exist: it'll just for loop to the next one on #your hit list.
function nuke() { if [ $(whoami) != "root" ] ; then for x in $@; do sudo apt-get autoremove --purge $x; done; else for x in $@; do apt-get autoremove --purge $x; done; fi }

</t>
<t tx="sa.20110121142539.1676">##################################################
# To show Apt Log History			 #
##################################################

function apt-history() {
      case "$1" in
        install)
              cat /var/log/dpkg.log | grep 'install '
              ;;
        upgrade|remove)
              cat /var/log/dpkg.log | grep $1
              ;;
        rollback)
              cat /var/log/dpkg.log | grep upgrade | \
                  grep "$2" -A10000000 | \
                  grep "$3" -B10000000 | \
                  awk '{print $4"="$5}'
              ;;
        *)
              cat /var/log/dpkg.log
              ;;
      esac
}</t>
<t tx="sa.20110121142539.1677">###### search Debian (or Ubuntu) package database (apt) using dpkg
#   $1 = search term (package name)
function sp() { apt-cache search "$1" | grep -i "$1"; }  # search all available</t>
<t tx="sa.20110121142539.1678"></t>
<t tx="sa.20110121142539.1679">##################################################
# Pacman Search					 #
##################################################

function pacsearch() {
       echo -e "$(pacman -Ss $@ | sed \
       -e 's#core/.*#\\033[1;31m&amp;\\033[0;37m#g' \
       -e 's#extra/.*#\\033[0;32m&amp;\\033[0;37m#g' \
       -e 's#community/.*#\\033[1;35m&amp;\\033[0;37m#g' \
       -e 's#^.*/.* [0-9].*#\\033[0;36m&amp;\\033[0;37m#g' )"
}


</t>
<t tx="sa.20110121142539.1680">##################################################
# Ask						 #
##################################################

function ask()
{
    echo -n "$@" '[y/n] ' ; read ans
    case "$ans" in
        y*|Y*) return 0 ;;
        *) return 1 ;;
    esac
}
</t>
<t tx="sa.20110121142539.1681"></t>
<t tx="sa.20110121142539.1682">###### watch the National debt clock
function natdebt()
{
watch -n 10 "wget -q http://www.brillig.com/debt_clock -O - | grep debtiv.gif | sed -e 's/.*ALT=\"//' -e 's/\".*//' -e 's/ //g'"
}




</t>
<t tx="sa.20110121142539.1683">function oneliners()
{
w3m -dump_source http://www.onelinerz.net/random-one-liners/1/ | awk ' /.*&lt;div id=\"oneliner_[0-9].*/ {while (! /\/div/ ) { gsub("\n", ""); getline; }; gsub (/&lt;[^&gt;][^&gt;]*&gt;/, "", $0); print $0}'
}</t>
<t tx="sa.20110121142539.1684">##################################################
# Execute a given Linux command on a group of	 #
# files						 #
##################################################

###### Example: batchexec sh ls		# lists all files that have the extension 'sh'
# Example: batchexec sh chmod 755	# 'chmod 755' all files that have the extension 'sh'
function batchexec()
{
find . -type f -iname '*.'${1}'' -exec ${@:2}  {} \; ;
}</t>
<t tx="sa.20110121142539.1685">

##################################################
# Monitor progress of data through a pipeline	 #
##################################################

function tarcp() {
    if (( $# &gt;= 2 )); then
        echo "copy ${@[1, -2]} =&gt; ${@[-1]}"
        # http://www.ivarch.com/programs/pv.shtml
        if which pv ; then
            tar -c -f - ${@[1, -2]} | pv -t -b -r | tar -x -f - -C ${@[-1]}
        else
            tar -c -v -f - ${@[1, -2]} | tar -x -f - -C ${@[-1]}
        fi
    else
        "error, not enough parameters."
        return 1
    fi
}</t>
<t tx="sa.20110121142539.1686">##################################################
# Roll - archive wrapper			 #
##################################################

###### usage: roll &lt;foo.tar.gz&gt; ./foo ./bar
function roll()
{
  FILE=$1
  case $FILE in
    *.tar.bz2) shift &amp;&amp; tar cjf $FILE $* ;;
    *.tar.gz) shift &amp;&amp; tar czf $FILE $* ;;
    *.tgz) shift &amp;&amp; tar czf $FILE $* ;;
    *.zip) shift &amp;&amp; zip $FILE $* ;;
    *.rar) shift &amp;&amp; rar $FILE $* ;;
  esac
}
</t>
<t tx="sa.20110121142539.1687">
function mktbz() { tar cvjf "${1%%/}.tar.bz2" "${1%%/}/"; }
</t>
<t tx="sa.20110121142539.1688">##################################################
# Creates an archive from directory		 #
##################################################


function mktgz() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }

</t>
<t tx="sa.20110121142539.1689">function mktar() { tar cvf  "${1%%/}.tar"     "${1%%/}/"; }

</t>
<t tx="sa.20110121142539.1690">##################################################
# Escape potential tarbombs			 #
##################################################

function atb() { l=$(tar tf $1); if [ $(echo "$l" | wc -l) -eq $(echo "$l" | grep $(echo "$l" | head -n1) | wc -l) ]; then tar xf $1; else mkdir ${1%.tar.gz} &amp;&amp; tar xf $1 -C ${1%.tar.gz}; fi ; }
</t>
<t tx="sa.20110121142539.1691">##################################################
# Extract - extract most common compression	 #
# types						 #
##################################################

function extract() {
  local e=0 i c
  for i; do
    if [[ -f $i &amp;&amp; -r $i ]]; then
        c=''
        case $i in
          *.t@(gz|lz|xz|b@(2|z?(2))|a@(z|r?(.@(Z|bz?(2)|gz|lzma|xz)))))
                 c='bsdtar xvf' ;;
          *.7z)  c='7z x'       ;;
          *.Z)   c='uncompress' ;;
          *.bz2) c='bunzip2'    ;;
          *.exe) c='cabextract' ;;
          *.gz)  c='gunzip'     ;;
          *.rar) c='unrar x'    ;;
          *.xz)  c='unxz'       ;;
          *.zip) c='unzip'      ;;
          *)     echo "$0: cannot extract \`$i': Unrecognized file extension" &gt;&amp;2; e=1 ;;
        esac
        [[ $c ]] &amp;&amp; command $c "$i"
    else
        echo "$0: cannot extract \`$i': File is unreadable" &gt;&amp;2; e=2
    fi
  done
  return $e
}</t>
<t tx="sa.20110121142539.1692">
##################################################
# Creates a dated tarball			 #
##################################################

function tarball()
{
    name=$1
    shift
    tar zcvf $name-`date +%Y%m%d`.tar.gz "$@"
}

</t>
<t tx="sa.20110121142539.1693">


##################################################
# To create a ZIP archive of a file or folder	 #
##################################################

function zipf() { zip -r "$1".zip "$1" ; }
</t>
<t tx="sa.20110121142539.1694">##################################################
# Pull a single file out of a .tar.gz		 #
##################################################

function pullout() {
  if [ $# -ne 2 ]; then
    echo "need proper arguments:"
    echo "pullout [file] [archive.tar.gz]"
    return 1
  fi
  case $2 in
    *.tar.gz|*.tgz)
    gunzip &lt; $2 | tar -xf - $1
    ;;
    *)
    echo $2 is not a valid archive
    return 1
    ;;
  esac
  return 0
}
</t>
<t tx="sa.20110121142539.1695">##################################################
# Network information and IP address stuff	 #
##################################################

###### clear iptables rules safely
function clearIptables()
{
iptables -P INPUT ACCEPT; iptables -P FORWARD ACCEPT; iptables -P OUTPUT ACCEPT; iptables -F; iptables -X; iptables -L
}



###### find an unused unprivileged TCP port
function findtcp()
{
(netstat  -atn | awk '{printf "%s\n%s\n", $4, $4}' | grep -oE '[0-9]*$'; seq 32768 61000) | sort -n | uniq -u | head -n 1
}



###### geoip lookup (need geoip database: sudo apt-get install geoip-bin)
function geoip() {
geoiplookup $1
}



###### geoip information
# requires 'html2text': sudo apt-get install html2text
function geoiplookup() { curl -A "Mozilla/5.0" -s "http://www.geody.com/geoip.php?ip=$1" | grep "^IP.*$1" | html2text; }



###### get IP address of a given interface
# Example: getip lo
# Example: getip eth0	# this is the default
function getip()		{ lynx -dump http://whatismyip.org/; }



###### display private IP
function ippriv()
{
    ifconfig eth0|grep "inet adr"|awk '{print $2}'|awk -F ':' '{print $2}'
}



###### ifconfig connection check
function ips()
{
    if [ "$OS" = "Linux" ]; then
        for i in $( /sbin/ifconfig | grep ^e | awk '{print $1}' | sed 's/://' ); do echo -n "$i: ";  /sbin/ifconfig $i | perl -nle'/dr:(\S+)/ &amp;&amp; print $1'; done
    elif [ "$OS" = "Darwin" ]; then
        for i in $( /sbin/ifconfig | grep ^e | awk '{print $1}' | sed 's/://' ); do echo -n "$i: ";  /sbin/ifconfig $i | perl -nle'/inet (\S+)/ &amp;&amp; print $1'; done
    fi
}



###### geolocate a given IP address
function ip2loc() { wget -qO - www.ip2location.com/$1 | grep "&lt;span id=\"dgLookup__ctl2_lblICountry\"&gt;" | sed 's/&lt;[^&gt;]*&gt;//g; s/^[\t]*//; s/&amp;quot;/"/g; s/&lt;/&lt;/g; s/&gt;/&gt;/g; s/&amp;amp;/\&amp;/g'; }



###### myip - finds your current IP if your connected to the internet
function myip()
{
lynx -dump -hiddenlinks=ignore -nolist http://checkip.dyndns.org:8245/ | awk '{ print $4 }' | sed '/^$/d; s/^[ ]*//g; s/[ ]*$//g'
}



###### netinfo - shows network information for your system
function netinfo()
{
echo "--------------- Network Information ---------------"
/sbin/ifconfig | awk /'inet addr/ {print $2}'
/sbin/ifconfig | awk /'Bcast/ {print $3}'
/sbin/ifconfig | awk /'inet addr/ {print $4}'
/sbin/ifconfig | awk /'HWaddr/ {print $4,$5}'
myip=`lynx -dump -hiddenlinks=ignore -nolist http://checkip.dyndns.org:8245/ | sed '/^$/d; s/^[ ]*//g; s/[ ]*$//g' `
echo "${myip}"
echo "---------------------------------------------------"
}



###### show ip
# copyright 2007 - 2010 Christopher Bratusek
function show_ip()
{
	case $1 in
		*help | "" )
			echo -e "\n${ewhite}Usage:\n"
			echo -e "${eorange}show_ip${ewhite} |${egreen} &lt;interface&gt; ${eiceblue}[show ip-address for &lt;interface&gt;]\
			\n${eorange}show_ip${ewhite} |${egreen} external${eiceblue} [show external ip address]\n"
			tput sgr0
		;;
		*external )
			wget -q -O - http://showip.spamt.net/
		;;
		* )
			LANG=C /sbin/ifconfig $1 | grep 'inet addr:' | cut -d: -f2 | gawk '{ print $1}'
		;;
	esac
}



###### display the ttl of a hostname in a human readable form
function ttl()
{
/usr/sbin/timetrans -count $(dig +noquestion +noadditional +noauthority $1 | grep "^$1" | awk '{print $2}')
}



###### show Url information
# Usage:	url-info "ur"
# This script is part of nixCraft shell script collection (NSSC)
# Visit http://bash.cyberciti.biz/ for more information.
# Modified by Silviu Silaghi (http://docs.opensourcesolutions.ro) to handle
# more ip adresses on the domains on which this is available (eg google.com or yahoo.com)
# Last updated on Sep/06/2010
function url-info()
{
doms=$@
if [ $# -eq 0 ]; then
echo -e "No domain given\nTry $0 domain.com domain2.org anyotherdomain.net"
fi
for i in $doms; do
_ip=$(host $i|grep 'has address'|awk {'print $4'})
if [ "$_ip" == "" ]; then
echo -e "\nERROR: $i DNS error or not a valid domain\n"
continue
fi
ip=`echo ${_ip[*]}|tr " " "|"`
echo -e "\nInformation for domain: $i [ $ip ]\nQuerying individual IPs"
 for j in ${_ip[*]}; do
echo -e "\n$j results:"
whois $j |egrep -w 'OrgName:|City:|Country:|OriginAS:|NetRange:'
done
done
}
</t>
<t tx="sa.20110121142539.1696">
##################################################
# Scans a port, returns what's on it.		 #
##################################################

function port() {
lsof -i :"$1"
}



##################################################
# Portscan in one line				 #
##################################################

function portscan()
{
$HOST=127.0.0.1;for((port=1;port&lt;=65535;++port));do echo -en "$port ";if echo -en "open $HOST $port\nlogout\quit" | telnet 2&gt;/dev/null | grep 'Connected to' &gt; /dev/null;then echo -en "\n\nport $port/tcp is open\n\n";fi;done
}
</t>
<t tx="sa.20110121142539.1697">###### takes a name of a color and some text and then echoes out the text in the named color
# Usage:	colorize_text "color" "whatever text"
function colorize-text()
{
b='[0;30m'
# Implement command-line options
while getopts "nr" opt
 do
  case $opt in
   n  )  o='-n' ;;
   r  )  b=''   ;;
  esac
 done
shift $(($OPTIND - 1))
# Set variables
col=$1
shift
text="$*"
# Set a to console color code
case $col in
 'black'  ) a='[0;30m' ;;
 'blue'   ) a='[0;34m' ;;
 'green'  ) a='[0;32m' ;;
 'cyan'   ) a='[0;36m' ;;
 'red'    ) a='[0;31m' ;;
 'purple' ) a='[0;35m' ;;
 'brown'  ) a='[0;33m' ;;
 'ltgray' ) a='[0;37m' ;;
 'white'  ) a='[1;30m' ;;
 'ltblue' ) a='[1;34m' ;;
 'ltgreen') a='[1;32m' ;;
 'ltcyan' ) a='[1;36m' ;;
 'ltred'  ) a='[1;31m' ;;
 'pink'   ) a='[1;35m' ;;
 'yellow' ) a='[1;33m' ;;
 'gray'   ) a='[1;37m' ;;
esac
# Display text in designated color, no newline
echo -en "\033$a$text"
# If 'b' switch not on, restore color to black
if [ -n $b ]
 then
  echo -en "\033$b"
fi
# If 'n' switch on, do not display final newline
# otherwise output newline
echo $o
}



###### shows the colors in a kewl way...partially stolen from HH
function colors()
{
       # Display ANSI colours.
    esc="\033["
    echo -e "\t  40\t   41\t   42\t    43\t      44       45\t46\t 47"
    for fore in 30 31 32 33 34 35 36 37; do
        line1="$fore  "
        line2="    "
        for back in 40 41 42 43 44 45 46 47; do
            line1="${line1}${esc}${back};${fore}m Normal  ${esc}0m"
            line2="${line2}${esc}${back};${fore};1m Bold    ${esc}0m"
        done
        echo -e "$line1\n$line2"
    done
    echo ""
    echo "# Example:"
    echo "#"
    echo "# Type a Blinkin TJEENARE in Swedens colours (Yellow on Blue)"
    echo "#"
    echo "#           ESC"
    echo "#            |  CD"
    echo "#            |  | CD2"
    echo "#            |  | | FG"
    echo "#            |  | | |  BG + m"
    echo "#            |  | | |  |         END-CD"
    echo "#            |  | | |  |            |"
    echo "# echo -e '\033[1;5;33;44mTJEENARE\033[0m'"
    echo "#"
    echo "# Sedika Signing off for now ;-&gt;"
}



###### displays all 256 possible background colors, using ANSI escape sequences.
# author: Chetankumar Phulpagare
# used in ABS Guide with permission.
function colors2()
{
T1=8
T2=6
T3=36
offset=0
for num1 in {0..7}
do {
   for num2 in {0,1}
       do {
          shownum=`echo "$offset + $T1 * ${num2} + $num1" | bc`
          echo -en "\E[0;48;5;${shownum}m color ${shownum} \E[0m"
          }
       done
   echo
   }
done
offset=16
for num1 in {0..5}
do {
   for num2 in {0..5}
       do {
          for num3 in {0..5}
              do {
                 shownum=`echo "$offset + $T2 * ${num3} \
                 + $num2 + $T3 * ${num1}" | bc`
                 echo -en "\E[0;48;5;${shownum}m color ${shownum} \E[0m"
                 }
               done
          echo
          }
       done
}
done
offset=232
for num1 in {0..23}
do {
   shownum=`expr $offset + $num1`
   echo -en "\E[0;48;5;${shownum}m ${shownum}\E[0m"
}
done
echo
}



###### print all 256 colors for testing TERM or for a quick reference
# show numerical values for each of the 256 colors in bash
function colors2nums()
{
for code in {0..255}; do echo -e "\e[38;05;${code}m $code: Test"; done
}

</t>
<t tx="sa.20110121142539.1698"></t>
<t tx="sa.20110121142539.1699">##################################################
# Lookup a word with dict.org			 #
##################################################

###### define "whatever"
function dic() { curl dict://dict.org/d:"$@" ; }



###### find matches of $1, with optional strat $2 and optional db $3
function ref()
{
    if [[ -z $3 ]]; then
        curl dict://dict.org/m:${1}:english:${2};
    else
        curl dict://dict.org/m:${1}:${3}:${2};
    fi
}



###### look in Webster
function webster() { curl dict://dict.org/d:${1}:web1913; }



###### look in WordNet
function wordnet() { curl dict://dict.org/d:${1}:wn; }</t>
<t tx="sa.20110121142539.1700">##################################################
###### command line way to get the stock quote via Yahoo
function stock()
{
curl -s 'http://download.finance.yahoo.com/d/quotes.csv?s=csco&amp;f=l1'
}


</t>
<t tx="sa.20110121142539.1701">##################################################
# User friendly ps				 #
##################################################

function my_ps() { ps $@ -u $USER -o pid,%cpu,%mem,bsdtime,command ; }



function pp() { my_ps f | awk '!/awk/ &amp;&amp; $0~var' var=${1:-".*"} ; }



function psaux() {
    [ $# == 1 ] &amp;&amp; ps aux | grep $1
}



</t>
<t tx="sa.20110121142539.1702">##################################################
# Find out the pid of a specified process	 #
##################################################

######  note that the command name can be specified via a regex
#    E.g. findPid '/d$/' finds pids of all processes with names ending in 'd'
#    Without the 'sudo' it will only find processes of the current user
function findPid() { sudo /usr/sbin/lsof -t -c "$@" ; }

</t>
<t tx="sa.20110121142539.1703">

##################################################
# Easily run a program in the background without #
# losing output	 				 #
##################################################

function fork() { tf=$(tempfile -d /tmp -p $1.);echo -n "$tf "; $@ &amp;&gt;$tf&amp; }

</t>
<t tx="sa.20110121142539.1704">##################################################
# Kill a process by name			 #
##################################################

###### example: killps firefox-bin
function killps()
{
    local pid pname sig="-TERM" # default signal
    if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
        echo "Usage: killps [-SIGNAL] pattern"
        return;
    fi
    if [ $# = 2 ]; then sig=$1 ; fi
    for pid in $(myps | nawk '!/nawk/ &amp;&amp; $0~pat { print $2 }' pat=${!#}) ; do
        pname=$(myps | nawk '$2~var { print $6 }' var=$pid )
        if ask "Kill process $pid &lt;$pname&gt; with signal $sig ? "
            then kill $sig $pid
        fi
    done
}



###### example: pskill firefox-bin
# copyright 2007 - 2010 Christopher Bratusek
function psgrep() {
	if [[ $1 == "-u" ]]; then
		ps aux | grep -v grep | grep $2 | awk '{ print $2 " : " $11}' | tee .temp
		CMDS=$(cat .temp)
	elif [[ $1 != "" ]]; then
		ps aux | grep -v grep | grep "$1" | awk '{ print $11 " : " $2 " : " $1 }' | tee .temp
		CMDS=$(cat .temp)
	fi
	if [[ $CMDS == "" ]]; then
		echo "no matching process"
	fi
	rm -f .temp
}



function pskill() {
	if [[ $1 ]]; then
		psgrep $1
		shift
		if [[ $CMDS != "" ]]; then
			echo -e "\nenter process number to kill:\n"
			read ID
			if [[ ! $ID == 0 || ! $ID == "" ]]; then
				kill $@ $ID
			fi
		fi
	fi
}

</t>
<t tx="sa.20110121142539.1705">

##################################################
# Run command detached from terminal and without #
# output					 #
##################################################

###### Usage: nh
function nh() {
    nohup "$@" &amp;&gt;/dev/null &amp;
}

</t>
<t tx="sa.20110121142539.1706">
##################################################
# Open a GUI app from CLI			 #
##################################################

function open() {
  $1 &gt;/dev/null 2&gt;&amp;1 &amp;
}

</t>
<t tx="sa.20110121142539.1707">

##################################################
# Run program on a timer			 #
##################################################

###### Example: program-timer 20 viewnior arg1
function program-timer() { perl -e 'alarm shift; exec @ARGV' "$@" &amp; exit; }

</t>
<t tx="sa.20110121142539.1708">
##################################################
# Progress visuals				 #
##################################################







# Function that outputs dots every second until
# command completes	
function sleeper() { while `ps -p $1 &amp;&gt;/dev/null`; do echo -n "${2:-.}"; sleep ${3:-1}; done; }; export -f sleeper



function progressbar()
# copyright 2007 - 2010 Christopher Bratusek
{
	SP_COLOUR="\e[37;44m"
	SP_WIDTH=5.5
	SP_DELAY=0.2
	SP_STRING=${2:-"'|/=\'"}
	while [ -d /proc/$1 ]
	do
		printf "$SP_COLOUR\e7  %${SP_WIDTH}s  \e8\e[01;37m" "$SP_STRING"
		sleep ${SP_DELAY:-.2}
		SP_STRING=${SP_STRING#"${SP_STRING%?}"}${SP_STRING%?}
	done
	tput sgr0
}



###### please wait...
# copyright 2007 - 2010 Christopher Bratusek
function spanner() {
	PROC=$1;COUNT=0
	echo -n "Please wait "
	while [ -d /proc/$PROC ];do
		while [ "$COUNT" -lt 10 ];do
			echo -ne '\x08  ' ; sleep 0.1
			((COUNT++))
		done
		until [ "$COUNT" -eq 0 ];do
			echo -ne '\x08\x08 ' ; sleep 0.1
			((COUNT -= 1))
		done
	done
}



function spin() {
	# copyright 2007 - 2010 Christopher Bratusek
        echo -n "|/     |"
        while [ -d /proc/$1 ]
        do
        # moving right
        echo -ne "\b\b\b\b\b\b\b-     |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\b\\     |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\b|     |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\b /    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b-    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\\    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b|    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b /   |"
        sleep .05
        echo -ne "\b\b\b\b\b-   |"
        sleep .05
        echo -ne "\b\b\b\b\b\\   |"
        sleep .05
        echo -ne "\b\b\b\b\b|   |"
        sleep .05
        echo -ne "\b\b\b\b\b /  |"
        sleep .05
        echo -ne "\b\b\b\b-  |"
        sleep .05
        echo -ne "\b\b\b\b\\  |"
        sleep .05
        echo -ne "\b\b\b\b|  |"
        sleep .05
        echo -ne "\b\b\b\b / |"
        sleep .05
        echo -ne "\b\b\b- |"
        sleep .05
        echo -ne "\b\b\b\\ |"
        sleep .05
        echo -ne "\b\b\b| |"
        sleep .05
        echo -ne "\b\b\b /|"
        sleep .05
        echo -ne "\b\b-|"
        sleep .05
        echo -ne "\b\b\\|"
        sleep .05
        echo -ne "\b\b||"
        sleep .05
        echo -ne "\b\b/|"
        sleep .05
        # moving left
        echo -ne "\b\b||"
        sleep .05
        echo -ne "\b\b\\|"
        sleep .05
        echo -ne "\b\b-|"
        sleep .05
        echo -ne "\b\b\b/ |"
        sleep .05
        echo -ne "\b\b\b| |"
        sleep .05
        echo -ne "\b\b\b\\ |"
        sleep .05
        echo -ne "\b\b\b- |"
        sleep .05
        echo -ne "\b\b\b\b/  |"
        sleep .05
        echo -ne "\b\b\b\b|  |"
        sleep .05
        echo -ne "\b\b\b\b\\  |"
        sleep .05
        echo -ne "\b\b\b\b-  |"
        sleep .05
        echo -ne "\b\b\b\b\b/   |"
        sleep .05
        echo -ne "\b\b\b\b\b|   |"
        sleep .05
        echo -ne "\b\b\b\b\b\\   |"
        sleep .05
        echo -ne "\b\b\b\b\b-   |"
        sleep .05
        echo -ne "\b\b\b\b\b\b/    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b|    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\\    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b-    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\b/     |"
        sleep .05
        done
	echo -e "\b\b\b\b\b\b\b\b\b|=======| done!"
}



function spinner()
# copyright 2007 - 2010 Christopher Bratusek
{
	PROC=$1
	while [ -d /proc/$PROC ];do
		echo -ne '\e[01;32m/\x08' ; sleep 0.05
		echo -ne '\e[01;32m-\x08' ; sleep 0.05
		echo -ne '\e[01;32m\\\x08' ; sleep 0.05
		echo -ne '\e[01;32m|\x08' ; sleep 0.05
	done
}



###### Display a progress process
# To start the spinner2 function, you have to send the function
# into the background. To stop the spinner2 function, you have
# to define the argument "stop".
# EXAMPLE:
#    echo -n "Starting some daemon "; spinner2 &amp;
#    if sleep 10; then
#       spinner2 "stop"; echo -e "\t[ OK ]"
#    else
#       spinner2 "stop"; echo -e "\t[ FAILED ]"
#    fi
function spinner2() {
      local action=${1:-"start"}
      declare -a sign=( "-" "/" "|" "\\\\" )
      # define singnal file...
      [ "$action" = "start" ] &amp;&amp; echo 1 &gt; /tmp/signal
      [ "$action" = "stop" ] &amp;&amp; echo 0 &gt; /tmp/signal
      while [ "$( cat /tmp/signal 2&gt;/dev/null )" == "1" ] ; do
          for (( i=0; i&lt;${#sign[@]}; i++ )); do
              echo -en "${sign[$i]}\b"
              # with this command you can use millisecond as sleep time - perl rules ;-)
              perl -e 'select( undef, undef, undef, 0.1 );'
          done
      done
      # clear the last ${sign[$i]} sign at finish...
      [ "$action" = "stop" ] &amp;&amp; echo -ne " \b"
}



function working()
# copyright 2007 - 2010 Christopher Bratusek
{
   while [ -d /proc/$1 ]
   do
	echo -ne "w      \b\b\b\b\b\b\b";sleep .08;
	echo -ne "wo     \b\b\b\b\b\b\b";sleep .08;
	echo -ne "wor    \b\b\b\b\b\b\b";sleep .08;
	echo -ne "work   \b\b\b\b\b\b\b";sleep .08;
	echo -ne "worki  \b\b\b\b\b\b\b";sleep .08;
	echo -ne "workin \b\b\b\b\b\b\b";sleep .08;
	echo -ne "working\b\b\b\b\b\b\b";sleep .08;
	echo -ne " orking\b\b\b\b\b\b\b";sleep .08;
	echo -ne "  rking\b\b\b\b\b\b\b";sleep .08;
	echo -ne "   king\b\b\b\b\b\b\b";sleep .08;
	echo -ne "    ing\b\b\b\b\b\b\b";sleep .08;
	echo -ne "     ng\b\b\b\b\b\b\b";sleep .08;
	echo -ne "      g\b\b\b\b\b\b\b";sleep .08;
   done
}
</t>
<t tx="sa.20110121142539.1709">##################################################
# Stupid simple note taker			 #
##################################################

function note()
{
        # if file doesn't exist, create it
        [ -f $HOME/.notes ] || touch $HOME/.notes
        # no arguments, print file
        if [ $# = 0 ]
        then
                cat $HOME/.notes
        # clear file
        elif [ $1 = -c ]
        then
                &gt; $HOME/.notes
        # add all arguments to file
        else
                echo "$@" &gt;&gt; $HOME/.notes
        fi
}

</t>
<t tx="sa.20110121142539.1710">##################################################
# Manage services				 #
##################################################

function service() {
  if [ $# -lt 2 ]; then
    echo "Missing service name or command"
    return 1
  fi
  sudo /etc/init.d/$1 $2 &amp;&amp; return 0
}



###### service() { /etc/rc.d/$1 $2; }
function service_() {
        if [ -n "$2"  ]
        then
                /etc/rc.d/$1 $2
        else
                echo    "All daemons"
                ls --ignore=functions* /etc/rc.d/
                echo    "Running daemons"
                ls /var/run/daemons
        fi
}






##################################################
# Daemon management				 #
##################################################

# function restart() { sudo /etc/rc.d/$1 restart; }



# function start() { sudo /etc/rc.d/$1 start; }



# function stop() { sudo /etc/rc.d/$1 stop; }
</t>
<t tx="sa.20110121142539.1711"></t>
<t tx="sa.20110121142539.1712">##################################################
# Color chart					 #
##################################################

txtblk='\e[0;30m' # Black - Regular
txtred='\e[0;31m' # Red
txtgrn='\e[0;32m' # Green
txtylw='\e[0;33m' # Yellow
txtblu='\e[0;34m' # Blue
txtpur='\e[0;35m' # Purple
txtcyn='\e[0;36m' # Cyan
txtwht='\e[0;37m' # White
bldblk='\e[1;30m' # Black - Bold
bldred='\e[1;31m' # Red
bldgrn='\e[1;32m' # Green
bldylw='\e[1;33m' # Yellow
bldblu='\e[1;34m' # Blue
bldpur='\e[1;35m' # Purple
bldcyn='\e[1;36m' # Cyan
bldwht='\e[1;37m' # White
unkblk='\e[4;30m' # Black - Underline
undred='\e[4;31m' # Red
undgrn='\e[4;32m' # Green
undylw='\e[4;33m' # Yellow
undblu='\e[4;34m' # Blue
undpur='\e[4;35m' # Purple
undcyn='\e[4;36m' # Cyan
undwht='\e[4;37m' # White
bakblk='\e[40m'   # Black - Background
bakred='\e[41m'   # Red
badgrn='\e[42m'   # Green
bakylw='\e[43m'   # Yellow
bakblu='\e[44m'   # Blue
bakpur='\e[45m'   # Purple
bakcyn='\e[46m'   # Cyan
bakwht='\e[47m'   # White
txtrst='\e[0m'    # Text Reset
</t>
<t tx="sa.20110121142539.1714">alias pacclean='sudo yaourt -Scc' 						# clean package cache
alias pacin='sudo yaourt -S'  							# install a specific package
alias pacman='yaourt' 								# switches from Pacman to Yaourt so we can troll the AUR
alias pacout='sudo yaourt -Rs'							# Remove a specific package
alias pacsync='sudo yaourt -Sy'   						# Sync
alias pacup='sudo yaourt -Syu'

</t>
<t tx="sa.20110121142539.1715">alias yr='yaourt -Rs -C'
alias yss='yaourt -Ss -C'
alias ys='yaourt -S -C'
alias ysyu='yaourt -Syu -C'
alias ysy='yaourt -Sy -C'
							</t>
<t tx="sa.20110121142539.1716">##################################################
# Apt-cache stuff				 #
##################################################

alias aptadd='sudo apt-cache add'
alias aptdepends='sudo apt-cache depends'
alias aptdotty='sudo apt-cache dotty'
alias aptdumpavail='sudo apt-cache dumpavail'
alias aptdump='sudo apt-cache dump'
alias aptgencaches='sudo apt-cache gencaches'
alias aptpkgnames='sudo apt-cache pkgnames'
alias aptpolicy='sudo apt-cache policy'
alias aptrdepends='sudo apt-cache rdepends'
alias aptsearch='sudo apt-cache search'
alias aptshowpkg='sudo apt-cache showpkg'
alias aptshowsrc='sudo apt-cache showsrc'
alias aptshow='sudo apt-cache show'
alias aptstats='sudo apt-cache stats'
alias aptunmet='sudo apt-cache unmet'
alias aptxvcg='sudo apt-cache xvcg'

</t>
<t tx="sa.20110121142539.1717">##################################################
# Apt-get stuff					 #
##################################################

alias autoremove='sudo apt-get autoremove'
alias check='sudo apt-get check'
alias dist-upgrade='sudo apt-get dist-upgrade'
alias dselect-upgrade='sudo apt-get dselect-upgrade'
alias source='sudo apt-get source'


</t>
<t tx="sa.20110121142539.1718">##################################################
# Apt-history Stuff				 #
##################################################

alias historya='apt-history'
alias historyi='apt-history install'
alias historyre='apt-history remove'
alias historyro='apt-history rollback'
alias historyu='apt-history upgrade'
</t>
<t tx="sa.20110121142539.1719">##################################################
# Aptitude stuff				 #
##################################################

alias autoclean='sudo aptitude autoclean'
alias build-dep='sudo aptitude build-dep'
alias changelog='sudo aptitude changelog'
alias clean='sudo aptitude clean'
alias download='sudo aptitude download'
alias forbid-version='sudo aptitude forbid-version'
alias forget-new='sudo aptitude forget-new'
alias full-upgrade='sudo aptitude full-upgrade'
alias hold='sudo aptitude hold'
alias install='sudo aptitude install'
alias linux-image='sudo aptitude search linux-image'		# linux-image kernel update check
alias markauto='sudo aptitude markauto'
alias purge='sudo aptitude purge'
alias reinstall='sudo aptitude reinstall'
alias remove='sudo aptitude remove'
alias search='sudo aptitude search'
alias show='sudo aptitude show'
alias unhold='sudo aptitude unhold'
alias unmarkauto='sudo aptitude unmarkauto'
alias update='sudo aptitude update'
alias upgrade='sudo aptitude safe-upgrade'
alias why-not='sudo aptitude why-not'
alias why='sudo aptitude why'
</t>
<t tx="sa.20110128155259.1842">@language shell

@others
</t>
<t tx="sa.20110128155259.1843"></t>
<t tx="sa.20110128155259.1844"># If not running interactively, don't do anything
[ -z "$PS1" ] &amp;&amp; return
</t>
<t tx="sa.20110128155259.1845"># don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

</t>
<t tx="sa.20110128155259.1846"># check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize
</t>
<t tx="sa.20110128155259.1847"># make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] &amp;&amp; eval "$(SHELL=/bin/sh lesspipe)"
</t>
<t tx="sa.20110128155259.1848"># set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] &amp;&amp; [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi
</t>
<t tx="sa.20110128155259.1849"># set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
# force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac
</t>
<t tx="sa.20110128155259.1850"># enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors &amp;&amp; eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    # alias dir='dir --color=auto'
    # alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
</t>
<t tx="sa.20110128155259.1851"># enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then
    . /etc/bash_completion
fi
</t>
<t tx="sa.20110128155259.1852"># Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

</t>
<t tx="sa.20110128155259.1853">######################################################################################################################################################
# ALIASES
######################################################################################################################################################

##################################################
# App-specific					 
##################################################

alias wget='wget -c'


##################################################
# Command substitution				
##################################################



alias egrep='egrep –color=auto'
alias fgrep='fgrep –color=auto'
alias grep='grep --color=auto'	# highlight matched pattern


alias more='less'

alias parts='cat /proc/partitions'

alias path='echo -e ${PATH//:/\\n}'


##################################################
# Information					 #
##################################################


alias tree='tree -Cs'	# nice alternative to 'ls'







# will show you all the string (plain text) values in ram			
alias ramvalue='sudo dd if=/dev/mem | cat | strings' 






</t>
<t tx="sa.20110128155259.1854">alias pacclean='sudo yaourt -Scc' 						# clean package cache
alias pacin='sudo yaourt -S'  							# install a specific package
alias pacman='yaourt' 								# switches from Pacman to Yaourt so we can troll the AUR
alias pacout='sudo yaourt -Rs'							# Remove a specific package
alias pacsync='sudo yaourt -Sy'   						# Sync
alias pacup='sudo yaourt -Syu'

</t>
<t tx="sa.20110128155259.1855">alias yr='yaourt -Rs -C'
alias yss='yaourt -Ss -C'
alias ys='yaourt -S -C'
alias ysyu='yaourt -Syu -C'
alias ysy='yaourt -Sy -C'
							</t>
<t tx="sa.20110128155259.1856">##################################################
# Apt-cache stuff				 #
##################################################

alias aptadd='sudo apt-cache add'
alias aptdepends='sudo apt-cache depends'
alias aptdotty='sudo apt-cache dotty'
alias aptdumpavail='sudo apt-cache dumpavail'
alias aptdump='sudo apt-cache dump'
alias aptgencaches='sudo apt-cache gencaches'
alias aptpkgnames='sudo apt-cache pkgnames'
alias aptpolicy='sudo apt-cache policy'
alias aptrdepends='sudo apt-cache rdepends'
alias aptsearch='sudo apt-cache search'
alias aptshowpkg='sudo apt-cache showpkg'
alias aptshowsrc='sudo apt-cache showsrc'
alias aptshow='sudo apt-cache show'
alias aptstats='sudo apt-cache stats'
alias aptunmet='sudo apt-cache unmet'
alias aptxvcg='sudo apt-cache xvcg'

</t>
<t tx="sa.20110128155259.1857">##################################################
# Apt-get stuff
##################################################

alias autoremove='sudo apt-get autoremove'
alias check='sudo apt-get check'
alias dist-upgrade='sudo apt-get dist-upgrade'
alias dselect-upgrade='sudo apt-get dselect-upgrade'
alias source='sudo apt-get source'


</t>
<t tx="sa.20110128155259.1858">##################################################
# Apt-history Stuff				 #
##################################################

alias historya='apt-history'
alias historyi='apt-history install'
alias historyre='apt-history remove'
alias historyro='apt-history rollback'
alias historyu='apt-history upgrade'
</t>
<t tx="sa.20110128155259.1859">##################################################
# Aptitude stuff				 #
##################################################

alias autoclean='sudo aptitude autoclean'
alias build-dep='sudo aptitude build-dep'
alias changelog='sudo aptitude changelog'
alias clean='sudo aptitude clean'
alias download='sudo aptitude download'
alias forbid-version='sudo aptitude forbid-version'
alias forget-new='sudo aptitude forget-new'
alias full-upgrade='sudo aptitude full-upgrade'
alias hold='sudo aptitude hold'
alias install='sudo aptitude install'
alias linux-image='sudo aptitude search linux-image'		# linux-image kernel update check
alias markauto='sudo aptitude markauto'
alias purge='sudo aptitude purge'
alias reinstall='sudo aptitude reinstall'
alias remove='sudo aptitude remove'
alias search='sudo aptitude search'
alias show='sudo aptitude show'
alias unhold='sudo aptitude unhold'
alias unmarkauto='sudo aptitude unmarkauto'
alias update='sudo aptitude update'
alias upgrade='sudo aptitude safe-upgrade'
alias why-not='sudo aptitude why-not'
alias why='sudo aptitude why'
</t>
<t tx="sa.20110128155259.1860"># Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] &amp;&amp; echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//'\'')"'

</t>
<t tx="sa.20110128155259.1861">export BLOCKSIZE=K
export BROWSER='firefox'
export EDITOR='vi'
export PAGER='less -e'
export PATH=$PATH:$HOME/scripts

export WORKON_HOME=$HOME/.virtualenvs
source /usr/local/bin/virtualenvwrapper.sh
export PIP_VIRTUALENV_BASE=$WORKON_HOME
export EDITOR=vi
export PATH="$PATH:$HOME/bin:$HOME/.cabal/bin:/var/lib/gems/1.8/bin"
export BROWSER=/usr/bin/firefox
export CLOJURE_EXT=~/.clojure


export CHHOME=/home/sa/apps/ch6.3.0
export PATH=/home/sa/apps/ch6.3.0/bin:$PATH
export MANPATH=$MANPATH:/home/sa/apps/ch6.3.0/docs/man
</t>
<t tx="sa.20110128155259.1862"></t>
<t tx="sa.20110128155259.1863"></t>
<t tx="sa.20110128155259.1864">
##################################################
# Sanitize - set file/directory owner and	 #
# permissions to normal values (644/755)	 #
##################################################

###### usage: sanitize &lt;file&gt;
function sanitize()
{
  chmod -R u=rwX,go=rX "$@"
  chown -R ${USER}:users "$@"
}

</t>
<t tx="sa.20110128155259.1865">
##################################################
# Recursively fix dir/file permissions on a	 #
# given directory				 #
##################################################

function fix() {
if [ -d $1 ]; then
find $1 -type d -exec chmod 755 {} \;
find $1 -type f -exec chmod 644 {} \;
else
echo "$1 is not a directory."
fi
}</t>
<t tx="sa.20110128155259.1866">##################################################
# Ownership Changes { own file user }		 #
##################################################

function own() { chown -R "$2":"$2" ${1:-.}; }
</t>
<t tx="sa.20110128155259.1867">
##################################################
# Xchown something				 #
##################################################

function xchown() {
	# copyright 2007 - 2010 Christopher Bratusek
	user="$1"
	shift
	for df in "$@";
		do su -c "chown -R $user:$user \"$df\"";
	done
}

</t>
<t tx="sa.20110128155259.1868">

##################################################
# Set permissions to "standard" values (644/755),#
# recursive					 #
##################################################

###### Usage: resetp
function resetp() {
    chmod -R u=rwX,go=rX "$@"
}
</t>
<t tx="sa.20110128155259.1869"></t>
<t tx="sa.20110128155259.1870">##################################################
# Edit files in place to ensure Unix line-	 #
# endings					 #
##################################################

function fixlines() { /usr/bin/perl -pi~ -e 's/\r\n?/\n/g' "$@" ; }

</t>
<t tx="sa.20110128155259.1871">##################################################
# Delete function				 #
##################################################

function del()
{
    mv "$@" "/${HOME}/.local/share/Trash/files/"
}



function delete() {
    DIR=$1
    shift
    for i in $*; do
        if [ -f $DIR/$i ]; then
            rm $DIR/$i
        fi
    done
}


##################################################
# Moves specified files to ~/.Trash		 #
##################################################

###### will not overwrite files that have the same name
function trashit()
{   local trash_dir=$HOME/.Trash
    for file in "$@" ; do
        if [[ -d $file ]] ; then
            local already_trashed=$trash_dir/`basename $file`
            if [[ -n `/bin/ls -d $already_trashed*` ]] ; then
                local count=`/bin/ls -d $already_trashed* | /usr/bin/wc -l`
                count=$((++count))
                /bin/mv --verbose "$file" "$trash_dir/$file$count"
                continue
            fi
        fi
        /bin/mv --verbose --backup=numbered "$file" $HOME/.Trash
    done
}</t>
<t tx="sa.20110128155259.1872">##################################################
# Cp with progress bar (using pv)		 #
##################################################

function cp_p() {
	if [ `echo "$2" | grep ".*\/$"` ]
	then
		pv "$1" &gt; "$2""$1"
	else
		pv "$1" &gt; "$2"/"$1"
	fi
}</t>
<t tx="sa.20110128155259.1873">##################################################
# Creates a backup of the file passed as	 #
# parameter with the date and time		 #
##################################################

function bak()
{
  cp $1 $1_`date +%H:%M:%S_%d-%m-%Y`
}</t>
<t tx="sa.20110128155259.1874">###### lowercase all files in the current directory
function lcfiles() {
	print -n 'Really lowercase all files? (y/n) '
	if read -q ; then
		for i in * ; do
			mv $i $i:l
	done
	fi
}
</t>
<t tx="sa.20110128155259.1875">###### move filenames to lowercase
function lowercase()
{
    for file ; do
        filename=${file##*/}
        case "$filename" in
        */*) dirname==${file%/*} ;;
        *) dirname=.;;
        esac
        nf=$(echo $filename | tr A-Z a-z)
        newname="${dirname}/${nf}"
        if [ "$nf" != "$filename" ]; then
            mv "$file" "$newname"
            echo "lowercase: $file --&gt; $newname"
        else
            echo "lowercase: $file not changed."
        fi
    done
}</t>
<t tx="sa.20110128155259.1876">###### Space removal and lowercases folders in current dir.
function rmspaces() {
    ls | while read -r FILE
        do
        mv -v "$FILE" `echo $FILE | tr ' ' '_' | tr -d '[{}(),\!]' | tr -d "\'" | tr '[A-Z]' '[a-z]' | sed 's/_-_/_/g'`
        done
}
</t>
<t tx="sa.20110128155259.1877">###### sort lines in a text file
function linesort()
{
sort -u "$1" &gt; "$1".new
}</t>
<t tx="sa.20110128155259.1878">###### remove duplicate lines in a file (without resorting)
function removeduplines()
{
awk '!x[$0]++' "$1" &gt; "$1".new
}</t>
<t tx="sa.20110128155259.1879">##################################################
# Save a file to ~/Temp				 #
##################################################

function saveit() {
cp $1 ${HOME}/tmp/${1}.saved
}

</t>
<t tx="sa.20110128155259.1880">##################################################
# Make a backup before editing a file		 #
##################################################

function safeedit() {
cp $1 ${1}.backup &amp;&amp; vim $1
}

</t>
<t tx="sa.20110128155259.1881">##################################################
# Show the contents of a file, including 	 #
# additional useful info			 #
##################################################

function showfile()
{
width=72
for input
do
  lines="$(wc -l &lt; $input | sed 's/ //g')"
  chars="$(wc -c &lt; $input | sed 's/ //g')"
  owner="$(ls -ld $input | awk '{print $3}')"
  echo "-----------------------------------------------------------------"
  echo "File $input ($lines lines, $chars characters, owned by $owner):"
  echo "-----------------------------------------------------------------"
  while read line
    do
      if [ ${#line} -gt $width ] ; then
        echo "$line" | fmt | sed -e '1s/^/  /' -e '2,$s/^/+ /'
      else
        echo "  $line"
      fi
    done &lt; $input
  echo "-----------------------------------------------------------------"
done | more
}</t>
<t tx="sa.20110128155259.1882">##################################################
# To examine lots of files and potentially move  #
# them to a common directory			 #
##################################################

###### ex:	tmv -s /mnt/disk/5k
# ex:	make a playlist
# ex:	tmv eye-of-the-tiger.mp3 #  &lt;-&gt; mv eye-of-the-tiger.mp3 /mnt/disk/5k
function tmv() {
        if [ "$1" = "-s" -o "$1" = "--set-target" ]; then
                MOVE_TARGET="$(realpath $2)";
        elif [ "$1" = "-h" -o "$1" = "--help" ]; then
                echo "usage: tmv [-s|--set-target &lt;dir&gt;] | &lt;mv args&gt; &lt;files&gt;";
        else
                mv --target-directory "$MOVE_TARGET" "$@";
        fi
}
</t>
<t tx="sa.20110128155259.1883">##################################################
# Changes spaces to underscores in names	 #
##################################################

function underscore()
{
	for f in * ; do
    	[ "${f}" != "${f// /_}" ]
		mv -- "${f}" "${f// /_}"
	done
}</t>
<t tx="sa.20110128155259.1884">
##################################################
# Run a command, redirecting output to a file, 	 #
# then edit the file with vim			 #
##################################################

function vimcmd() { $1 &gt; $2 &amp;&amp; vim $2; }

</t>
<t tx="sa.20110128155259.1885">

##################################################
# Overwrite a file with zeros			 #
##################################################

function zero() {
        case "$1" in
                "")     echo "Usage: zero &lt;file&gt;"

                        return -1;
        esac
        filesize=`wc -c  "$1" | awk '{print $1}'`
        `dd if=/dev/zero of=$1 count=$filesize bs=1`
}
</t>
<t tx="sa.20110128155259.1886"></t>
<t tx="sa.20110128155259.1887">




##################################################
# Advanced ls functions				 #
##################################################

function la() {
	# copyright 2007 - 2010 Christopher Bratusek
	ls -A --group-directories-first "$@"
}



function lg() {
	# copyright 2007 - 2010 Christopher Bratusek
	if [[ "$@" == "" ]]; then
		$@="*"
	fi
	ls -l --group-directories-first "$@" | gawk '{print $9, "belongs to Group -&gt;", $4}' | column -t
}



function ll() {
	# copyright 2007 - 2010 Christopher Bratusek
	ls -l --group-directories-first "$@"
}



###### Counts files, subdirectories and directory size and displays details
# about files depending on the available space
function lls() {
	# count files
	echo -n "&lt;`find . -maxdepth 1 -mindepth 1 -type f | wc -l | tr -d '[:space:]'` files&gt;"
	# count sub-directories
	echo -n " &lt;`find . -maxdepth 1 -mindepth 1 -type d | wc -l | tr -d '[:space:]'` dirs/&gt;"
	# count links
	echo -n " &lt;`find . -maxdepth 1 -mindepth 1 -type l | wc -l | tr -d '[:space:]'` links@&gt;"
	# total disk space used by this directory and all subdirectories
	echo " &lt;~`du -sh . 2&gt; /dev/null | cut -f1`&gt;"
	ROWS=`stty size | cut -d' ' -f1`
	FILES=`find . -maxdepth 1 -mindepth 1 |
	wc -l | tr -d '[:space:]'`
	# if the terminal has enough lines, do a long listing
	if [ `expr "${ROWS}" - 6` -lt "${FILES}" ]; then
		ls
	else
		ls -hlAF --full-time
	fi
}



function lo() {
	# copyright 2007 - 2010 Christopher Bratusek
	if [[ "$@" == "" ]]; then
		$@="*"
	fi
	ls -l --group-directories-first "$@" | gawk '{print $9, "belongs to User -&gt;", $3}' | sed -e '1d' | column -t
}



function l1() {
	# copyright 2007 - 2010 Christopher Bratusek
	ls -1 --group-directories-first "$@"
}




function lm() {
	# copyright 2007 - 2010 Christopher Bratusek
	if [[ ! "$@" == "" ]]; then
		for file in "$@"; do
			stat -c "%A %a %n" "$file" | gawk '{print "Permissions of:", $3, "-&gt;", $1, "("$2")"}'
		done | column -t
	fi
}



###### inspired by http://tldp.org/HOWTO/Bash-Prompt-HOWTO/x279.html
# but I made it a single awk instead of an awk, forloop and a bc
# asumes we have awk available.  but really, who doesnt have awk?
# let's get the size of the files in this dir
function lsbytes() {
    echo -n $(ls -l | awk '/^-/{total += $5} END{printf "%.2f", total/1048576}')
}



function lscd() {
	# copyright 2007 - 2010 Christopher Bratusek
	builtin cd "${@}" &amp;&gt;/dev/null
	. $BSNG_RC_DIR/dirinfo/display
	dirinfo_display
	echo -e "${epink}content:"
	ls $LSCD_OPTS
	echo "$PWD" &gt; $HOME/.lastpwd
}



###### display long list of files with the given extension
# example: lsext txt
function lsext()
{
find . -type f -iname '*.'${1}'' -exec ls -l {} \; ;
}



###### another way to call for a list of files/folders
function lsr() { /bin/ls -l "$@"/..namedfork/rsrc ; }

</t>
<t tx="sa.20110128155259.1888">##################################################
# Size of items in directory			 #
##################################################

function dubigf() {
  du -sh * | awk '/[[:space:]]*[[:digit:]]+,*[[:digit:]]*G/' | sort -nr
  du -sh * | awk '/[[:space:]]*[[:digit:]]+,*[[:digit:]]*M/' | sort -nr
}


</t>
<t tx="sa.20110128155259.1889">##################################################
# Change directory and list files		 #
##################################################

function cds() {
    # only change directory if a directory is specified
    [ -n "${1}" ] &amp;&amp; cd $1
    lls
}
</t>
<t tx="sa.20110128155259.1890">##################################################
# Size of directories in MB			 #
##################################################

function ds()
{
    echo "size of directories in MB"
    if [ $# -lt 1 ] || [ $# -gt 2 ]; then
        echo "you did not specify a directy, using pwd"
        DIR=$(pwd)
        find $DIR -maxdepth 1 -type d -exec du -sm \{\} \; | sort -nr
    else
        find $1 -maxdepth 1 -type d -exec du -sm \{\} \; | sort -nr
    fi
}</t>
<t tx="sa.20110128155259.1891">


##################################################
# Makes directory then moves into it		 #
##################################################

function mkcdr() {
    mkdir -p -v $1
    cd $1
}



function mkdircd()	{ mkdir -p "$@" &amp;&amp; eval cd "\"\$$#\""; }

</t>
<t tx="sa.20110128155259.1892">##################################################
# Substitutes underscores for blanks in all the  #
# filenames in a directory			 #
##################################################

function blank_rename()
{
ONE=1                     # For getting singular/plural right (see below).
number=0                  # Keeps track of how many files actually renamed.
FOUND=0                   # Successful return value.
for filename in *         #Traverse all files in directory.
do
     echo "$filename" | grep -q " "         #  Check whether filename
     if [ $? -eq $FOUND ]                   #+ contains space(s).
     then
       fname=$filename                      # Yes, this filename needs work.
       n=`echo $fname | sed -e "s/ /_/g"`   # Substitute underscore for blank.
       mv "$fname" "$n"                     # Do the actual renaming.
       let "number += 1"
     fi
done
if [ "$number" -eq "$ONE" ]                 # For correct grammar.
then
 echo "$number file renamed."
else
 echo "$number files renamed."
fi
}</t>
<t tx="sa.20110128155259.1893"></t>
<t tx="sa.20110128155259.1894"></t>
<t tx="sa.20110128155259.1895">
##################################################
# Search and replace words/phrases from text file#
##################################################

###### usage:	searchnreplace "whatever oldtext" "whatever newtext" "file(s) to act on"
function searchnreplace()
{
# Store old text and new text in variables
old=$1;
new=$2;
# Shift positional parameters to places to left (get rid of old and
# new from command line)
shift;
shift;
# Store list of files as a variable
files=$@;
a='';
for a in $files
 do
  temp=$(echo "/tmp/$LOGNAME-$a");
# echo "$temp";
  echo -n ".";
  sed -e "s/$old/$new/g" $a &gt; $temp;
  mv $temp $a;
 done
echo;
echo -e "Searched $# files for '$old' and replaced with '$new'";
}
</t>
<t tx="sa.20110128155259.1896">##################################################
# Find a file(s) ...				 #
##################################################

###### ... with pattern $1 in name and Execute $2 on it
function fe() { find . -type f -iname '*'$1'*' -exec "${2:-file}" {} \;  ; }



###### ... under the current directory
function ff() { /usr/bin/find . -name "$@" ; }



###### ... whose name ends with a given string
function ffe() { /usr/bin/find . -name '*'"$@" ; }



###### ... whose name starts with a given string
function ffs() { /usr/bin/find . -name "$@"'*' ; }



###### ... larger than a certain size (in bytes)
function find_larger() { find . -type f -size +${1}c ; }



###### find a file with a pattern in name in the local directory
function fp()
{
    find . -type f -iname '*'$*'*' -ls ;
}


###### ... who is the newest file in a directory
function newest() { find ${1:-\.} -type f |xargs ls -lrt ; }
</t>
<t tx="sa.20110128155259.1897">###### find pattern in a set of files and highlight them
function fstr()
{
    OPTIND=1
    local case=""
    local usage="fstr: find string in files.
Usage: fstr [-i] \"pattern\" [\"filename pattern\"] "
    while getopts :it opt
    do
        case "$opt" in
        i) case="-i " ;;
        *) echo "$usage"; return;;
        esac
    done
    shift $(( $OPTIND - 1 ))
    if [ "$#" -lt 1 ]; then
        echo "$usage"
        return;
    fi
    local SMSO=$(tput smso)
    local RMSO=$(tput rmso)
    find . -type f -name "${2:-*}" -print0 | xargs -0 grep -sn ${case} "$1" 2&gt;&amp;- | \
sed "s/$1/${SMSO}\0${RMSO}/gI" | more
}



###### searches through the text of all the files in your current directory
# http://seanp2k.com/?p=13
# Good for debugging a PHP script you didn't write and can't trackdown where MySQL connect string actually is
# function grip() {
# grep -ir "$1″ "$PWD"
# }

##################################################
# Find in file and ( AND relation )		 #
##################################################

# Will search PWD for text files that contain $1 AND $2 AND $3 etc...
# Actually it does the same as grep word1|grep word2|grep word3 etc, but in a more elegant way.
function ffa() { (($# &lt; 2)) &amp;&amp; { echo "usage: ffa pat1 pat2 [...]" &gt;&amp;2; return 1; };awk "/$1/$(printf "&amp;&amp;/%s/" "${@:2}")"'{ print FILENAME ":" $0 }' *; }

</t>
<t tx="sa.20110128155259.1898">##################################################
# Print the corresponding error message		 #
##################################################

function strerror() { python -c "import os; print os.strerror($1)"; }
</t>
<t tx="sa.20110128155259.1899"></t>
<t tx="sa.20110128155259.1900">##################################################
# Extract a particular column of space-		 #
# separated output				 #
##################################################

###### e.g.: lsof | getcolumn 0 | sort | uniq
function getcolumn() { perl -ne '@cols = split; print "$cols['$1']\n"' ; }



</t>
<t tx="sa.20110128155259.1901">##################################################
# Create box of '#' characters around given 	 #
# string					 #
##################################################

function box() { t="$1xxxx";c=${2:-#}; echo ${t//?/$c}; echo "$c $1 $c"; echo ${t//?/$c}; }

</t>
<t tx="sa.20110128155259.1902">
##################################################
# Computes most frequent used words of text file #
##################################################

###### usage:	most_frequent "file.txt"
function most_frequent()
{
cat "$1" | tr -cs "[:alnum:]" "\n"| tr "[:lower:]" "[:upper:]" | awk '{h[$1]++}END{for (i in h){print h[i]" "i}}'|sort -nr | cat -n | head -n 30
}

</t>
<t tx="sa.20110128155259.1903">
##################################################
# Print a row of characters across the terminal	 #
##################################################

###### Default character is "=", default color is white
function println()
{
echo -n -e "\e[038;05;${2:-255}m";printf "%$(tput cols)s"|sed "s/ /${1:-=}/g"
}</t>
<t tx="sa.20110128155259.1904"></t>
<t tx="sa.20110128155259.1905">##################################################
# Change to specified pkg's documentation dir and#
# display the files				 #
##################################################s

###### Usage: doc
function doc() {
    pushd "/usr/share/doc/$1" &amp;&amp; ls
}

</t>
<t tx="sa.20110128155259.1906">##################################################
# Arch-wiki-docs simple search			 #
##################################################

function archwikisearch() {
	# old version
	# cd /usr/share/doc/arch-wiki/html/
	# grep -i "$1" index.html | sed 's/.*HREF=.\(.*\.html\).*/\1/g' | xargs opera -newpage
	cd /usr/share/doc/arch-wiki/html/
	for i in $(grep -li $1 *)
	do
		STRING=`grep -m1 -o 'wgTitle = "[[:print:]]\+"' $i`
		LEN=${#STRING}
		let LEN=LEN-12
		STRING=${STRING:11:LEN}
		LOCATION="/usr/share/doc/arch-wiki/html/$i"
		echo -e " \E[33m$STRING   \E[37m$LOCATION"
	done
}</t>
<t tx="sa.20110128155259.1907">

###### example:	man2text wipe	=	wipe.txt
function man2text()
{
man "$1" | col -b &gt; ~/man_"$1".txt
}


</t>
<t tx="sa.20110128155259.1908">##################################################
# RTFM function					 #
##################################################

function rtfm() { help $@ || man $@ || $BROWSER "http://www.google.com/search?q=$@"; }
</t>
<t tx="sa.20110128155259.1909"></t>
<t tx="sa.20110128155259.1910">##################################################
# Show computer information of all sorts	 #
# (requires 'gawk': sudo apt-get install gawk)	 #
##################################################

###### machine details
function ii()
{
    echo -e "\n${RED}You are logged onto:$NC " ; hostname
    echo -e "\n${RED}Additionnal information:$NC " ; uname -a
    echo -e "\n${RED}Users logged on:$NC " ; w -h
    echo -e "\n${RED}Current date:$NC " ; date
    echo -e "\n${RED}Machine stat:$NC " ; uptime
    echo -e "\n${RED}Disk space:$NC " ; df -h
    echo -e "\n${RED}Memory stats (in MB):$NC " ;
    if [ "$OS" = "Linux" ]; then
        free -m
    elif [ "$OS" = "Darwin" ]; then
        vm_stat
    fi
    echo -e "\n${RED}IPs:$NC " ; ips
}

</t>
<t tx="sa.20110128155259.1911">##################################################
# Display theme info				 #
##################################################

function themeinfo() {
  if [ `pgrep emerald` ]; then
    echo "  Emerald:    `cat $HOME/.emerald/theme/theme.ini | grep description | awk -F= '{print $2}'`"
  else
    echo "  Metacity:   `gconftool-2 -g /apps/metacity/general/theme`"
  fi
  echo "  GTK:        `gconftool-2 -g /desktop/gnome/interface/gtk_theme`"
  echo "  Icons:      `gconftool-2 -g /desktop/gnome/interface/icon_theme`"
  echo "  Cursor:     `gconftool-2 -g /desktop/gnome/peripherals/mouse/cursor_theme`"
  echo "  Font:       `gconftool-2 -g /desktop/gnome/interface/font_name`"
  echo "  Wallpaper:  `gconftool-2 -g /desktop/gnome/background/picture_filename | xargs basename | cut -d. -f 1`"
  echo
}

</t>
<t tx="sa.20110128155259.1912"></t>
<t tx="sa.20110128155259.1913">##################################################
# Git stuff					 #
##################################################

###### copyright 2007 - 2010 Christopher Bratusek
function git_action() {
	if [[ -d .git ]]; then
		if [[ -f .git/dotest/rebasing ]]; then
			ACTION="rebase"
		elif [[ -f .git/dotest/applying ]]; then
			ACTION="apply"
		elif [[ -f .git/dotest-merge/interactive ]]; then
			ACTION="rebase -i"
		elif [[ -d .git/dotest-merge ]]; then
			ACTION="rebase -m"
		elif [[ -f .git/MERGE_HEAD ]]; then
			ACTION="merge"
		elif [[ -f .git/index.lock ]]; then
			ACTION="locked"
		elif [[ -f .git/BISECT_LOG ]]; then
			ACTION="bisect"
		else	ACTION="nothing"
		fi
		echo $ACTION
	else	echo --
	fi
}



function git_branch() {
	if [[ -d .git ]]; then
		BRANCH=$(git symbolic-ref HEAD 2&gt;/dev/null)
		echo ${BRANCH#refs/heads/}
	else	echo --
	fi
}



function git_bzip() {
	git archive master | bzip2 -9 &gt;"$PWD".tar.bz2
}



function git_e() {
	if [[ "$SVN_USER_ENLIGTENMENT" &amp;&amp; $1 == "-m" ]]; then
		svn co svn+ssh://"$SVN_USER_ENLIGTENMENT"@svn.enlightenment.org/var/svn/$2
	else
		svn co http://svn.enlightenment.org/svn/$2
	fi
}



function git_export() {
	if [[ "$1" != "" ]]; then
		git checkout-index --prefix="$1"/ -a
	fi
}



function git_gnome() {
	if [[ $GIT_USER_GNOME ]]; then
		if [[ $1 == "-m" ]]; then
			git clone git+ssh://$GIT_USER_GNOME@git.gnome.org/git/$2
		elif [[ $1 == "-mb" ]]; then
			git clone -b $3 git+ssh://$GIT_USER_GNOME@git.gnome.org/git/$2
		fi
	fi
	if [[ $1 == "-b" ]]; then
		git clone -b $3 git://git.gnome.org/$2
	else 	git clone git://git.gnome.org/$1
	fi
}



function git_kde() {
	if [[ "$SVN_USER_KDE" ]]; then
		if [[ $1 == "-m" ]]; then
			svn co --user-name="$SVN_USER_KDE" svn+ssh://svn.kde.org/home/kde/trunk/KDE/$2
		elif [[ $1 == "-mb" ]]; then
			svn co --user-name="$SVN_USER_KDE" svn+ssh://svn.kde.org/home/kde/branches/KDE/$2
		fi
	fi
	if [[ $1 == "-b" ]]; then
		svn co svn://svn.kde.org/home/kde/branches/KDE/$2
	else	svn co svn://svn.kde.org/home/kde/trunk/KDE/$2
	fi
}



function git_revision() {
	if [[ -d .git ]]; then
		REVISION=$(git rev-parse HEAD 2&gt;/dev/null)
		REVISION=${REVISION/HEAD/}
		echo ${REVISION:0:6}
	else	echo --
	fi
}



function git_xfce() {
	if [[ $GIT_USER_XFCE ]]; then
		if [[ $1 == "-m" ]]; then
			git clone ssh://$GIT_USER_XFCE@git.xfce.org/git/$2
		elif [[ $1 == "-mb" ]]; then
			git clone -b $3 ssh://$GIT_USER_XFCE@git.xfce.org/git/$2
		fi
	fi
	if [[ $1 == "-b" ]]; then
		git clone -b $3 git://git.xfce.org/$2
	else	git clone git://git.xfce.org/$1
	fi
}



function git_xz() {
	git archive master | xz -9 &gt; "$PWD".tar.xz
}



function gup() {
  git fetch &amp;&amp; git rebase origin/$(git branch | grep '^\*' | cut -d\  -f2)
}
</t>
<t tx="sa.20110128155259.1914">##################################################
# Temporarily add to PATH			 #
##################################################

function apath()
{
    if [ $# -lt 1 ] || [ $# -gt 2 ]; then
        echo "Temporarily add to PATH"
        echo "usage: apath [dir]"
    else
        PATH=$1:$PATH
    fi
}
</t>
<t tx="sa.20110128155259.1915">##################################################
# Grep, grep, grep				 #
##################################################

###### to grep through files found by find, e.g. grepf pattern '*.c'
# note that 'grep -r pattern dir_name' is an alternative if want all files
function grepfind() { find . -type f -name "$2" -print0 | xargs -0 grep "$1" ; }



###### to grep through the /usr/include directory
function grepincl() { (cd /usr/include; find . -type f -name '*.h' -print0 | xargs -0 grep "$1" ) ; }



###### hgrep, hgrepl (I use these so much I miss them not being on my other machines and should copy them over)
function hgrepl() {
history | sed s/.*\ \ // | grep $@
}



function hgrep() {
history | sed s/.*\ \ // | grep $@ | tail -n 30
}



function hhgrep() {
history | egrep "$@" | egrep -v "hgrep $@"
}</t>
<t tx="sa.20110128155259.1916">##################################################
# Common commands piped through grep		 #
##################################################

function aptg()		# debian specific.
{
    if [ $# -lt 1 ] || [ $# -gt 1 ]; then
        echo "search debian package list"
        echo "usage: aptg [program/keyword]"
    else
        apt-cache search $1 | sort | less
    fi
}



###### grep by paragraph instead of by line
function grepp() { [ $# -eq 1 ] &amp;&amp; perl -00ne "print if /$1/i" || perl -00ne "print if /$1/i" &lt; "$2";}



function hgg()
{
    if [ $# -lt 1 ] || [ $# -gt 1 ]; then
        echo "search bash history"
        echo "usage: mg [search pattern]"
    else
        history | grep -i $1 | grep -v hg
    fi
}



function lsofg()
{
    if [ $# -lt 1 ] || [ $# -gt 1 ]; then
        echo "grep lsof"
        echo "usage: losfg [port/program/whatever]"
    else
        lsof | grep -i $1 | less
    fi
}



function psg()
{
    if [ $# -lt 1 ] || [ $# -gt 1 ]; then
        echo "grep running processes"
        echo "usage: psg [process]"
    else
        ps aux | grep USER | grep -v grep
        ps aux | grep -i $1 | grep -v grep
    fi
}
</t>
<t tx="sa.20110128155259.1917"></t>
<t tx="sa.20110128155259.1918"></t>
<t tx="sa.20110128155259.1919">##################################################
# Download all installed deb packages from 	 #
# official repos currently on system		 #
##################################################

function packagelistdl()
{
sudo dpkg --get-selections | awk '{ print $1};' | while read package; do apt-cache show "$package"| wget -c 'http://ae.archive.ubuntu.com/ubuntu/'`sed -ne '/^Filename/s/^Filename: //p'`; done
}</t>
<t tx="sa.20110128155259.1920">##################################################
# Remove apps with style: nuke it from orbit	 #
##################################################

###### You can't stand programs x, y, and z. Remove all trace of their existence by adding this function to your config. It will remove the cruft, the settings, #and such and such. This function doesn't even give a damn about you trying to remove programs that don't exist: it'll just for loop to the next one on #your hit list.
function nuke() { if [ $(whoami) != "root" ] ; then for x in $@; do sudo apt-get autoremove --purge $x; done; else for x in $@; do apt-get autoremove --purge $x; done; fi }

</t>
<t tx="sa.20110128155259.1921">##################################################
# To show Apt Log History			 #
##################################################

function apt-history() {
      case "$1" in
        install)
              cat /var/log/dpkg.log | grep 'install '
              ;;
        upgrade|remove)
              cat /var/log/dpkg.log | grep $1
              ;;
        rollback)
              cat /var/log/dpkg.log | grep upgrade | \
                  grep "$2" -A10000000 | \
                  grep "$3" -B10000000 | \
                  awk '{print $4"="$5}'
              ;;
        *)
              cat /var/log/dpkg.log
              ;;
      esac
}</t>
<t tx="sa.20110128155259.1922">###### search Debian (or Ubuntu) package database (apt) using dpkg
#   $1 = search term (package name)
function sp() { apt-cache search "$1" | grep -i "$1"; }  # search all available</t>
<t tx="sa.20110128155259.1923"></t>
<t tx="sa.20110128155259.1924">##################################################
# Pacman Search					 #
##################################################

function pacsearch() {
       echo -e "$(pacman -Ss $@ | sed \
       -e 's#core/.*#\\033[1;31m&amp;\\033[0;37m#g' \
       -e 's#extra/.*#\\033[0;32m&amp;\\033[0;37m#g' \
       -e 's#community/.*#\\033[1;35m&amp;\\033[0;37m#g' \
       -e 's#^.*/.* [0-9].*#\\033[0;36m&amp;\\033[0;37m#g' )"
}


</t>
<t tx="sa.20110128155259.1925">##################################################
# Ask						 #
##################################################

function ask()
{
    echo -n "$@" '[y/n] ' ; read ans
    case "$ans" in
        y*|Y*) return 0 ;;
        *) return 1 ;;
    esac
}
</t>
<t tx="sa.20110128155259.1926"></t>
<t tx="sa.20110128155259.1927">###### watch the National debt clock
function natdebt()
{
watch -n 10 "wget -q http://www.brillig.com/debt_clock -O - | grep debtiv.gif | sed -e 's/.*ALT=\"//' -e 's/\".*//' -e 's/ //g'"
}




</t>
<t tx="sa.20110128155259.1928">function oneliners()
{
w3m -dump_source http://www.onelinerz.net/random-one-liners/1/ | awk ' /.*&lt;div id=\"oneliner_[0-9].*/ {while (! /\/div/ ) { gsub("\n", ""); getline; }; gsub (/&lt;[^&gt;][^&gt;]*&gt;/, "", $0); print $0}'
}</t>
<t tx="sa.20110128155259.1929">##################################################
# Execute a given Linux command on a group of	 #
# files						 #
##################################################

###### Example: batchexec sh ls		# lists all files that have the extension 'sh'
# Example: batchexec sh chmod 755	# 'chmod 755' all files that have the extension 'sh'
function batchexec()
{
find . -type f -iname '*.'${1}'' -exec ${@:2}  {} \; ;
}</t>
<t tx="sa.20110128155259.1930">

##################################################
# Monitor progress of data through a pipeline	 #
##################################################

function tarcp() {
    if (( $# &gt;= 2 )); then
        echo "copy ${@[1, -2]} =&gt; ${@[-1]}"
        # http://www.ivarch.com/programs/pv.shtml
        if which pv ; then
            tar -c -f - ${@[1, -2]} | pv -t -b -r | tar -x -f - -C ${@[-1]}
        else
            tar -c -v -f - ${@[1, -2]} | tar -x -f - -C ${@[-1]}
        fi
    else
        "error, not enough parameters."
        return 1
    fi
}</t>
<t tx="sa.20110128155259.1931">##################################################
# Roll - archive wrapper			 #
##################################################

###### usage: roll &lt;foo.tar.gz&gt; ./foo ./bar
function roll()
{
  FILE=$1
  case $FILE in
    *.tar.bz2) shift &amp;&amp; tar cjf $FILE $* ;;
    *.tar.gz) shift &amp;&amp; tar czf $FILE $* ;;
    *.tgz) shift &amp;&amp; tar czf $FILE $* ;;
    *.zip) shift &amp;&amp; zip $FILE $* ;;
    *.rar) shift &amp;&amp; rar $FILE $* ;;
  esac
}
</t>
<t tx="sa.20110128155259.1932">
function mktbz() { tar cvjf "${1%%/}.tar.bz2" "${1%%/}/"; }
</t>
<t tx="sa.20110128155259.1933">##################################################
# Creates an archive from directory		 #
##################################################


function mktgz() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }

</t>
<t tx="sa.20110128155259.1934">function mktar() { tar cvf  "${1%%/}.tar"     "${1%%/}/"; }

</t>
<t tx="sa.20110128155259.1935">##################################################
# Escape potential tarbombs			 #
##################################################

function atb() { l=$(tar tf $1); if [ $(echo "$l" | wc -l) -eq $(echo "$l" | grep $(echo "$l" | head -n1) | wc -l) ]; then tar xf $1; else mkdir ${1%.tar.gz} &amp;&amp; tar xf $1 -C ${1%.tar.gz}; fi ; }
</t>
<t tx="sa.20110128155259.1936">##################################################
# Extract - extract most common compression	 #
# types						 #
##################################################

function extract() {
  local e=0 i c
  for i; do
    if [[ -f $i &amp;&amp; -r $i ]]; then
        c=''
        case $i in
          *.t@(gz|lz|xz|b@(2|z?(2))|a@(z|r?(.@(Z|bz?(2)|gz|lzma|xz)))))
                 c='bsdtar xvf' ;;
          *.7z)  c='7z x'       ;;
          *.Z)   c='uncompress' ;;
          *.bz2) c='bunzip2'    ;;
          *.exe) c='cabextract' ;;
          *.gz)  c='gunzip'     ;;
          *.rar) c='unrar x'    ;;
          *.xz)  c='unxz'       ;;
          *.zip) c='unzip'      ;;
          *)     echo "$0: cannot extract \`$i': Unrecognized file extension" &gt;&amp;2; e=1 ;;
        esac
        [[ $c ]] &amp;&amp; command $c "$i"
    else
        echo "$0: cannot extract \`$i': File is unreadable" &gt;&amp;2; e=2
    fi
  done
  return $e
}</t>
<t tx="sa.20110128155259.1937">
##################################################
# Creates a dated tarball			 #
##################################################

function tarball()
{
    name=$1
    shift
    tar zcvf $name-`date +%Y%m%d`.tar.gz "$@"
}

</t>
<t tx="sa.20110128155259.1938">


##################################################
# To create a ZIP archive of a file or folder	 #
##################################################

function zipf() { zip -r "$1".zip "$1" ; }
</t>
<t tx="sa.20110128155259.1939">##################################################
# Pull a single file out of a .tar.gz		 #
##################################################

function pullout() {
  if [ $# -ne 2 ]; then
    echo "need proper arguments:"
    echo "pullout [file] [archive.tar.gz]"
    return 1
  fi
  case $2 in
    *.tar.gz|*.tgz)
    gunzip &lt; $2 | tar -xf - $1
    ;;
    *)
    echo $2 is not a valid archive
    return 1
    ;;
  esac
  return 0
}
</t>
<t tx="sa.20110128155259.1940">##################################################
# Network information and IP address stuff	 #
##################################################

###### clear iptables rules safely
function clearIptables()
{
iptables -P INPUT ACCEPT; iptables -P FORWARD ACCEPT; iptables -P OUTPUT ACCEPT; iptables -F; iptables -X; iptables -L
}



###### find an unused unprivileged TCP port
function findtcp()
{
(netstat  -atn | awk '{printf "%s\n%s\n", $4, $4}' | grep -oE '[0-9]*$'; seq 32768 61000) | sort -n | uniq -u | head -n 1
}



###### geoip lookup (need geoip database: sudo apt-get install geoip-bin)
function geoip() {
geoiplookup $1
}



###### geoip information
# requires 'html2text': sudo apt-get install html2text
function geoiplookup() { curl -A "Mozilla/5.0" -s "http://www.geody.com/geoip.php?ip=$1" | grep "^IP.*$1" | html2text; }



###### get IP address of a given interface
# Example: getip lo
# Example: getip eth0	# this is the default
function getip()		{ lynx -dump http://whatismyip.org/; }



###### display private IP
function ippriv()
{
    ifconfig eth0|grep "inet adr"|awk '{print $2}'|awk -F ':' '{print $2}'
}



###### ifconfig connection check
function ips()
{
    if [ "$OS" = "Linux" ]; then
        for i in $( /sbin/ifconfig | grep ^e | awk '{print $1}' | sed 's/://' ); do echo -n "$i: ";  /sbin/ifconfig $i | perl -nle'/dr:(\S+)/ &amp;&amp; print $1'; done
    elif [ "$OS" = "Darwin" ]; then
        for i in $( /sbin/ifconfig | grep ^e | awk '{print $1}' | sed 's/://' ); do echo -n "$i: ";  /sbin/ifconfig $i | perl -nle'/inet (\S+)/ &amp;&amp; print $1'; done
    fi
}



###### geolocate a given IP address
function ip2loc() { wget -qO - www.ip2location.com/$1 | grep "&lt;span id=\"dgLookup__ctl2_lblICountry\"&gt;" | sed 's/&lt;[^&gt;]*&gt;//g; s/^[\t]*//; s/&amp;quot;/"/g; s/&lt;/&lt;/g; s/&gt;/&gt;/g; s/&amp;amp;/\&amp;/g'; }



###### myip - finds your current IP if your connected to the internet
function myip()
{
lynx -dump -hiddenlinks=ignore -nolist http://checkip.dyndns.org:8245/ | awk '{ print $4 }' | sed '/^$/d; s/^[ ]*//g; s/[ ]*$//g'
}



###### netinfo - shows network information for your system
function netinfo()
{
echo "--------------- Network Information ---------------"
/sbin/ifconfig | awk /'inet addr/ {print $2}'
/sbin/ifconfig | awk /'Bcast/ {print $3}'
/sbin/ifconfig | awk /'inet addr/ {print $4}'
/sbin/ifconfig | awk /'HWaddr/ {print $4,$5}'
myip=`lynx -dump -hiddenlinks=ignore -nolist http://checkip.dyndns.org:8245/ | sed '/^$/d; s/^[ ]*//g; s/[ ]*$//g' `
echo "${myip}"
echo "---------------------------------------------------"
}



###### show ip
# copyright 2007 - 2010 Christopher Bratusek
function show_ip()
{
	case $1 in
		*help | "" )
			echo -e "\n${ewhite}Usage:\n"
			echo -e "${eorange}show_ip${ewhite} |${egreen} &lt;interface&gt; ${eiceblue}[show ip-address for &lt;interface&gt;]\
			\n${eorange}show_ip${ewhite} |${egreen} external${eiceblue} [show external ip address]\n"
			tput sgr0
		;;
		*external )
			wget -q -O - http://showip.spamt.net/
		;;
		* )
			LANG=C /sbin/ifconfig $1 | grep 'inet addr:' | cut -d: -f2 | gawk '{ print $1}'
		;;
	esac
}



###### display the ttl of a hostname in a human readable form
function ttl()
{
/usr/sbin/timetrans -count $(dig +noquestion +noadditional +noauthority $1 | grep "^$1" | awk '{print $2}')
}



###### show Url information
# Usage:	url-info "ur"
# This script is part of nixCraft shell script collection (NSSC)
# Visit http://bash.cyberciti.biz/ for more information.
# Modified by Silviu Silaghi (http://docs.opensourcesolutions.ro) to handle
# more ip adresses on the domains on which this is available (eg google.com or yahoo.com)
# Last updated on Sep/06/2010
function url-info()
{
doms=$@
if [ $# -eq 0 ]; then
echo -e "No domain given\nTry $0 domain.com domain2.org anyotherdomain.net"
fi
for i in $doms; do
_ip=$(host $i|grep 'has address'|awk {'print $4'})
if [ "$_ip" == "" ]; then
echo -e "\nERROR: $i DNS error or not a valid domain\n"
continue
fi
ip=`echo ${_ip[*]}|tr " " "|"`
echo -e "\nInformation for domain: $i [ $ip ]\nQuerying individual IPs"
 for j in ${_ip[*]}; do
echo -e "\n$j results:"
whois $j |egrep -w 'OrgName:|City:|Country:|OriginAS:|NetRange:'
done
done
}
</t>
<t tx="sa.20110128155259.1941">
##################################################
# Scans a port, returns what's on it.		 #
##################################################

function port() {
lsof -i :"$1"
}



##################################################
# Portscan in one line				 #
##################################################

function portscan()
{
$HOST=127.0.0.1;for((port=1;port&lt;=65535;++port));do echo -en "$port ";if echo -en "open $HOST $port\nlogout\quit" | telnet 2&gt;/dev/null | grep 'Connected to' &gt; /dev/null;then echo -en "\n\nport $port/tcp is open\n\n";fi;done
}
</t>
<t tx="sa.20110128155259.1942">###### takes a name of a color and some text and then echoes out the text in the named color
# Usage:	colorize_text "color" "whatever text"
function colorize-text()
{
b='[0;30m'
# Implement command-line options
while getopts "nr" opt
 do
  case $opt in
   n  )  o='-n' ;;
   r  )  b=''   ;;
  esac
 done
shift $(($OPTIND - 1))
# Set variables
col=$1
shift
text="$*"
# Set a to console color code
case $col in
 'black'  ) a='[0;30m' ;;
 'blue'   ) a='[0;34m' ;;
 'green'  ) a='[0;32m' ;;
 'cyan'   ) a='[0;36m' ;;
 'red'    ) a='[0;31m' ;;
 'purple' ) a='[0;35m' ;;
 'brown'  ) a='[0;33m' ;;
 'ltgray' ) a='[0;37m' ;;
 'white'  ) a='[1;30m' ;;
 'ltblue' ) a='[1;34m' ;;
 'ltgreen') a='[1;32m' ;;
 'ltcyan' ) a='[1;36m' ;;
 'ltred'  ) a='[1;31m' ;;
 'pink'   ) a='[1;35m' ;;
 'yellow' ) a='[1;33m' ;;
 'gray'   ) a='[1;37m' ;;
esac
# Display text in designated color, no newline
echo -en "\033$a$text"
# If 'b' switch not on, restore color to black
if [ -n $b ]
 then
  echo -en "\033$b"
fi
# If 'n' switch on, do not display final newline
# otherwise output newline
echo $o
}



###### shows the colors in a kewl way...partially stolen from HH
function colors()
{
       # Display ANSI colours.
    esc="\033["
    echo -e "\t  40\t   41\t   42\t    43\t      44       45\t46\t 47"
    for fore in 30 31 32 33 34 35 36 37; do
        line1="$fore  "
        line2="    "
        for back in 40 41 42 43 44 45 46 47; do
            line1="${line1}${esc}${back};${fore}m Normal  ${esc}0m"
            line2="${line2}${esc}${back};${fore};1m Bold    ${esc}0m"
        done
        echo -e "$line1\n$line2"
    done
    echo ""
    echo "# Example:"
    echo "#"
    echo "# Type a Blinkin TJEENARE in Swedens colours (Yellow on Blue)"
    echo "#"
    echo "#           ESC"
    echo "#            |  CD"
    echo "#            |  | CD2"
    echo "#            |  | | FG"
    echo "#            |  | | |  BG + m"
    echo "#            |  | | |  |         END-CD"
    echo "#            |  | | |  |            |"
    echo "# echo -e '\033[1;5;33;44mTJEENARE\033[0m'"
    echo "#"
    echo "# Sedika Signing off for now ;-&gt;"
}



###### displays all 256 possible background colors, using ANSI escape sequences.
# author: Chetankumar Phulpagare
# used in ABS Guide with permission.
function colors2()
{
T1=8
T2=6
T3=36
offset=0
for num1 in {0..7}
do {
   for num2 in {0,1}
       do {
          shownum=`echo "$offset + $T1 * ${num2} + $num1" | bc`
          echo -en "\E[0;48;5;${shownum}m color ${shownum} \E[0m"
          }
       done
   echo
   }
done
offset=16
for num1 in {0..5}
do {
   for num2 in {0..5}
       do {
          for num3 in {0..5}
              do {
                 shownum=`echo "$offset + $T2 * ${num3} \
                 + $num2 + $T3 * ${num1}" | bc`
                 echo -en "\E[0;48;5;${shownum}m color ${shownum} \E[0m"
                 }
               done
          echo
          }
       done
}
done
offset=232
for num1 in {0..23}
do {
   shownum=`expr $offset + $num1`
   echo -en "\E[0;48;5;${shownum}m ${shownum}\E[0m"
}
done
echo
}



###### print all 256 colors for testing TERM or for a quick reference
# show numerical values for each of the 256 colors in bash
function colors2nums()
{
for code in {0..255}; do echo -e "\e[38;05;${code}m $code: Test"; done
}

</t>
<t tx="sa.20110128155259.1943"></t>
<t tx="sa.20110128155259.1944">##################################################
# Lookup a word with dict.org			 #
##################################################

###### define "whatever"
function dic() { curl dict://dict.org/d:"$@" ; }



###### find matches of $1, with optional strat $2 and optional db $3
function ref()
{
    if [[ -z $3 ]]; then
        curl dict://dict.org/m:${1}:english:${2};
    else
        curl dict://dict.org/m:${1}:${3}:${2};
    fi
}



###### look in Webster
function webster() { curl dict://dict.org/d:${1}:web1913; }



###### look in WordNet
function wordnet() { curl dict://dict.org/d:${1}:wn; }</t>
<t tx="sa.20110128155259.1945">##################################################
###### command line way to get the stock quote via Yahoo
function stock()
{
curl -s 'http://download.finance.yahoo.com/d/quotes.csv?s=csco&amp;f=l1'
}


</t>
<t tx="sa.20110128155259.1946">##################################################
# User friendly ps				 #
##################################################

function my_ps() { ps $@ -u $USER -o pid,%cpu,%mem,bsdtime,command ; }



function pp() { my_ps f | awk '!/awk/ &amp;&amp; $0~var' var=${1:-".*"} ; }



function psaux() {
    [ $# == 1 ] &amp;&amp; ps aux | grep $1
}



</t>
<t tx="sa.20110128155259.1947">##################################################
# Find out the pid of a specified process	 #
##################################################

######  note that the command name can be specified via a regex
#    E.g. findPid '/d$/' finds pids of all processes with names ending in 'd'
#    Without the 'sudo' it will only find processes of the current user
function findPid() { sudo /usr/sbin/lsof -t -c "$@" ; }

</t>
<t tx="sa.20110128155259.1948">

##################################################
# Easily run a program in the background without #
# losing output	 				 #
##################################################

function fork() { tf=$(tempfile -d /tmp -p $1.);echo -n "$tf "; $@ &amp;&gt;$tf&amp; }

</t>
<t tx="sa.20110128155259.1949">##################################################
# Kill a process by name			 #
##################################################

###### example: killps firefox-bin
function killps()
{
    local pid pname sig="-TERM" # default signal
    if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
        echo "Usage: killps [-SIGNAL] pattern"
        return;
    fi
    if [ $# = 2 ]; then sig=$1 ; fi
    for pid in $(myps | nawk '!/nawk/ &amp;&amp; $0~pat { print $2 }' pat=${!#}) ; do
        pname=$(myps | nawk '$2~var { print $6 }' var=$pid )
        if ask "Kill process $pid &lt;$pname&gt; with signal $sig ? "
            then kill $sig $pid
        fi
    done
}



###### example: pskill firefox-bin
# copyright 2007 - 2010 Christopher Bratusek
function psgrep() {
	if [[ $1 == "-u" ]]; then
		ps aux | grep -v grep | grep $2 | awk '{ print $2 " : " $11}' | tee .temp
		CMDS=$(cat .temp)
	elif [[ $1 != "" ]]; then
		ps aux | grep -v grep | grep "$1" | awk '{ print $11 " : " $2 " : " $1 }' | tee .temp
		CMDS=$(cat .temp)
	fi
	if [[ $CMDS == "" ]]; then
		echo "no matching process"
	fi
	rm -f .temp
}



function pskill() {
	if [[ $1 ]]; then
		psgrep $1
		shift
		if [[ $CMDS != "" ]]; then
			echo -e "\nenter process number to kill:\n"
			read ID
			if [[ ! $ID == 0 || ! $ID == "" ]]; then
				kill $@ $ID
			fi
		fi
	fi
}

</t>
<t tx="sa.20110128155259.1950">

##################################################
# Run command detached from terminal and without #
# output					 #
##################################################

###### Usage: nh
function nh() {
    nohup "$@" &amp;&gt;/dev/null &amp;
}

</t>
<t tx="sa.20110128155259.1951">
##################################################
# Open a GUI app from CLI			 #
##################################################

function open() {
  $1 &gt;/dev/null 2&gt;&amp;1 &amp;
}

</t>
<t tx="sa.20110128155259.1952">

##################################################
# Run program on a timer			 #
##################################################

###### Example: program-timer 20 viewnior arg1
function program-timer() { perl -e 'alarm shift; exec @ARGV' "$@" &amp; exit; }

</t>
<t tx="sa.20110128155259.1953">
##################################################
# Progress visuals				 #
##################################################







# Function that outputs dots every second until
# command completes	
function sleeper() { while `ps -p $1 &amp;&gt;/dev/null`; do echo -n "${2:-.}"; sleep ${3:-1}; done; }; export -f sleeper



function progressbar()
# copyright 2007 - 2010 Christopher Bratusek
{
	SP_COLOUR="\e[37;44m"
	SP_WIDTH=5.5
	SP_DELAY=0.2
	SP_STRING=${2:-"'|/=\'"}
	while [ -d /proc/$1 ]
	do
		printf "$SP_COLOUR\e7  %${SP_WIDTH}s  \e8\e[01;37m" "$SP_STRING"
		sleep ${SP_DELAY:-.2}
		SP_STRING=${SP_STRING#"${SP_STRING%?}"}${SP_STRING%?}
	done
	tput sgr0
}



###### please wait...
# copyright 2007 - 2010 Christopher Bratusek
function spanner() {
	PROC=$1;COUNT=0
	echo -n "Please wait "
	while [ -d /proc/$PROC ];do
		while [ "$COUNT" -lt 10 ];do
			echo -ne '\x08  ' ; sleep 0.1
			((COUNT++))
		done
		until [ "$COUNT" -eq 0 ];do
			echo -ne '\x08\x08 ' ; sleep 0.1
			((COUNT -= 1))
		done
	done
}



function spin() {
	# copyright 2007 - 2010 Christopher Bratusek
        echo -n "|/     |"
        while [ -d /proc/$1 ]
        do
        # moving right
        echo -ne "\b\b\b\b\b\b\b-     |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\b\\     |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\b|     |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\b /    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b-    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\\    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b|    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b /   |"
        sleep .05
        echo -ne "\b\b\b\b\b-   |"
        sleep .05
        echo -ne "\b\b\b\b\b\\   |"
        sleep .05
        echo -ne "\b\b\b\b\b|   |"
        sleep .05
        echo -ne "\b\b\b\b\b /  |"
        sleep .05
        echo -ne "\b\b\b\b-  |"
        sleep .05
        echo -ne "\b\b\b\b\\  |"
        sleep .05
        echo -ne "\b\b\b\b|  |"
        sleep .05
        echo -ne "\b\b\b\b / |"
        sleep .05
        echo -ne "\b\b\b- |"
        sleep .05
        echo -ne "\b\b\b\\ |"
        sleep .05
        echo -ne "\b\b\b| |"
        sleep .05
        echo -ne "\b\b\b /|"
        sleep .05
        echo -ne "\b\b-|"
        sleep .05
        echo -ne "\b\b\\|"
        sleep .05
        echo -ne "\b\b||"
        sleep .05
        echo -ne "\b\b/|"
        sleep .05
        # moving left
        echo -ne "\b\b||"
        sleep .05
        echo -ne "\b\b\\|"
        sleep .05
        echo -ne "\b\b-|"
        sleep .05
        echo -ne "\b\b\b/ |"
        sleep .05
        echo -ne "\b\b\b| |"
        sleep .05
        echo -ne "\b\b\b\\ |"
        sleep .05
        echo -ne "\b\b\b- |"
        sleep .05
        echo -ne "\b\b\b\b/  |"
        sleep .05
        echo -ne "\b\b\b\b|  |"
        sleep .05
        echo -ne "\b\b\b\b\\  |"
        sleep .05
        echo -ne "\b\b\b\b-  |"
        sleep .05
        echo -ne "\b\b\b\b\b/   |"
        sleep .05
        echo -ne "\b\b\b\b\b|   |"
        sleep .05
        echo -ne "\b\b\b\b\b\\   |"
        sleep .05
        echo -ne "\b\b\b\b\b-   |"
        sleep .05
        echo -ne "\b\b\b\b\b\b/    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b|    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\\    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b-    |"
        sleep .05
        echo -ne "\b\b\b\b\b\b\b/     |"
        sleep .05
        done
	echo -e "\b\b\b\b\b\b\b\b\b|=======| done!"
}



function spinner()
# copyright 2007 - 2010 Christopher Bratusek
{
	PROC=$1
	while [ -d /proc/$PROC ];do
		echo -ne '\e[01;32m/\x08' ; sleep 0.05
		echo -ne '\e[01;32m-\x08' ; sleep 0.05
		echo -ne '\e[01;32m\\\x08' ; sleep 0.05
		echo -ne '\e[01;32m|\x08' ; sleep 0.05
	done
}



###### Display a progress process
# To start the spinner2 function, you have to send the function
# into the background. To stop the spinner2 function, you have
# to define the argument "stop".
# EXAMPLE:
#    echo -n "Starting some daemon "; spinner2 &amp;
#    if sleep 10; then
#       spinner2 "stop"; echo -e "\t[ OK ]"
#    else
#       spinner2 "stop"; echo -e "\t[ FAILED ]"
#    fi
function spinner2() {
      local action=${1:-"start"}
      declare -a sign=( "-" "/" "|" "\\\\" )
      # define singnal file...
      [ "$action" = "start" ] &amp;&amp; echo 1 &gt; /tmp/signal
      [ "$action" = "stop" ] &amp;&amp; echo 0 &gt; /tmp/signal
      while [ "$( cat /tmp/signal 2&gt;/dev/null )" == "1" ] ; do
          for (( i=0; i&lt;${#sign[@]}; i++ )); do
              echo -en "${sign[$i]}\b"
              # with this command you can use millisecond as sleep time - perl rules ;-)
              perl -e 'select( undef, undef, undef, 0.1 );'
          done
      done
      # clear the last ${sign[$i]} sign at finish...
      [ "$action" = "stop" ] &amp;&amp; echo -ne " \b"
}



function working()
# copyright 2007 - 2010 Christopher Bratusek
{
   while [ -d /proc/$1 ]
   do
	echo -ne "w      \b\b\b\b\b\b\b";sleep .08;
	echo -ne "wo     \b\b\b\b\b\b\b";sleep .08;
	echo -ne "wor    \b\b\b\b\b\b\b";sleep .08;
	echo -ne "work   \b\b\b\b\b\b\b";sleep .08;
	echo -ne "worki  \b\b\b\b\b\b\b";sleep .08;
	echo -ne "workin \b\b\b\b\b\b\b";sleep .08;
	echo -ne "working\b\b\b\b\b\b\b";sleep .08;
	echo -ne " orking\b\b\b\b\b\b\b";sleep .08;
	echo -ne "  rking\b\b\b\b\b\b\b";sleep .08;
	echo -ne "   king\b\b\b\b\b\b\b";sleep .08;
	echo -ne "    ing\b\b\b\b\b\b\b";sleep .08;
	echo -ne "     ng\b\b\b\b\b\b\b";sleep .08;
	echo -ne "      g\b\b\b\b\b\b\b";sleep .08;
   done
}
</t>
<t tx="sa.20110128155259.1954">##################################################
# Stupid simple note taker			 #
##################################################

function note()
{
        # if file doesn't exist, create it
        [ -f $HOME/.notes ] || touch $HOME/.notes
        # no arguments, print file
        if [ $# = 0 ]
        then
                cat $HOME/.notes
        # clear file
        elif [ $1 = -c ]
        then
                &gt; $HOME/.notes
        # add all arguments to file
        else
                echo "$@" &gt;&gt; $HOME/.notes
        fi
}

</t>
<t tx="sa.20110128155259.1955">##################################################
# Manage services				 #
##################################################

function service() {
  if [ $# -lt 2 ]; then
    echo "Missing service name or command"
    return 1
  fi
  sudo /etc/init.d/$1 $2 &amp;&amp; return 0
}



###### service() { /etc/rc.d/$1 $2; }
function service_() {
        if [ -n "$2"  ]
        then
                /etc/rc.d/$1 $2
        else
                echo    "All daemons"
                ls --ignore=functions* /etc/rc.d/
                echo    "Running daemons"
                ls /var/run/daemons
        fi
}






##################################################
# Daemon management				 #
##################################################

# function restart() { sudo /etc/rc.d/$1 restart; }



# function start() { sudo /etc/rc.d/$1 start; }



# function stop() { sudo /etc/rc.d/$1 stop; }
</t>
<t tx="sa.20110128155259.1956"></t>
<t tx="sa.20110128155259.1957">##################################################
# Color chart					 #
##################################################

txtblk='\e[0;30m' # Black - Regular
txtred='\e[0;31m' # Red
txtgrn='\e[0;32m' # Green
txtylw='\e[0;33m' # Yellow
txtblu='\e[0;34m' # Blue
txtpur='\e[0;35m' # Purple
txtcyn='\e[0;36m' # Cyan
txtwht='\e[0;37m' # White
bldblk='\e[1;30m' # Black - Bold
bldred='\e[1;31m' # Red
bldgrn='\e[1;32m' # Green
bldylw='\e[1;33m' # Yellow
bldblu='\e[1;34m' # Blue
bldpur='\e[1;35m' # Purple
bldcyn='\e[1;36m' # Cyan
bldwht='\e[1;37m' # White
unkblk='\e[4;30m' # Black - Underline
undred='\e[4;31m' # Red
undgrn='\e[4;32m' # Green
undylw='\e[4;33m' # Yellow
undblu='\e[4;34m' # Blue
undpur='\e[4;35m' # Purple
undcyn='\e[4;36m' # Cyan
undwht='\e[4;37m' # White
bakblk='\e[40m'   # Black - Background
bakred='\e[41m'   # Red
badgrn='\e[42m'   # Green
bakylw='\e[43m'   # Yellow
bakblu='\e[44m'   # Blue
bakpur='\e[45m'   # Purple
bakcyn='\e[46m'   # Cyan
bakwht='\e[47m'   # White
txtrst='\e[0m'    # Text Reset
</t>
<t tx="sa.20110128155259.1958"></t>
<t tx="sa.20110128155259.1959">@ignore
@language shell
# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# Define Colors {{{
red='\[\e[0;31m\]'
RED='\[\e[1;31m\]'
blue='\[\e[0;34m\]'
BLUE='\[\e[1;34m\]'
cyan='\[\e[0;36m\]'
CYAN='\[\e[1;36m\]'
NC='\[\e[0m\]'              # No Color
black='\[\e[0;30m\]'
BLACK='\[\e[1;30m\]'
green='\[\e[0;32m\]'
GREEN='\[\e[1;32m\]'
yellow='\[\e[0;33m\]'
YELLOW='\[\e[1;33m\]'
magenta='\[\e[0;35m\]'
MAGENTA='\[\e[1;35m\]'
white='\[\e[0;37m\]'
WHITE='\[\e[1;37m\]'
# }}}


# If not running interactively, don't do anything
[ -z "$PS1" ] &amp;&amp; return

# don't put duplicate lines in the history. See bash(1) for more options
# don't overwrite GNU Midnight Commander's setting of `ignorespace'.
export HISTCONTROL=$HISTCONTROL${HISTCONTROL+,}ignoredups
# ... or force ignoredups and ignorespace
export HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] &amp;&amp; eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] &amp;&amp; [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

#if [ -f ~/.bash_aliases ]; then
#    . ~/.bash_aliases
#fi

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    eval "`dircolors -b`"
    alias ls='ls --color=auto'
    alias dir='dir --color=auto'
    alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -lh'
alias la='ls -A'
alias l='ls -CF'

#alias p='vim +NERDTree'
alias c='clear'                             # clear screen
alias f='find | grep'                       # quick file search
alias sps='ps aux | grep -v grep | grep'    # search processes
alias free='free -m'                        # show free mem in mb
alias fm='pcmanfm .'
alias ve='virtualenv --no-site-packages'
alias path='echo -e ${PATH//:/\\n}'

# app specific
alias show='apt-cache show'

# interactive line wrapping
alias om='rlwrap ocaml -init'
alias ocaml='rlwrap ocaml'
alias csi='rlwrap csi'
alias io='rlwrap io'
alias sbcl='rlwrap sbcl --noinform'
alias pure='rlwrap pure'

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
fi

# setup virtualenvs and pip
export WORKON_HOME=$HOME/.virtualenvs
source /usr/local/bin/virtualenvwrapper.sh
export PIP_VIRTUALENV_BASE=$WORKON_HOME
export EDITOR=vi
export PATH="$PATH:$HOME/bin:$HOME/.cabal/bin:/var/lib/gems/1.8/bin"
export BROWSER=/usr/bin/firefox
export CLOJURE_EXT=~/.clojure


export CHHOME=/home/sa/apps/ch6.3.0
export PATH=/home/sa/apps/ch6.3.0/bin:$PATH
export MANPATH=$MANPATH:/home/sa/apps/ch6.3.0/docs/man


# functions
e() {
    scite $@ &amp;
}

simian() {
    java -jar /home/sa/src/www.redhillconsulting.com.au/products/simian/bin/simian-2.2.24.jar $@
}

writezeros() {
    sudo dd if=/dev/zero of=/empty_file; sudo rm /empty_file
}



extract () {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)  tar xjf $1      ;;
            *.tar.gz)   tar xzf $1      ;;
            *.bz2)      bunzip2 $1      ;;
            *.rar)      unrar x $1      ;;
            *.gz)       gunzip $1       ;;
            *.tar)      tar xf $1       ;;
            *.tbz2)     tar xjf $1      ;;
            *.tgz)      tar xzf $1      ;;
            *.zip)      unzip $1        ;;
            *.ZIP)      unzip $1        ;;
            *.Z)        uncompress $1   ;;
            *)          echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# mkmine - recursively change ownership to $USER:$USER
# usage:  mkmine, or
#         mkmine &lt;filename | dirname&gt;
function mkmine() { sudo chown -R ${USER}:${USER} ${1:-.}; }

# sanitize - set file/directory owner and permissions to normal values (644/755)
# usage: sanitize &lt;file&gt;
sanitize()
{
  chmod -R u=rwX,go=rX "$@"
  #chown -R ${USER}:users "$@"
}

# start, stop, restart, reload - simple daemon management
# usage: start &lt;daemon-name&gt;
start()
{
  for arg in $*; do
    sudo /etc/rc.d/$arg start
  done
}
stop()
{
  for arg in $*; do
    sudo /etc/rc.d/$arg stop
  done
}
restart()
{
  for arg in $*; do
    sudo /etc/rc.d/$arg restart
  done
}
reload()
{
  for arg in $*; do
    sudo /etc/rc.d/$arg reload
  done
}


# fstr() -- Find string in files {{{
function fstr()
{
    OPTIND=1
    local case=""
    local usage="fstr: find string in files.
Usage: fstr [-i] \"pattern\" [\"filename pattern\"] "
    while getopts :it opt
    do
        case "$opt" in
        i) case="-i " ;;
        *) echo "$usage"; return;;
        esac
    done
    shift $(( $OPTIND - 1 ))
    if [ "$#" -lt 1 ]; then
        echo "$usage"
        return;
    fi
    local SMSO=$(tput smso)
    local RMSO=$(tput rmso)
    find . -type f -name "${2:-*}" -print0 | xargs -0 grep -sn ${case} "$1" 2&gt;&amp;- | \
sed "s/$1/${SMSO}\0${RMSO}/gI" | more
}
# }}}

</t>
<t tx="sa.20110128155259.1960">@ignore
</t>
<t tx="sa.20110128155259.1961">alias na='nano'
alias nano='nano -W -m'								

alias ge='geany'

alias vi='vim'
alias svi='sudo vim'
alias ve='vi ~/.vimrc'
alias vi='vim'
</t>
<t tx="sa.20110128155259.1962">alias mv='mv -iv'
alias cp='cp -iv'
alias mkdir='mkdir -p -v'
alias rm='rm -iv'

# make a temp dir, then immediately cd into it
alias mktd='tdir=`mktemp -d` &amp;&amp; cd $tdir' 
</t>
<t tx="sa.20110128155259.1963">alias pg='ps aux | grep'
alias ps='ps auxf'

alias processtree='ps -e -o pid,args --forest'

# to check a process is running in a box with a heavy load: pss
alias pss='ps -ef | grep $1'								



</t>
<t tx="sa.20110128155259.1964">alias ping='ping -c 10'

# view only the process name using an internet connection
alias appson="netstat -lantp | grep -i stab | awk -F/ '{print $2}' | sort | uniq"	

# processor / memory bandwidthd? in GB/s
alias bandwidth='dd if=/dev/zero of=/dev/null bs=1M count=32768'			

# browse services advertised via Bonjour
# alias daemons='ls /var/run/daemons'

# copy remote db to local
alias dns='cat /etc/resolv.conf'			# view DNS numbers

# start "iftop" program (sudo apt-get install iftop)
# like top, but for files
# alias ftop='watch -d -n 2 'df; ls -FlAt;''		
# alias iftop='sudo iftop -i eth0' 							

# lists all listening ports together with PID of associated process
alias listen='sudo netstat -pnutl'

# to display open sockets ( -P option to lsof disables port names)
alias lsock='sudo /usr/sbin/lsof -i -P'


alias net1='watch --interval=2 "sudo netstat -apn -l -A inet"'
alias net2='watch --interval=2 "sudo netstat -anp --inet --inet6"'
alias net3='sudo lsof -i'
alias net4='watch --interval=2 "sudo netstat -p -e --inet --numeric-hosts"'
alias net5='watch --interval=2 "sudo netstat -tulpan"'
alias net6='sudo netstat -tulpan'
alias net7='watch --interval=2 "sudo netstat -utapen"'
alias net8='watch --interval=2 "sudo netstat -ano -l -A inet"'
alias netapps="lsof -P -i -n | cut -f 1 -d ' '| uniq | tail -n +2"

# start "nethogs" program (sudo apt-get install nethogs)
alias nethogs='sudo nethogs eth0'
		
alias netl='sudo nmap -sT -O localhost'

# to scan your environment for available networks, do the following
alias netscan='sudo iwlist wlan0 scan'
# if card supports it, you can collect wireless statistics by using
alias netstats='sudo iwspy wlan0'							
# view network device info
alias network='sudo lshw -C network' 							

# dump all the network activity except ssh stuff
alias networkdump='sudo tcpdump not port 22' 	
alias nsl='netstat -f inet | grep -v CLOSE_WAIT | cut -c-6,21-94 | tail +2'		# show all programs connected or listening on a network port
alias ns='netstat -alnp --protocol=inet | grep -v CLOSE_WAIT | cut -c-6,21-94 | tail +2'
alias openports='sudo netstat -nape --inet' 	# view open ports
alias pkt_trace='sudo tcpflow -i `active_net_iface` -c'
alias ports='lsof -i -n -P' 	# view programs using an internet connection
alias portstats='sudo netstat -s'
</t>
<t tx="sa.20110128155259.1965">alias packup='/bin/tar -czvf' # compress a file in tar format
alias contents='/bin/tar -tzf' # can view the contents of a Tar file
alias tc='tar cfvz'
alias tx='tar xfvz'

alias unpack='/bin/tar -xzvpf' # uncompress a a Tar file
</t>
<t tx="sa.20110128155259.1966">alias tf='tail -50f /var/log/iptables.log'
alias tm='tail -50f /var/log/messages.log'
alias ts='tail -50f /var/log/auth.log'
alias logs='tail -f /var/log/messages /var/log/*log'

# forensic tool to find hidden processes and ports
alias hiddenpnps='unhide (proc|sys|brute)'

alias boothistory='for wtmp in `dir -t /var/log/wtmp*`; do last reboot -f $wtmp; done | less'</t>
<t tx="sa.20110128155259.1968"># Computer cleanup

alias cleanup='sudo apt-get -y autoclean &amp;&amp; sudo apt-get -y autoremove &amp;&amp; sudo apt-get -y clean &amp;&amp; sudo apt-get -y remove &amp;&amp; sudo deborphan | xargs sudo apt-get -y remove --purge'

# purge configuration files of removed packages on debian systems
alias configpurge="sudo aptitude purge `dpkg --get-selections | grep deinstall | awk '{print $1}'`"	

# remove all unused Linux Kernel headers, images &amp; modules
alias kernelcleanup="dpkg -l 'linux-*' | sed '/^ii/!d;/'"$(uname -r | sed "s/\(.*\)-\([^0-9]\+\)/\1/")"'/d;s/^[^ ]* [^ ]* \([^ ]*\).*/\1/;/[0-9]/!d' | xargs sudo apt-get -y purge"
								
alias orphaned='sudo deborphan | xargs sudo apt-get -y remove --purge'

</t>
<t tx="sa.20110128155259.1969"># displays global disk usage by partition, excluding supermounted devices		
alias df='df -h -x tmpfs -x usbfs'	
alias directorydiskusage='du -s -k -c * | sort -rn'

# displays disk usage by directory, in human readable format
alias du='du -h --max-depth=1'

# easily find megabyte eating files or directories
alias dush='du -sm *|sort -n|tail'	 

alias diskwho='sudo iotop'

alias sizeof='du -sh'
alias space='df -h' # disk space usage

# displays the top ten biggest folders/files in the current directory
alias topten='du -sk $(/bin/ls -A) | sort -rn | head -10'	

# find the 20 biggest directories on the current filesystem
alias top20='du -xk | sort -n | tail -20'					

# hard disk information - model/serial no.
alias hdinfo='hdparm -i[I] /dev/sda'	</t>
<t tx="sa.20110128155259.1970"># overview of the hardware in the computer
alias hardware='sudo lshw -html &gt; hardware.html'					
</t>
<t tx="sa.20110128155259.1971"># to find CPU hogs
alias cpu_hogs='ps wwaxr -o pid,stat,%cpu,time,command | head -10'

# continual 'top' listing (every 10 sec) showing top 15 CPU things
alias topforever='top -l 0 -s 10 -o cpu -n 15'						

</t>
<t tx="sa.20110128155259.1972">alias ffind='sudo find / -name $1'

alias superfind='sudo find / ! \( -path /proc -prune -o -path /tmp -prune -o -path /dev -prune -o -path /mnt -prune \) -name'
</t>
<t tx="sa.20110128155259.1973">alias free='free -m'	# RAM and SWAP detail in MBs

# display the processes that are using the most CPU time and memory
alias hogc='ps -e -o %cpu,pid,ppid,user,cmd | sort -nr | head'				

# display the processes that are using the most CPU time and memory
alias hogm='ps -e -o %mem,pid,ppid,user,cmd | sort -nr | head'

# to find memory hogs
alias mem_hogs_ps='ps wwaxm -o pid,stat,vsize,rss,time,command | head -10'		

# to find memory hogs
alias mem_hogs_top='top -l 1 -o rsize -n 10'

alias processbymemusage='ps -e -o rss=,args= | sort -b -k1,1n | pr -TW$COLUMNS'

# release memory used by the Linux kernel on caches
alias memrel='free &amp;&amp; sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches &amp;&amp; free'
</t>
<t tx="sa.20110128155259.1974">##################################################
# Information (clock and date stuff)		 #
##################################################

alias bdate="date '+%a, %b %d %Y %T %Z'"
alias cal='cal -3' 									# show 3 months by default
alias da='date "+%Y-%m-%d %A    %T %Z"'							# date command
alias da_="date +'%a %Y-%m-%d %H:%M:%S %z'"						# another date command
alias dateh='date --help|sed "/^ *%a/,/^ *%Z/!d;y/_/!/;s/^ *%\([:a-z]\+\) \+/\1_/gI;s/%/#/g;s/^\([a-y]\|[z:]\+\)_/%%\1_%\1_/I"|while read L;do date "+${L}"|sed y/!#/%%/;done|column -ts_'	# view all date formats, quick reference help alias
alias daysleft='echo "There are $(($(date +%j -d"Dec 31, $(date +%Y)")-$(date +%j))) left in year $(date +%Y)."'	# how many days until the end of the year
alias epochtime='date +%s'								# report number of seconds since the Epoch
alias mytime='date +%H:%M:%S'								# shows just the current time
alias ntpdate='sudo ntpdate ntp.ubuntu.com pool.ntp.org'				# time synchronisation with NTP
alias oclock='read -a A&lt;&lt;&lt;".*.**..*....*** 8 9 5 10 6 0 2 11 7 4";for C in `date +"%H%M"|fold -w1`;do echo "${A:${A[C+1]}:4}";done'   # odd clock
alias onthisday='grep -h -d skip `date +%m/%d` /usr/share/calendar/*'			# on this day
alias secconvert='date -d@1234567890'							# convert seconds to human-readable format
alias stamp='date "+%Y%m%d%a%H%M"'							# timestamps
alias timestamp='date "+%Y%m%dT%H%M%S"'							# date command that lets you create timestamps in ISO 8601 format
alias today='date +"%A, %B %-d, %Y"'
alias weeknum='date +%V'								# perl one-liner to get the current week number
</t>
</tnodes>
</leo_file>
